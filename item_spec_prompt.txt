以下是为两个 Agent 准备的 Prompt。

---

### 1. 给 Agent A (Parsing Expert) 的 Prompt

**目标**：生成 `extract_context` 函数，能够处理 STA Log、Netlist Header 和 SPEF Header 三种文本格式。

**Prompt 内容：**

```markdown
# Role
You are the **Parsing Expert Agent** for the "Hierarchical Checker Architecture 10.2".
Your task is to write the `extract_context` Python function (Atom A).

# Input Context (From ItemSpec IMP-10-0-0-00)
We need to extract metadata from EDA design files. The input `text` can be content from an STA Log, a Verilog Netlist, or a SPEF file.

**Target Extraction Logic:**
1. **STA Log Mode**: Look for lines indicating files are loaded.
   - Keywords: "Reading netlist", "read_spef", "Reading parasitics".
   - Regex Pattern to target: `(?i)(reading|loaded|read_\w+).*?(netlist|spef|verilog|parasitics)`
2. **Netlist Header Mode**: Look for generator version info.
   - Comment style: `//` or `/*`.
   - Keywords: "Generator", "Created by", "Tool", "Version", "Date".
3. **SPEF Header Mode**: Look for standard header fields.
   - Pattern: `*SPEF`, `*program`, `*version`, `*date`.

# 10.2 Architecture Constraints (NON-NEGOTIABLE)
1. **Pure Function**: You must NOT use `open()`, `read()`, or file paths. You process the `text` string provided in arguments.
2. **Type Hard Lock**: The `value` key in the output dictionary MUST be a string (`str`).
3. **PR5**: Do NOT filter results. Extract EVERYTHING that looks like a match.
4. **Schema**: Your output must be a `List[Dict]` where each dict has:
   - `value`: (str) The primary string used for matching (e.g., "Netlist version: Innovus 21.1").
   - `source_file`: (str) Passed from input argument.
   - `line_number`: (int) The line where match occurred.
   - `matched_content`: (str) The raw line text.
   - `parsed_fields`: (dict) A dictionary containing the detailed metadata (tool_name, timestamp, etc.) as requested in the ItemSpec Section 1.1 and 1.2.

# Task
Generate the Python code for `extract_context(text: str, source_file: str) -> List[Dict]`.
Ensure you handle the logic to detect which format the `text` belongs to (heuristics based on content) or simply apply all regexes safely.
```

---

### 2. 给 Agent B (Logic Expert) 的 Prompt

**目标**：生成符合 10.2 规范的**通用** `validate_logic` 和 `check_existence` 代码，并**生成对应的 YAML 配置**来证明它能覆盖 IMP-10 的需求。

**Prompt 内容：**

```markdown
# Role
You are the **Logic Developer Agent** for the "Hierarchical Checker Architecture 10.2".
Your task is to generate the "Universal Logic Atoms" (Atom B & C) and the "Policy Configuration" (YAML).

# Context (ItemSpec IMP-10-0-0-00)
The user wants to validate EDA tool versions.
- **Check Requirement**: Verify tool is "Innovus" or "Genus" and version contains "21.1".
- **Waiver Scenario**: If the design is "academic" or "test", waive the version check.

# Task 1: Mechanism (Python Code)
Write the **Universal** logic functions. Do NOT hardcode "Innovus" or "21.1" inside the Python code. The code must be generic to handle ANY pattern provided by the YAML.

**Constraints for Atom B (`validate_logic`)**:
1. **Signature**: `def validate_logic(text, pattern, parsed_fields=None, default_match="contains", regex_mode="search")`
2. **Hard Precedence Rules**:
   - Priority 1: Alternatives (if `|` is present). Example: "Genus|Innovus" -> Split and check if ANY exists.
   - Priority 2: Regex (if starts with `regex:`). Example: "regex:^Version \d+\.\d+" -> Use `re.search` or `re.match` based on `regex_mode`.
   - Priority 3: Wildcard (if `*` is present). Example: "*2025*" -> Use `fnmatch`.
   - Priority 4: Default. Use string containment (if `default_match="contains"`) or equality.
3. **Safety**: Catch `re.error` and return `is_match=False`.

**Constraints for Atom C (`check_existence`)**:
1. Just return `{'is_match': True, 'evidence': items}` if list is not empty. This is for Gate 1 compliance.

# Task 2: Policy (Pseudo-YAML)
Based on the ItemSpec IMP-10 described in Context, generate the YAML `requirements` and `waivers` sections that would DRIVE your code to pass the checks.

**Example YAML Requirement**:
`pattern: "Genus|Innovus"` (Should utilize your Alternative logic)

# Output Format
Provide the Python code first, followed by the YAML block.
```

---

### 3. 预期结果与差异点

#### **Agent A 的产出 (Extraction)**
Agent A 会生成一段复杂的 Python 代码，包含大量的 `re.findall` 或 `re.search`，专门用于解析 ItemSpec 中提到的那些复杂的日志格式。
*   **关键点**：它会把解析出的 `tool_name: "Innovus"` 等信息放入 `parsed_fields` 字典中，并将 `value` 构造成易于比对的字符串（例如 `"Tool: Innovus Version: 21.1"`）。

#### **Agent B 的产出 (Logic)**
Agent B 会生成一段**标准化的、甚至有些“枯燥”的**代码。
*   **关键点**：它的代码里**完全看不到** "Innovus" 或 "SPEF" 这些字眼。它只关心如何处理 `|`、`*` 和 `regex:`。
*   **但是**，它生成的 YAML 部分会展示如何配置：
    ```yaml
    # Agent B 生成的建议配置
    requirements:
      pattern_items:
        - "Innovus|Genus"  # 利用 Atom B 的 split('|') 逻辑
        - "regex:Version 2\." # 利用 Atom B 的正则逻辑
    ```

