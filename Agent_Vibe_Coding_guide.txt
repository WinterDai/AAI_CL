---

# Vibe Coding 落地实施指南：Architecture 10.2

**目标**：构建一个 Developer Agent，让用户只需“扔进去一段日志和一个想法（Vibe）”，Agent 就能自动产出符合 10.2 铁律的 Python Atom 代码。

---

## 1. 架构选型：为什么必须是 LangGraph？

在“Vibe Coding”的体验下，用户感觉是随意的，但在后台，Agent 的执行必须是**确定性**的。

*   **选型结论**：**LangGraph** (推荐) > CrewAI。
*   **决策依据**：
    *   **确定性控制 (Deterministic Control)**：源文件指出，CrewAI 适合创意头脑风暴，但在生产环境中，其抽象层会导致“黑盒”问题，难以调试。而 LangGraph 基于**状态机（State Machine）**，允许我们显式定义“如果代码未通过 Gate 1 检查，必须回滚并重写”的死循环逻辑。
    *   **人机交互 (HITL)**：LangGraph 原生支持**中断（Interrupts）**。如果 Agent 对日志格式不确定，它可以暂停并向用户反问：“这里的 `10.2` 是版本号还是错误码？”，获得用户反馈后继续执行，这正是 Vibe Coding 的精髓——**人机协同**。

---

## 2. 认知流设计 (The Cognitive Architecture)

我们要构建一个 **"Reflective Coder" (反思型编码者)** 工作流。请在 LangGraph 中定义以下节点（Nodes）和状态（State）。

### 2.1 定义状态 (Shared State)
根据最佳实践，状态必须是类型化的（TypedDict）：

```python
class DeveloperState(TypedDict):
    user_intent: str          # 用户的自然语言需求
    log_snippet: str          # 日志样本
    generated_code: str       # Agent 生成的 Python 代码
    pseudo_contract: str      # Agent 生成的 YAML 契约
    error_logs: List[str]     # Gate 检查的报错信息
    iteration_count: int      # 循环次数（防止死循环）
```

### 2.2 工作流图谱 (The Graph)

该图谱包含三个核心节点和一个条件边：

1.  **Draft Node (起草)**：
    *   **输入**：日志 + 需求。
    *   **动作**：识别日志模式（Regex/Delimiters），编写 Atom A/B。
    *   **策略**：使用 "CoT (Chain of Thought)"，先写伪代码，再写 Python。

2.  **Gatekeeper Node (守门人 - 关键)**：
    *   **动作**：运行静态分析（AST Parse）+ Gate 1/2 测试。
    *   **检查项（基于 10.2 Spec）**：
        *   *IO Ban*: 代码里有 `open()`, `read()`, `print()` 吗？-> Fail。
        *   *Type Lock*: `extract_context` 里有 `str()` 强转吗？-> Fail（Plan_v2.txt L43）。
        *   *Atom A Sig*: `extract_context(text: str, source_file: str)` 双参数？-> Fail（Plan_v2.txt L18）。
        *   *Atom B Sig*: `validate_logic` 接受 `default_match` 和 `regex_mode` 参数了吗？-> Fail（Plan_v2.txt L73-74）。
        *   *Atom B 'kind' Field*: MatchResult 必须返回 `{'is_match', 'reason', 'kind'}`？-> Fail（Plan_v2.txt L71, L95, L120, L133）。
        *   *Atom C 'evidence' Field*: check_existence 返回 `{'is_match', 'reason', 'evidence'}`？-> Fail（Plan_v2.txt L157）。
        *   *Gate 2 Tests*: 7个测试向量全部通过（None-Safety, Empty Alternatives, Bad Regex, Literal Alternatives, Wildcard Priority, Default Strategy, Invalid regex_mode）？-> Fail（Plan_v2.txt L431-452）。
    *   **输出**：更新 `error_logs`。

3.  **Reflect Node (反思与修复)**：
    *   **触发条件**：`error_logs` 不为空。
    *   **动作**：Agent 阅读报错信息，修改 `generated_code`。
    *   **Prompt 注入**："你之前的代码违背了 10.2 规范，错误是 X，请修复它。"

4.  **条件边 (Conditional Edge)**：
    *   如果 `error_logs` 为空 -> **End** (输出代码)。
    *   如果 `error_logs` 有值 -> 回到 **Reflect Node** (最多重试 3 次)。

---

## 3. 上下文工程 (Context Engineering)

为了让 Agent "懂" 10.2 架构，不能把整个文档扔给它（会导致注意力分散）。根据 Anthropic 的上下文工程指南，我们需要**精简且高信噪比**的 Prompt。

### System Prompt 模板 (针对 Draft Node)

```markdown
# Role
You are a Senior EDA Tool Developer specializing in the "Hierarchical Checker Architecture 10.2".

# The 10.2 Hard Constraints (Memorize These)
1. **No IO**: You interpret strings, you never read files.
2. **Atom A Signature**: `extract_context(text: str, source_file: str) -> List[Dict]` (Plan_v2.txt L18).
3. **Atom A Type Lock**: You MUST cast all extracted values to `str`. Example: `val = str(item.get('val'))` (Plan_v2.txt L43).
4. **Atom B Signature**: `validate_logic(text, pattern, parsed_fields=None, default_match="contains", regex_mode="search")` (Plan_v2.txt L73-74).
5. **Atom B Precedence**: Alternatives (`|`) > Regex (`regex:`) > Wildcard (`*`) > Default (Plan_v2.txt L85-133).
6. **Atom B MatchResult Schema**: MUST return `{'is_match': bool, 'reason': str, 'kind': str}` (Plan_v2.txt L71, L95, L120, L133).
   - 'kind' values: "alternatives", "regex", "wildcard", "contains", "exact" (Plan_v2.txt L71, L95, L120, L133).
7. **Atom C check_existence Schema**: MUST return `{'is_match': bool, 'reason': str, 'evidence': List}` (Plan_v2.txt L157).
8. **Standardization Layer**: Atom A MUST include the locked standardization code after extraction logic (Plan_v2.txt L40-54).

# Your Task
Analyze the user's log snippet.
Generate TWO artifacts:
1. The Python Atoms (Mechanism).
2. The ItemSpec YAML (Policy).

# Reference Examples (Few-Shot)
[Insert a perfect pair of Atom A code and corresponding log snippet here]
```

---

## 4. 落地实施：代码生成与工具集成

根据源文件，推荐使用 **OpenAI Agents SDK** 或 **LangGraph** 的 Python 接口来实现。

### 步骤 1：构建 Sandbox 工具
Agent 需要一个“沙箱工具”来验证代码是否跑得通。不要让 Agent 瞎写，给它一把“尺子”。

```python
@tool
def validate_10_2_compliance(code_str: str) -> str:
    """
    静态分析工具：检查代码是否违反了 10.2 规范。
    返回："PASS" 或 具体错误信息。
    
    检查项（基于 Plan_v2.txt 第5节 Gate 1/2 要求）：
    1. **Signature**: Atom A/B/C 函数名存在？Atom B 接受 default_match 和 regex_mode？
    2. **IO Ban**: 代码中不允许出现 open(), read(), write(), print() 等 IO 操作（Plan_v2.txt L14）。
    3. **Atom A Schema**: ParsedItem 必须包含 {'value', 'source_file', 'line_number', 'matched_content', 'parsed_fields'}（Plan_v2.txt L414-422）。
    4. **Type Safety**: item['value'] 必须是 str 类型（Plan_v2.txt L426）。
    5. **Atom B 'kind' Field**: MatchResult 返回值必须包含 'kind' 键（Plan_v2.txt L71等）。
    6. **Atom C 'evidence' Field**: check_existence 返回值必须包含 'evidence' 键（Plan_v2.txt L157）。
    
    注意：Plan_v2.txt 并未提供 AST 实现细节，开发者需要自行实现 AST 解析逻辑或使用 Python ast 模块。
    推荐参考 Work/verify_agent_guide.py 中的验证逻辑。
    """
    # 实现者需要补充：AST parsing + signature extraction + return value inspection
    pass 
```

### 步骤 2：流式输出 (Streaming)
为了达到 "Vibe Coding" 的流畅感，Agent 的思考过程和代码生成过程需要**流式传输**到前端。
*   **User Experience**: 用户不应该等 30 秒才看到结果。他们应该看到：“正在分析日志结构... 识别到时间戳... 正在编写正则... 校验 10.2 合规性... 修正类型错误... 完成。”

---

## 5. 总结：从 Guide 到落地的差异表

| 之前的 Guide | Vibe Coding 增强版 Guide | 来源依据 |
| :--- | :--- | :--- |
| **单次生成** | **循环生成 (Reflective Loop)**：写代码 -> 跑检查 -> 改代码。 | Reflection Pattern |
| **人工审查** | **自动化 Guardrails**：利用 AST 工具自动拦截 IO 操作，无需人工介入。 | Reliability through Validation |
| **通用 Prompt** | **上下文工程**：将 10.2 Spec 拆解为 Few-Shot 示例，注入到 System Prompt。 | Few-shot prompting |
| **黑盒交付** | **白盒状态机**：用户可见 Agent 在哪一步（分析、编码、还是修复）。 | Observability |

### 最终建议行动点

1.  **采用 LangGraph**：构建 `Draft -> Validate -> Reflect` 的循环图。
2.  **编写 AST 校验器**：作为 Agent 的核心工具（Tool），强制执行“IO 禁令”和“Str 转换”。
3.  **Prompt 优化**：将 `Plan_v2.txt` 中的代码作为 **Few-Shot Examples** 放入 Prompt，让 Agent 模仿而不是猜测。