{
  "timestamp": "2026-01-28T14:06:01.329557",
  "prompt": "# Role\nYou are the **Logic Developer Agent** for \"Hierarchical Checker Architecture 10.2\".\nYour task is to generate the \"Universal Logic Atoms\" (Atom B & C) and the \"Policy Configuration\" (YAML).\n\n# The 10.2 Hard Constraints (NON-NEGOTIABLE)\n\n## Atom B: validate_logic\n1. **Signature**: `def validate_logic(text, pattern, parsed_fields=None, default_match=\"contains\", regex_mode=\"search\")`\n2. **Hard Precedence Rules** (MUST implement in this EXACT order):\n   - Priority 1: **Alternatives** (if `|` in pattern) → Split by `|` and check if ANY segment matches via containment\n   - Priority 2: **Regex** (if pattern starts with `regex:`) → Use `re.search` or `re.match` based on `regex_mode`\n   - Priority 3: **Wildcard** (if `*` or `?` in pattern) → Use `fnmatch.fnmatchcase`\n   - Priority 4: **Default** → String containment or equality based on `default_match` param\n3. **Return Schema**: `{'is_match': bool, 'reason': str, 'kind': str}`\n   - `kind` values MUST be one of: `\"alternatives\"`, `\"regex\"`, `\"wildcard\"`, `\"contains\"`, `\"exact\"`\n4. **Safety Requirements**:\n   - **None Safety**: Handle `parsed_fields=None` without raising exception\n   - **Bad Regex Safety**: Catch `re.error` and return `is_match=False` with reason starting with `\"Invalid Regex:\"`\n   - **Invalid regex_mode Safety**: If `regex_mode` is not `\"match\"` or `\"search\"`, default to `\"search\"` behavior\n5. **Binding Constraint**: Use `re.match` when `regex_mode=='match'` and `re.search` when `regex_mode=='search'`\n\n## Atom C: check_existence\n1. **Signature**: `def check_existence(items: List[Dict]) -> Dict`\n2. **Return Schema**: `{'is_match': bool, 'reason': str, 'evidence': items}`\n3. **Logic**: Return `is_match=True` if items list is non-empty, pass through evidence\n\n# Gate 2 Test Vectors (YOUR CODE MUST PASS ALL)\nYour implementation will be tested against these exact cases:\n1. `validate_logic(\"abc\",\"a\", parsed_fields=None)` → no exception raised\n2. `validate_logic(\"abc\",\"|a||\")` → `is_match=True`, `kind=\"alternatives\"`\n3. `validate_logic(\"abc\",\"regex:[\", regex_mode=\"search\")` → `is_match=False`, reason startswith `\"Invalid Regex:\"`\n4. `validate_logic(\"regex:^a\", \"regex:^a|zzz\")` → match (literal alternatives, NOT regex)\n5. `validate_logic(\"abc\",\"a*c\")` → `kind=\"wildcard\"`\n6. `validate_logic(\"abc\",\"b\", default_match=\"contains\")` → match; `validate_logic(\"abc\",\"b\", default_match=\"exact\")` → no match\n7. `validate_logic(\"abc\",\"regex:^a\", regex_mode=\"BAD\")` → must NOT raise, defaults to search behavior\n\n# YAML Field Semantics Reference\nUse this reference when generating YAML configuration:\n\n## Checker Type System (4 Types)\n| Type   | Pattern Search | Waiver Support | requirements.value | waivers.value |\n|--------|----------------|----------------|--------------------|---------------|\n| Type 1 | No             | No             | N/A                | N/A           |\n| Type 2 | Yes            | No             | integer (>0)       | N/A           |\n| Type 3 | Yes            | Yes            | integer (>0)       | 0 or >0       |\n| Type 4 | No             | Yes            | N/A                | 0 or >0       |\n\n## requirements.value Semantics\n- **N/A**: Type 1/4, no pattern search (boolean check only)\n- **Integer (>0)**: Type 2/3, count of pattern_items list\n\n## requirements.pattern_items Format\n- **Contains Match (Default)**: `\"2025\"` → checks if \"2025\" in item.value\n- **Wildcard Match**: `\"*Genus*\"` → fnmatch(item.value, \"*Genus*\")\n- **Regex Match**: `\"regex:\\d{4}\"` → re.search(\"\\d{4}\", item.value)\n- **Alternatives**: `\"2025|Genus\"` → split by |, any one match is sufficient\n\n## waivers.value Semantics\n- **N/A**: Type 1/2, no waiver support\n- **0**: Global waiver mode, all violations → INFO, auto PASS\n- **>0**: Selective waiver mode, count of waive_items patterns\n\n## waivers.waive_items Behavior\n- **When value=0**: Contains comments/reasons (informational)\n- **When value>0**: Contains actual waiver patterns (same format as pattern_items)\n\n# CRITICAL: Zero Hardcoding Policy\n- Your Python code MUST be **UNIVERSAL**\n- Do NOT include any item-specific keywords (tool names, file patterns, version numbers)\n- All business logic is driven by the YAML configuration, NOT hardcoded in Python\n\n# Task 1: Mechanism (Python Code)\nWrite UNIVERSAL logic functions. The same code works for ALL items.\n\n# Task 2: Policy (YAML Configuration)\nBased on the ItemSpec, generate the YAML configuration that DRIVES your universal code.\nUse pattern types (alternatives, regex, wildcard) appropriately.\n\n# Output Format\n```python\n# === ATOM B ===\ndef validate_logic(text, pattern, parsed_fields=None, default_match=\"contains\", regex_mode=\"search\"):\n    ...\n\n# === ATOM C ===\ndef check_existence(items):\n    ...\n```\n\n```yaml\n# === YAML Configuration ===\nrequirements:\n  value: ...\n  pattern_items: [...]\nwaivers:\n  value: ...\n  waive_items: [...]\n```\n\n---\n\n# ItemSpec Content\n_item_id: IMP-10-0-0-00\n_source_path: C:\\Users\\wentao\\Desktop\\AAI\\Main_work\\ACL\\Agentic-AI\\Agents\\codegen\\IMP-10-0-0-00_ItemSpec.md\nraw_content: \"# ItemSpec: IMP-10-0-0-00\\n\\n## 1. Parsing Logic\\n\\n**Information to\\\n  \\ Extract**:\\n\\n### 1.1 Netlist File Information\\n- **Purpose**: Extract version\\\n  \\ metadata from netlist files to verify tool, version, and generation timestamp\\\n  \\ information\\n- **Key Fields**:\\n  - `loaded`: Boolean indicating whether netlist\\\n  \\ file was successfully accessed and parsed\\n  - `tool_name`: String representing\\\n  \\ the EDA tool that generated the netlist (e.g., \\\"Innovus\\\", \\\"Genus\\\", \\\"ICC2\\\"\\\n  , \\\"DC\\\")\\n  - `tool_version`: String representing the tool version number (e.g.,\\\n  \\ \\\"21.1\\\", \\\"2023.03-SP2\\\")\\n  - `timestamp`: String representing the generation\\\n  \\ date/time of the netlist\\n  - `format`: String representing the netlist format\\\n  \\ (e.g., \\\"Verilog\\\", \\\"VHDL\\\", \\\"DEF\\\")\\n\\n### 1.2 SPEF File Information\\n- **Purpose**:\\\n  \\ Extract version metadata from SPEF (Standard Parasitic Exchange Format) files\\\n  \\ to verify extraction tool, version, standard compliance, and generation timestamp\\n\\\n  - **Key Fields**:\\n  - `loaded`: Boolean indicating whether SPEF file was successfully\\\n  \\ accessed and parsed\\n  - `tool_name`: String representing the parasitic extraction\\\n  \\ tool (e.g., \\\"StarRC\\\", \\\"Quantus\\\", \\\"PrimeTime\\\")\\n  - `tool_version`: String\\\n  \\ representing the extraction tool version number\\n  - `timestamp`: String representing\\\n  \\ the generation date/time of the SPEF file\\n  - `standard_version`: String representing\\\n  \\ the IEEE standard version (e.g., \\\"IEEE 1481-1999\\\", \\\"IEEE 1481-2009\\\")\\n\\n###\\\n  \\ 1.3 File Metadata\\n- **Purpose**: Provide traceability information for debugging\\\n  \\ and audit purposes\\n- **Key Fields**:\\n  - `source_file`: Absolute path to the\\\n  \\ input file where information was extracted\\n  - `line_number`: Line number where\\\n  \\ version information was found\\n  - `matched_content`: The actual text line that\\\n  \\ was matched during extraction\\n\\n**Data Structure**: Output structure follows\\\n  \\ global_rules.md Section 2.4.1 (Required metadata + parsed_fields)\\n\\n**parsed_fields\\\n  \\ Example**:\\n```python\\n{\\n  \\\"netlist\\\": {\\n    \\\"loaded\\\": True,\\n    \\\"tool_name\\\"\\\n  : \\\"Innovus\\\",\\n    \\\"tool_version\\\": \\\"21.10-s080_1\\\",\\n    \\\"timestamp\\\": \\\"2025-01-15\\\n  \\ 14:23:45\\\",\\n    \\\"format\\\": \\\"Verilog\\\"\\n  },\\n  \\\"spef\\\": {\\n    \\\"loaded\\\"\\\n  : True,\\n    \\\"tool_name\\\": \\\"StarRC\\\",\\n    \\\"tool_version\\\": \\\"2022.06-SP1\\\",\\n\\\n  \\    \\\"timestamp\\\": \\\"2025-01-15 16:45:12\\\",\\n    \\\"standard_version\\\": \\\"IEEE 1481-2009\\\"\\\n  \\n  }\\n}\\n```\\n\\n**Complete Output Structure Example**:\\n```python\\n[\\n  {\\n   \\\n  \\ \\\"value\\\": \\\"Netlist version: Innovus 21.10-s080_1\\\",\\n    \\\"source_file\\\": \\\"\\\n  /project/design/netlist/top.v.gz\\\",\\n    \\\"line_number\\\": 3,\\n    \\\"matched_content\\\"\\\n  : \\\"// Generator: Cadence Innovus 21.10-s080_1\\\",\\n    \\\"parsed_fields\\\": {\\n  \\\n  \\    \\\"netlist\\\": {\\n        \\\"loaded\\\": True,\\n        \\\"tool_name\\\": \\\"Innovus\\\"\\\n  ,\\n        \\\"tool_version\\\": \\\"21.10-s080_1\\\",\\n        \\\"timestamp\\\": \\\"2025-01-15\\\n  \\ 14:23:45\\\",\\n        \\\"format\\\": \\\"Verilog\\\"\\n      }\\n    }\\n  },\\n  {\\n    \\\"\\\n  value\\\": \\\"SPEF version: IEEE 1481-2009\\\",\\n    \\\"source_file\\\": \\\"/project/design/spef/top.spef.gz\\\"\\\n  ,\\n    \\\"line_number\\\": 1,\\n    \\\"matched_content\\\": \\\"*SPEF \\\\\\\"IEEE 1481-2009\\\\\\\n  \\\"\\\",\\n    \\\"parsed_fields\\\": {\\n      \\\"spef\\\": {\\n        \\\"loaded\\\": True,\\n\\\n  \\        \\\"tool_name\\\": \\\"StarRC\\\",\\n        \\\"tool_version\\\": \\\"2022.06-SP1\\\",\\n\\\n  \\        \\\"timestamp\\\": \\\"2025-01-15 16:45:12\\\",\\n        \\\"standard_version\\\":\\\n  \\ \\\"IEEE 1481-2009\\\"\\n      }\\n    }\\n  }\\n]\\n```\\n\\n## 2. Check Logic\\n\\nBased\\\n  \\ on description \\\"Confirm the netlist/spef version is correct\\\", the following\\\n  \\ items require validation:\\n\\n**Validation Items**:\\n\\n### 2.1 Netlist File Loading\\\n  \\ Status\\n- **Purpose**: Verify netlist file was successfully accessed and parsed\\n\\\n  - **Completeness definition**: \\n  - `parsed_fields.netlist.loaded == True`\\n  -\\\n  \\ File path is accessible and readable\\n- **Validation type**: Existence check (Boolean)\\n\\\n  - **PASS condition**: Netlist file successfully loaded\\n- **FAIL condition**: File\\\n  \\ not found, access denied, or parsing error\\n\\n### 2.2 Netlist Version Completeness\\n\\\n  - **Purpose**: Verify netlist contains complete version metadata\\n- **Completeness\\\n  \\ definition**:\\n  - `parsed_fields.netlist.tool_name` exists and is non-empty\\n\\\n  \\  - `parsed_fields.netlist.tool_version` exists and is non-empty\\n  - `parsed_fields.netlist.timestamp`\\\n  \\ exists and is non-empty\\n  - `parsed_fields.netlist.format` exists and is non-empty\\n\\\n  - **Validation type**: Existence check (Boolean)\\n- **PASS condition**: All mandatory\\\n  \\ version fields present and non-empty\\n- **FAIL condition**: Any mandatory field\\\n  \\ missing or empty\\n\\n### 2.3 SPEF File Loading Status\\n- **Purpose**: Verify SPEF\\\n  \\ file was successfully accessed and parsed\\n- **Completeness definition**:\\n  -\\\n  \\ `parsed_fields.spef.loaded == True`\\n  - File path is accessible and readable\\n\\\n  - **Validation type**: Existence check (Boolean)\\n- **PASS condition**: SPEF file\\\n  \\ successfully loaded\\n- **FAIL condition**: File not found, access denied, or parsing\\\n  \\ error\\n\\n### 2.4 SPEF Version Completeness\\n- **Purpose**: Verify SPEF contains\\\n  \\ complete version metadata\\n- **Completeness definition**:\\n  - `parsed_fields.spef.tool_name`\\\n  \\ exists and is non-empty\\n  - `parsed_fields.spef.tool_version` exists and is non-empty\\n\\\n  \\  - `parsed_fields.spef.timestamp` exists and is non-empty\\n  - `parsed_fields.spef.standard_version`\\\n  \\ exists and is non-empty\\n- **Validation type**: Existence check (Boolean)\\n- **PASS\\\n  \\ condition**: All mandatory version fields present and non-empty\\n- **FAIL condition**:\\\n  \\ Any mandatory field missing or empty\\n\\n**Pattern Matching**:\\n- Items requiring\\\n  \\ pattern matching: None (Type 4 checker - Boolean validation only)\\n- Items with\\\n  \\ existence check only: All items (2.1, 2.2, 2.3, 2.4)\\n\\n**Pattern Correspondence\\\n  \\ Order**: \\n- Not applicable (requirements.value = N/A, no pattern_items defined)\\n\\\n  \\n**Overall Pass/Fail Logic**:\\n- **PASS**: All four validation items pass (both\\\n  \\ netlist and SPEF files loaded successfully with complete version information)\\n\\\n  - **FAIL**: Any validation item fails (file loading failure OR incomplete version\\\n  \\ metadata)\\n- **Edge Cases**:\\n  - If netlist loads but SPEF fails \\u2192 FAIL\\\n  \\ (unless waived)\\n  - If version fields exist but contain only whitespace \\u2192\\\n  \\ FAIL (treated as empty)\\n  - If files are compressed (.gz) \\u2192 Must decompress\\\n  \\ before parsing\\n  - If multiple version headers exist \\u2192 Use first occurrence\\n\\\n  \\n**Validation Sequence**:\\n1. Check netlist loading status (Item 2.1)\\n2. If loaded,\\\n  \\ validate netlist version completeness (Item 2.2)\\n3. Check SPEF loading status\\\n  \\ (Item 2.3)\\n4. If loaded, validate SPEF version completeness (Item 2.4)\\n5. Return\\\n  \\ PASS only if all items pass\\n\\n## 3. Waiver Logic\\n\\nBased on description \\\"Confirm\\\n  \\ the netlist/spef version is correct\\\", analyze waiver scenarios for validation\\\n  \\ items:\\n\\n**Waivable Items and Matching Keywords**:\\n\\n### 3.1 SPEF File Loading\\\n  \\ Status (Item 2.3)\\n- **Waiver scenario**: Early design stages where parasitic\\\n  \\ extraction has not yet been performed\\n  - Synthesis stage: Only netlist exists,\\\n  \\ SPEF generation occurs later in P&R flow\\n  - Pre-layout timing analysis: Using\\\n  \\ wireload models instead of extracted parasitics\\n  - Floorplanning stage: Physical\\\n  \\ design not finalized for extraction\\n- **Typical waiver reason**: \\\"Pre-extraction\\\n  \\ design stage - SPEF file not yet available. Using wireload models for timing analysis.\\\"\\\n  \\n- **Matching keywords**: `\\\"SPEF\\\"`, `\\\"synthesis\\\"`, `\\\"pre-extraction\\\"`, `\\\"\\\n  wireload\\\"`, `\\\"early-stage\\\"`, `\\\"floorplan\\\"`\\n- **Business justification**: SPEF\\\n  \\ files are only generated after place-and-route completion. Earlier design stages\\\n  \\ legitimately operate without parasitic data.\\n\\n### 3.2 SPEF Version Completeness\\\n  \\ (Item 2.4)\\n- **Waiver scenario**: Legacy or third-party SPEF files with non-standard\\\n  \\ headers\\n  - Regression testing: Golden reference files from previous tool versions\\\n  \\ may lack complete metadata\\n  - Vendor-provided IP blocks: SPEF files may use\\\n  \\ proprietary header formats\\n  - Format conversion: SPEF files converted from other\\\n  \\ formats may have incomplete version information\\n- **Typical waiver reason**:\\\n  \\ \\\"Legacy SPEF file from regression suite - version metadata grandfathered for\\\n  \\ compatibility\\\"\\n- **Matching keywords**: `\\\"SPEF\\\"`, `\\\"legacy\\\"`, `\\\"golden\\\"\\\n  `, `\\\"regression\\\"`, `\\\"vendor\\\"`, `\\\"third-party\\\"`, `\\\"converted\\\"`\\n- **Business\\\n  \\ justification**: Historical data used for validation may predate current version\\\n  \\ tracking requirements. Functional correctness takes precedence over metadata completeness.\\n\\\n  \\n### 3.3 Netlist Version Completeness (Item 2.2)\\n- **Waiver scenario**: Hand-edited\\\n  \\ or merged netlists lacking tool-generated headers\\n  - ECO (Engineering Change\\\n  \\ Order) flows: Manual netlist modifications for bug fixes\\n  - Netlist merging:\\\n  \\ Combining multiple sub-netlists may strip original headers\\n  - Custom scripting:\\\n  \\ Automated netlist transformations may not preserve version comments\\n- **Typical\\\n  \\ waiver reason**: \\\"ECO-modified netlist - original tool version information removed\\\n  \\ during manual editing\\\"\\n- **Matching keywords**: `\\\"netlist\\\"`, `\\\"ECO\\\"`, `\\\"\\\n  manual\\\"`, `\\\"hand-edit\\\"`, `\\\"merged\\\"`, `\\\"custom\\\"`\\n- **Business justification**:\\\n  \\ Engineering change orders require direct netlist modification. Version tracking\\\n  \\ shifts to ECO documentation rather than file headers.\\n\\n### 3.4 Both Netlist\\\n  \\ and SPEF Version Information (Items 2.2 and 2.4)\\n- **Waiver scenario**: Ideal/academic\\\n  \\ test cases without real tool provenance\\n  - Benchmark circuits: Standard test\\\n  \\ designs (ISCAS, ITC) without tool metadata\\n  - Simulation-only flows: Behavioral\\\n  \\ models not requiring production tool versions\\n  - Algorithm validation: Synthetic\\\n  \\ test cases for checker development\\n- **Typical waiver reason**: \\\"Academic benchmark\\\n  \\ circuit - no production tool version information available\\\"\\n- **Matching keywords**:\\\n  \\ `\\\"benchmark\\\"`, `\\\"test\\\"`, `\\\"simulation\\\"`, `\\\"academic\\\"`, `\\\"synthetic\\\"\\\n  `, `\\\"ISCAS\\\"`, `\\\"ITC\\\"`\\n- **Business justification**: Research and development\\\n  \\ activities use standardized test cases that lack production tool metadata but\\\n  \\ serve valid verification purposes.\\n\\n---\\n\\n**Waiver Modes**:\\n\\n### Global Waiver\\\n  \\ Mode (waivers.value = 0)\\n- **Behavior**: All validation items (2.1, 2.2, 2.3,\\\n  \\ 2.4) are waived unconditionally\\n- **Use cases**:\\n  - Initial checker deployment:\\\n  \\ Gradual rollout without breaking existing flows\\n  - Tool migration periods: Transitioning\\\n  \\ between EDA tool versions\\n  - Emergency bypass: Critical tapeout schedules requiring\\\n  \\ temporary relaxation\\n- **Application**: Set `waivers.value = 0` in configuration\\n\\\n  - **Traceability**: Global waiver reason must be documented in `waivers.waive_reasons[0]`\\n\\\n  \\n### Selective Waiver Mode (waivers.value > 0)\\n- **Behavior**: Only validation\\\n  \\ items matching keywords in `waivers.waive_items` are waived\\n- **Matching strategy**:\\n\\\n  \\  - **Exact matching**: Item identifier must exactly match waive_items entry\\n\\\n  \\    - Example: `waive_items = [\\\"2.3\\\"]` waives only SPEF loading status\\n  - **Keyword\\\n  \\ matching**: Waive_items entries matched against scenario keywords\\n    - Example:\\\n  \\ `waive_items = [\\\"SPEF\\\", \\\"synthesis\\\"]` waives items 2.3 and 2.4 in synthesis\\\n  \\ context\\n  - **Wildcard matching**: Use `\\\"*\\\"` for pattern-based matching\\n \\\n  \\   - Example: `waive_items = [\\\"SPEF*\\\"]` waives all SPEF-related items (2.3, 2.4)\\n\\\n  - **Application**: \\n  - Set `waivers.value = N` where N = number of items in `waivers.waive_items`\\n\\\n  \\  - Populate `waivers.waive_items` with item identifiers or keywords\\n  - Provide\\\n  \\ corresponding reasons in `waivers.waive_reasons`\\n- **Traceability**: Each waived\\\n  \\ item must have corresponding entry in waive_reasons at same index\\n\\n**Implementation\\\n  \\ Guidance**:\\n\\n1. **Waiver-to-Item Mapping**:\\n   - Item 2.1 (Netlist loading):\\\n  \\ Rarely waived - indicates fundamental file access problem\\n   - Item 2.2 (Netlist\\\n  \\ version): Waivable via keywords `\\\"netlist\\\"`, `\\\"ECO\\\"`, `\\\"manual\\\"`, `\\\"benchmark\\\"\\\n  `\\n   - Item 2.3 (SPEF loading): Waivable via keywords `\\\"SPEF\\\"`, `\\\"synthesis\\\"\\\n  `, `\\\"pre-extraction\\\"`\\n   - Item 2.4 (SPEF version): Waivable via keywords `\\\"\\\n  SPEF\\\"`, `\\\"legacy\\\"`, `\\\"vendor\\\"`\\n\\n2. **Keyword Matching Logic**:\\n   ```python\\n\\\n  \\   # Pseudo-code for selective waiver matching\\n   for validation_item in failed_items:\\n\\\n  \\       item_id = validation_item.id  # e.g., \\\"2.3\\\"\\n       item_keywords = validation_item.keywords\\\n  \\  # e.g., [\\\"SPEF\\\", \\\"loading\\\"]\\n       \\n       for waive_entry in waivers.waive_items:\\n\\\n  \\           if waive_entry == item_id:  # Exact match\\n               apply_waiver(validation_item)\\n\\\n  \\           elif any(keyword in waive_entry for keyword in item_keywords):  # Keyword\\\n  \\ match\\n               apply_waiver(validation_item)\\n   ```\\n\\n3. **Traceability\\\n  \\ Requirements**:\\n   - Each waiver must reference specific validation item(s) by\\\n  \\ ID\\n   - Waiver reason must include business justification and approver information\\n\\\n  \\   - Waiver application must be logged with timestamp and user context\\n   - Audit\\\n  \\ trail must link waived failures to original check results\\n\\n4. **Best Practices**:\\n\\\n  \\   - Prefer selective waivers over global waivers for better traceability\\n   -\\\n  \\ Document waiver expiration conditions (e.g., \\\"valid until P&R completion\\\")\\n\\\n  \\   - Review and refresh waivers periodically (recommend quarterly)\\n   - Escalate\\\n  \\ repeated waivers as potential flow issues requiring root cause analysis\\n\\n##\\\n  \\ 4. Implementation Guide\\n\\n### 4.1 Item-Specific Implementation Points\\n\\n**Data\\\n  \\ Source Inference**:\\n- **Primary data source**: Static Timing Analysis (STA) log\\\n  \\ files\\n  - Recommended file patterns: `sta*.log`, `timing*.log`, `primetime*.log`,\\\n  \\ `tempus*.log`\\n  - These logs typically contain file loading messages and version\\\n  \\ information\\n- **Secondary data source**: Netlist and SPEF file headers\\n  - Netlist\\\n  \\ files: `*.v`, `*.v.gz`, `*.vg`\\n  - SPEF files: `*.spef`, `*.spef.gz`\\n  - File\\\n  \\ headers contain generator tool and version metadata\\n- **Fallback strategy**:\\\n  \\ If STA logs unavailable, parse netlist/SPEF files directly\\n\\n**Information Extraction\\\n  \\ Methods**:\\n\\n- **File Loading Status**: Extract from STA log file loading messages\\n\\\n  \\  - **Innovus/Tempus**: Search for keywords:\\n    - `\\\"Reading netlist\\\"`, `\\\"\\\n  read_netlist\\\"`, `\\\"Netlist loaded\\\"`\\n    - `\\\"Reading SPEF\\\"`, `\\\"read_spef\\\"\\\n  `, `\\\"SPEF loaded\\\"`\\n  - **PrimeTime**: Search for keywords:\\n    - `\\\"read_verilog\\\"\\\n  `, `\\\"Reading Verilog netlist\\\"`\\n    - `\\\"read_parasitics\\\"`, `\\\"Reading SPEF\\\"\\\n  `\\n  - **Genus**: Search for keywords:\\n    - `\\\"read_hdl\\\"`, `\\\"Reading design\\\"\\\n  `\\n  - **Extraction pattern**: `(?i)(reading|loaded|read_\\\\w+).*?(netlist|spef|verilog|parasitics)`\\n\\\n  \\  - **Success indicators**: Look for \\\"successfully\\\", \\\"completed\\\", or absence\\\n  \\ of error messages\\n\\n- **Netlist Version Information**: Extract from netlist file\\\n  \\ headers (first 50-100 lines)\\n  - **Location**: Comment blocks at file beginning\\n\\\n  \\  - **Comment formats**: \\n    - Verilog: `//` or `/* ... */`\\n    - VHDL: `--`\\n\\\n  \\  - **Keywords to search**:\\n    - Tool name: `\\\"Generator\\\"`, `\\\"Created by\\\"\\\n  `, `\\\"Tool\\\"`, `\\\"Synthesized by\\\"`\\n    - Version: `\\\"version\\\"`, `\\\"Version\\\"\\\n  `, `\\\"Ver\\\"`, `\\\"Release\\\"`\\n    - Date: `\\\"Date\\\"`, `\\\"Generated on\\\"`, `\\\"Timestamp\\\"\\\n  `\\n  - **Parsing pattern**: `(?i)(generator|created by|tool):\\\\s*(\\\\w+)\\\\s+(version\\\\\\\n  s+)?([0-9.]+)`\\n  - **Date pattern**: `(?i)(date|generated on):\\\\s*(\\\\d{4}[-/]\\\\\\\n  d{2}[-/]\\\\d{2}|\\\\d{2}[-/]\\\\d{2}[-/]\\\\d{4})`\\n\\n- **SPEF Version Information**: Extract\\\n  \\ from SPEF file headers\\n  - **Location**: First 20-30 lines of SPEF file\\n  -\\\n  \\ **Standard format**: IEEE 1481-1999 or IEEE 1481-2009\\n  - **Keywords to search**:\\n\\\n  \\    - `*SPEF`, `*DESIGN`, `*DATE`, `*VENDOR`, `*PROGRAM`, `*VERSION`\\n  - **Parsing\\\n  \\ pattern**: `\\\\*(\\\\w+)\\\\s+\\\"([^\\\"]+)\\\"`\\n  - **Version extraction**: Combine `*PROGRAM`\\\n  \\ and `*VERSION` fields\\n  - **Date extraction**: `*DATE` field (format varies by\\\n  \\ tool)\\n\\n**Adaptive Learning Strategy**:\\n- **Do not assume fixed formats**: Different\\\n  \\ EDA tools use different header formats\\n  - Learn from actual file content structure\\n\\\n  \\  - Use flexible regex patterns with case-insensitive matching\\n  - Extract all\\\n  \\ comment blocks and search for version-related keywords\\n- **Fallback handling**:\\n\\\n  \\  - If netlist file not found in STA log: Search for `*.v` or `*.vg` files in design\\\n  \\ directory\\n  - If SPEF file not found: Mark `spef.loaded = False`, set other SPEF\\\n  \\ fields to `null`\\n  - If version information incomplete: Mark corresponding completeness\\\n  \\ fields as `False`\\n- **Error tolerance**:\\n  - Compressed files (`.gz`): Decompress\\\n  \\ before parsing\\n  - Encoding issues: Try UTF-8, then Latin-1, then ignore errors\\n\\\n  \\  - Malformed headers: Continue parsing, mark fields as missing rather than failing\\\n  \\ completely\\n  - Multiple files: If multiple netlist/SPEF files found, extract\\\n  \\ from all and report in metadata\\n\\n**Multi-Stage Extraction Strategy**:\\n1. **Stage\\\n  \\ 1**: Parse STA log to identify file paths\\n   - Extract netlist file path from\\\n  \\ loading messages\\n   - Extract SPEF file path from loading messages\\n2. **Stage\\\n  \\ 2**: Parse identified files for version metadata\\n   - Open netlist file, read\\\n  \\ header comments\\n   - Open SPEF file, read header directives\\n3. **Stage 3**:\\\n  \\ Combine information\\n   - Merge loading status from Stage 1 with version info\\\n  \\ from Stage 2\\n   - Populate all required fields in structured output\\n\\n### 4.2\\\n  \\ Special Scenario Handling\\n\\n#### Scenario 1: SPEF Unavailable During Synthesis\\\n  \\ Stage\\n- **Context**: In synthesis flow, parasitic extraction has not yet occurred\\n\\\n  - **Check result**: \\n  - Item 2.3 (SPEF loading status): `missing_items` (file\\\n  \\ not found)\\n  - Item 2.4 (SPEF version completeness): `missing_items` (no data\\\n  \\ to validate)\\n- **Waiver handling**: \\n  - If `waive_items` contains keywords:\\\n  \\ `\\\"synthesis\\\"`, `\\\"SPEF\\\"`, `\\\"pre-layout\\\"`, `\\\"wireload\\\"`\\n  - Apply waiver\\\n  \\ to Items 2.3 and 2.4 \\u2192 move to `waived` field\\n  - Final status: `PASS` (netlist\\\n  \\ items still validated)\\n- **Implementation note**: Check STA log for stage indicators\\\n  \\ like \\\"synthesis mode\\\" or \\\"wireload model\\\"\\n\\n#### Scenario 2: Golden Netlist\\\n  \\ with Historical Timestamp\\n- **Context**: Using archived golden netlist from previous\\\n  \\ tapeout or reference design\\n- **Check result**:\\n  - Item 2.1 (Netlist loading):\\\n  \\ `found_items` (file exists)\\n  - Item 2.2 (Netlist version completeness): `missing_items`\\\n  \\ if timestamp pattern requires current year\\n- **Waiver handling**:\\n  - If `waive_items`\\\n  \\ contains keywords: `\\\"golden\\\"`, `\\\"reference\\\"`, `\\\"historical\\\"`, `\\\"archive\\\"\\\n  `, or specific old year like `\\\"2023\\\"`\\n  - Apply waiver to Item 2.2 timestamp\\\n  \\ validation \\u2192 move to `waived` field\\n  - Final status: `PASS` (tool name\\\n  \\ and version still validated)\\n- **Implementation note**: Extract year from netlist\\\n  \\ date field and compare against pattern requirements\\n\\n#### Scenario 3: Vendor-Specific\\\n  \\ SPEF Format Extensions\\n- **Context**: Some EDA tools add proprietary extensions\\\n  \\ to standard SPEF format\\n- **Check result**:\\n  - Item 2.3 (SPEF loading): `found_items`\\\n  \\ (file loaded)\\n  - Item 2.4 (SPEF version completeness): May fail if expecting\\\n  \\ strict IEEE format\\n- **Waiver handling**:\\n  - If `waive_items` contains tool-specific\\\n  \\ keywords: `\\\"Innovus\\\"`, `\\\"Calibre\\\"`, `\\\"StarRC\\\"`, `\\\"vendor extension\\\"`\\n\\\n  \\  - Apply waiver to strict format validation \\u2192 move to `waived` field\\n  -\\\n  \\ Final status: `PASS` (basic version information still validated)\\n- **Implementation\\\n  \\ note**: Parse `*PROGRAM` field to identify tool vendor, adjust validation accordingly\\n\\\n  \\n#### Scenario 4: Multiple Netlist/SPEF Files in Hierarchical Design\\n- **Context**:\\\n  \\ Large designs may have multiple netlist files (top-level + sub-blocks) or multiple\\\n  \\ SPEF files (per corner)\\n- **Check result**:\\n  - Items 2.1-2.4: Multiple entries\\\n  \\ in `found_items` (one per file)\\n  - Validation applies to each file independently\\n\\\n  - **Waiver handling**:\\n  - If `waive_items` contains block-specific patterns: `\\\"\\\n  block_*\\\"`, `\\\"sub_module_*\\\"`, or corner patterns: `\\\"*_slow\\\"`, `\\\"*_fast\\\"`\\n\\\n  \\  - Apply selective waivers to specific files \\u2192 move matching entries to `waived`\\\n  \\ field\\n  - Final status: `PASS` if all required files validated or waived\\n- **Implementation\\\n  \\ note**: Preserve file path in metadata to enable pattern matching against specific\\\n  \\ files\\n\\n#### Scenario 5: Compressed Files Not Accessible\\n- **Context**: Netlist/SPEF\\\n  \\ files compressed (`.gz`) but decompression fails due to corruption or permissions\\n\\\n  - **Check result**:\\n  - Item 2.1 or 2.3 (File loading): `missing_items` (decompression\\\n  \\ error)\\n  - Subsequent version checks: `missing_items` (no data available)\\n-\\\n  \\ **Waiver handling**:\\n  - If `waive_items` contains: `\\\"compressed\\\"`, `\\\"decompression\\\n  \\ error\\\"`, or specific file pattern\\n  - Apply waiver to affected items \\u2192\\\n  \\ move to `waived` field\\n  - Final status: `PASS` if waived, otherwise `FAIL`\\n\\\n  - **Implementation note**: Catch decompression exceptions, report clear error message\\\n  \\ with file path\\n\\n### 4.3 Test Data Generation Guidance\\n\\n**Note**: The following\\\n  \\ guidance is for generating test configurations covering all 6 test scenarios.\\n\\\n  \\n#### Test Scenario Matrix\\n\\nBased on requirements.value and waivers.value combinations,\\\n  \\ generate 6 test scenarios:\\n\\n| Scenario | requirements.value | waivers.value\\\n  \\ | Test Objective |\\n|----------|-------------------|---------------|----------------|\\n\\\n  | 1 | N/A | N/A | Basic existence validation |\\n| 2 | N/A | 0 | Global waiver mechanism\\\n  \\ |\\n| 3 | N/A | >0 | Selective waiver matching mechanism |\\n| 4 | >0 | N/A | Pattern\\\n  \\ matching - PASS path |\\n| 5 | >0 | 0 | Pattern matching - FAIL path + global waiver\\\n  \\ |\\n| 6 | >0 | >0 | Pattern matching - FAIL path + selective waiver |\\n\\n#### Inference\\\n  \\ Strategy\\n\\n**Step 1: Run Parsing Logic to obtain actual metadata**\\n\\nAfter Parsing\\\n  \\ Logic execution, analyze the actual output structure and content. Expected fields:\\n\\\n  - `netlist.tool_name`: e.g., \\\"Genus\\\", \\\"Innovus\\\", \\\"Design Compiler\\\"\\n- `netlist.version`:\\\n  \\ e.g., \\\"21.1\\\", \\\"19.12-s090_1\\\"\\n- `netlist.date`: e.g., \\\"2025-01-15\\\", \\\"Jan\\\n  \\ 15 2025\\\"\\n- `spef.generator_info`: e.g., \\\"Innovus 21.1\\\", \\\"StarRC 2023.06\\\"\\\n  \\n- `spef.date`: e.g., \\\"2025-01-15\\\"\\n\\n**Step 2: Extract representative keywords**\\n\\\n  \\nFrom the `value` field of parsed objects, extract characteristic keywords:\\n\\n\\\n  - **Tool names**: Extract from `netlist.tool_name` and `spef.generator_info`\\n \\\n  \\ - Examples: `\\\"Genus\\\"`, `\\\"Innovus\\\"`, `\\\"PrimeTime\\\"`, `\\\"StarRC\\\"`, `\\\"Calibre\\\"\\\n  `\\n  - Use for pattern matching in Scenarios 4-6\\n\\n- **Version numbers**: Extract\\\n  \\ from `netlist.version` and `spef.generator_info`\\n  - Examples: `\\\"21.1\\\"`, `\\\"\\\n  19.12\\\"`, `\\\"2023.06\\\"`\\n  - Use for pattern matching in Scenarios 4-6\\n\\n- **Timestamps**:\\\n  \\ Extract year from `netlist.date` and `spef.date`\\n  - Examples: `\\\"2025\\\"`, `\\\"\\\n  2024\\\"`, `\\\"2023\\\"`\\n  - Use for pattern matching in Scenarios 4-6\\n\\n- **Stage\\\n  \\ indicators**: Infer from file presence/absence\\n  - Examples: `\\\"synthesis\\\"`\\\n  \\ (if SPEF missing), `\\\"post-route\\\"` (if SPEF present)\\n  - Use for waiver matching\\\n  \\ in Scenarios 2-3, 5-6\\n\\n**Step 3: Generate test YAML configurations**\\n\\n```yaml\\n\\\n  # Scenario 1: Basic existence check\\n# IMP-10-0-0-00_base.yaml\\nrequirements:\\n\\\n  \\  value: N/A\\n  pattern_items: []\\nwaivers:\\n  value: N/A\\n  waive_items: []\\n\\n\\\n  # Scenario 2: Global waiver\\n# IMP-10-0-0-00_global_waiver.yaml\\nrequirements:\\n\\\n  \\  value: N/A\\n  pattern_items: []\\nwaivers:\\n  value: 0\\n  waive_items: [\\\"All\\\n  \\ netlist/SPEF version checks waived for legacy design\\\"]\\n\\n# Scenario 3: Selective\\\n  \\ waiver\\n# IMP-10-0-0-00_selective_waiver.yaml\\nrequirements:\\n  value: N/A\\n \\\n  \\ pattern_items: []\\nwaivers:\\n  value: 2\\n  waive_items:\\n    - \\\"SPEF\\\"      \\\n  \\     # Waive SPEF-related failures (synthesis stage)\\n    - \\\"synthesis\\\"     \\\n  \\ # Waive synthesis-stage specific issues\\n\\n# Scenario 4: Pattern matching - PASS\\n\\\n  # IMP-10-0-0-00_pattern_pass.yaml\\nrequirements:\\n  value: 2  # Two items require\\\n  \\ pattern matching: netlist version (2.2) and SPEF version (2.4)\\n  pattern_items:\\n\\\n  \\    - \\\"Genus|Innovus|2025\\\"     # Netlist version: matches if contains tool name\\\n  \\ OR current year\\n    - \\\"Innovus|StarRC|2025\\\"    # SPEF version: matches if contains\\\n  \\ tool name OR current year\\nwaivers:\\n  value: N/A\\n  waive_items: []\\n\\n# Scenario\\\n  \\ 5: Pattern matching - FAIL + global waiver\\n# IMP-10-0-0-00_pattern_fail_global.yaml\\n\\\n  requirements:\\n  value: 2\\n  pattern_items:\\n    - \\\"DesignCompiler|2026\\\"    #\\\n  \\ Netlist version: does NOT match (wrong tool/future year)\\n    - \\\"PrimeTime|2026\\\"\\\n  \\         # SPEF version: does NOT match (wrong tool/future year)\\nwaivers:\\n  value:\\\n  \\ 0\\n  waive_items: [\\\"Version mismatch waived for regression testing\\\"]\\n\\n# Scenario\\\n  \\ 6: Pattern matching - FAIL + selective waiver\\n# IMP-10-0-0-00_pattern_fail_selective.yaml\\n\\\n  requirements:\\n  value: 2\\n  pattern_items:\\n    - \\\"DesignCompiler|2026\\\"    #\\\n  \\ Netlist version: does NOT match\\n    - \\\"PrimeTime|2026\\\"         # SPEF version:\\\n  \\ does NOT match\\nwaivers:\\n  value: 3\\n  waive_items:\\n    - \\\"golden\\\"       \\\n  \\          # Waive historical netlist timestamp\\n    - \\\"SPEF\\\"                \\\n  \\   # Waive SPEF version mismatch\\n    - \\\"synthesis\\\"              # Waive synthesis-stage\\\n  \\ SPEF absence\\n```\\n\\n**Key Principles**:\\n1. **PASS scenarios (Scenario 4)**:\\\n  \\ Use patterns that match actual data values\\n   - Extract actual tool names and\\\n  \\ years from Parsing Logic output\\n   - Use OR (`|`) to combine multiple valid alternatives\\n\\\n  \\   - Ensure at least one alternative matches for each pattern_item\\n\\n2. **FAIL\\\n  \\ scenarios (Scenarios 5-6)**: Use patterns that do NOT match actual data\\n   -\\\n  \\ Use wrong tool names (e.g., if actual is \\\"Genus\\\", use \\\"DesignCompiler\\\")\\n\\\n  \\   - Use future years (e.g., \\\"2026\\\" when actual is \\\"2025\\\")\\n   - Ensure patterns\\\n  \\ intentionally mismatch to trigger validation failures\\n\\n3. **OR relationships**:\\\n  \\ Connect multiple keywords with `|` for higher match probability\\n   - Example:\\\n  \\ `\\\"Genus|Innovus|2025\\\"` matches if value contains ANY of these strings\\n   -\\\n  \\ Increases robustness across different tool versions and configurations\\n\\n4. **waive_items**:\\\n  \\ Reference matching keywords defined in Section 3\\n   - Use keywords from Section\\\n  \\ 3.1-3.4 for selective waivers\\n   - Ensure waiver patterns match the violation\\\n  \\ descriptions\\n\\n**Pattern Matching Correspondence**:\\n- **pattern_items[0]** \\u2192\\\n  \\ Item 2.2 (Netlist version completeness)\\n  - Matches against `netlist.tool_name`,\\\n  \\ `netlist.version`, `netlist.date` combined value\\n- **pattern_items[1]** \\u2192\\\n  \\ Item 2.4 (SPEF version completeness)\\n  - Matches against `spef.generator_info`,\\\n  \\ `spef.date` combined value\\n\\n**Important**: These are recommendations based on\\\n  \\ expected Parsing Logic output. After actual Parsing Logic execution, adjust patterns\\\n  \\ according to real metadata structure and content values.\\n\"\n\n\n---\n\n# Agent A Code (extract_context)\nimport re\nfrom typing import List, Dict\n\ndef extract_context(text: str, source_file: str) -> List[Dict]:\n    \"\"\"\n    Extract netlist and SPEF version metadata from log files or file headers.\n    \n    This function parses:\n    1. STA log files for file loading messages\n    2. Netlist file headers (Verilog/VHDL comments)\n    3. SPEF file headers (IEEE 1481 format)\n    \n    Args:\n        text: Input text content (log file or netlist/SPEF file)\n        source_file: Source file path for traceability\n        \n    Returns:\n        List of dictionaries with extracted version metadata\n    \"\"\"\n    results = []\n    lines = text.split('\\n')\n    \n    # Initialize tracking structures\n    netlist_info = {\n        'loaded': False,\n        'tool_name': '',\n        'tool_version': '',\n        'timestamp': '',\n        'format': ''\n    }\n    \n    spef_info = {\n        'loaded': False,\n        'tool_name': '',\n        'tool_version': '',\n        'timestamp': '',\n        'standard_version': ''\n    }\n    \n    # Regex patterns for different extraction scenarios\n    \n    # Pattern 1: STA log file loading messages\n    netlist_load_pattern = re.compile(\n        r'(?i)(reading|loaded|read_verilog|read_hdl|read_netlist).*?(netlist|verilog|\\.v\\b)',\n        re.IGNORECASE\n    )\n    spef_load_pattern = re.compile(\n        r'(?i)(reading|loaded|read_parasitics|read_spef).*?(spef|parasitics)',\n        re.IGNORECASE\n    )\n    \n    # Pattern 2: Netlist header - tool and version\n    # Matches: \"// Generator: Cadence Innovus 21.10-s080_1\"\n    # Matches: \"// Created by: Genus 19.1\"\n    # Matches: \"// Tool: Design Compiler version 2023.03\"\n    netlist_tool_pattern = re.compile(\n        r'(?i)(?://|/\\*|--)\\s*(?:generator|created\\s+by|tool|synthesized\\s+by)[:\\s]+([A-Za-z0-9_]+)(?:\\s+(?:version\\s+)?([0-9][0-9.\\-_a-zA-Z]+))?',\n        re.IGNORECASE\n    )\n    \n    # Pattern 3: Netlist header - date/timestamp\n    # Matches: \"// Date: 2025-01-15 14:23:45\"\n    # Matches: \"// Generated on: Jan 15 2025\"\n    netlist_date_pattern = re.compile(\n        r'(?i)(?://|/\\*|--)\\s*(?:date|generated\\s+on|timestamp)[:\\s]+(.+?)(?:\\*/|$)',\n        re.IGNORECASE\n    )\n    \n    # Pattern 4: Netlist format detection\n    verilog_pattern = re.compile(r'\\b(module|endmodule|wire|reg|assign)\\b', re.IGNORECASE)\n    vhdl_pattern = re.compile(r'\\b(entity|architecture|signal|process)\\b', re.IGNORECASE)\n    \n    # Pattern 5: SPEF header directives\n    # Matches: *SPEF \"IEEE 1481-2009\"\n    # Matches: *PROGRAM \"Innovus\"\n    # Matches: *VERSION \"21.1\"\n    # Matches: *DATE \"Wed Jan 15 16:45:12 2025\"\n    spef_directive_pattern = re.compile(\n        r'^\\*(\\w+)\\s+\"([^\"]+)\"',\n        re.MULTILINE\n    )\n    \n    # Track which file type we're parsing (heuristic based on content)\n    is_spef_file = False\n    is_netlist_file = False\n    is_sta_log = False\n    \n    # Detect file type from content\n    for i, line in enumerate(lines[:50]):  # Check first 50 lines\n        if line.strip().startswith('*SPEF'):\n            is_spef_file = True\n            break\n        if re.search(r'\\b(module|entity)\\b', line, re.IGNORECASE):\n            is_netlist_file = True\n        if re.search(r'(?i)(primetime|tempus|innovus|genus|timing\\s+report)', line):\n            is_sta_log = True\n    \n    # === EXTRACTION LOGIC ===\n    \n    # Process each line\n    for line_num, line in enumerate(lines, start=1):\n        \n        # --- Extract from STA Log ---\n        if is_sta_log or (not is_spef_file and not is_netlist_file):\n            \n            # Check for netlist loading messages\n            netlist_load_match = netlist_load_pattern.search(line)\n            if netlist_load_match and not netlist_info['loaded']:\n                netlist_info['loaded'] = True\n                # Look for success indicators\n                if re.search(r'(?i)(success|complete|done)', line):\n                    results.append({\n                        'value': f\"Netlist loading: {line.strip()}\",\n                        'source_file': source_file,\n                        'line_number': line_num,\n                        'matched_content': line.strip(),\n                        'parsed_fields': {\n                            'netlist': {\n                                'loaded': True,\n                                'tool_name': netlist_info.get('tool_name', ''),\n                                'tool_version': netlist_info.get('tool_version', ''),\n                                'timestamp': netlist_info.get('timestamp', ''),\n                                'format': netlist_info.get('format', '')\n                            }\n                        }\n                    })\n            \n            # Check for SPEF loading messages\n            spef_load_match = spef_load_pattern.search(line)\n            if spef_load_match and not spef_info['loaded']:\n                spef_info['loaded'] = True\n                if re.search(r'(?i)(success|complete|done)', line):\n                    results.append({\n                        'value': f\"SPEF loading: {line.strip()}\",\n                        'source_file': source_file,\n                        'line_number': line_num,\n                        'matched_content': line.strip(),\n                        'parsed_fields': {\n                            'spef': {\n                                'loaded': True,\n                                'tool_name': spef_info.get('tool_name', ''),\n                                'tool_version': spef_info.get('tool_version', ''),\n                                'timestamp': spef_info.get('timestamp', ''),\n                                'standard_version': spef_info.get('standard_version', '')\n                            }\n                        }\n                    })\n        \n        # --- Extract from Netlist File Headers ---\n        if is_netlist_file or (line_num <= 100 and not is_spef_file):\n            \n            # Extract tool name and version\n            tool_match = netlist_tool_pattern.search(line)\n            if tool_match:\n                tool_name = tool_match.group(1).strip()\n                tool_version = tool_match.group(2).strip() if tool_match.group(2) else ''\n                \n                if tool_name and not netlist_info['tool_name']:\n                    netlist_info['tool_name'] = tool_name\n                    netlist_info['tool_version'] = tool_version\n                    netlist_info['loaded'] = True\n            \n            # Extract date/timestamp\n            date_match = netlist_date_pattern.search(line)\n            if date_match and not netlist_info['timestamp']:\n                netlist_info['timestamp'] = date_match.group(1).strip()\n            \n            # Detect format\n            if not netlist_info['format']:\n                if verilog_pattern.search(line):\n                    netlist_info['format'] = 'Verilog'\n                elif vhdl_pattern.search(line):\n                    netlist_info['format'] = 'VHDL'\n        \n        # --- Extract from SPEF File Headers ---\n        if is_spef_file or line.strip().startswith('*'):\n            \n            # Extract SPEF directives\n            directive_match = spef_directive_pattern.match(line)\n            if directive_match:\n                directive_name = directive_match.group(1).upper()\n                directive_value = directive_match.group(2).strip()\n                \n                if directive_name == 'SPEF':\n                    spef_info['standard_version'] = directive_value\n                    spef_info['loaded'] = True\n                elif directive_name == 'PROGRAM':\n                    spef_info['tool_name'] = directive_value\n                elif directive_name == 'VERSION':\n                    spef_info['tool_version'] = directive_value\n                elif directive_name == 'DATE':\n                    spef_info['timestamp'] = directive_value\n    \n    # === GENERATE OUTPUT RECORDS ===\n    \n    # Generate netlist record if any information was found\n    if netlist_info['loaded'] or netlist_info['tool_name']:\n        netlist_value_parts = []\n        if netlist_info['tool_name']:\n            netlist_value_parts.append(f\"Tool: {netlist_info['tool_name']}\")\n        if netlist_info['tool_version']:\n            netlist_value_parts.append(f\"Version: {netlist_info['tool_version']}\")\n        if netlist_info['timestamp']:\n            netlist_value_parts.append(f\"Date: {netlist_info['timestamp']}\")\n        \n        netlist_value = \"Netlist \" + \" \".join(netlist_value_parts) if netlist_value_parts else \"Netlist metadata\"\n        \n        results.append({\n            'value': netlist_value,\n            'source_file': source_file,\n            'line_number': 1,  # Aggregate record\n            'matched_content': f\"Netlist metadata extracted from {source_file}\",\n            'parsed_fields': {\n                'netlist': {\n                    'loaded': netlist_info['loaded'],\n                    'tool_name': netlist_info['tool_name'],\n                    'tool_version': netlist_info['tool_version'],\n                    'timestamp': netlist_info['timestamp'],\n                    'format': netlist_info['format']\n                }\n            }\n        })\n    \n    # Generate SPEF record if any information was found\n    if spef_info['loaded'] or spef_info['tool_name']:\n        spef_value_parts = []\n        if spef_info['standard_version']:\n            spef_value_parts.append(f\"Standard: {spef_info['standard_version']}\")\n        if spef_info['tool_name']:\n            spef_value_parts.append(f\"Tool: {spef_info['tool_name']}\")\n        if spef_info['tool_version']:\n            spef_value_parts.append(f\"Version: {spef_info['tool_version']}\")\n        if spef_info['timestamp']:\n            spef_value_parts.append(f\"Date: {spef_info['timestamp']}\")\n        \n        spef_value = \"SPEF \" + \" \".join(spef_value_parts) if spef_value_parts else \"SPEF metadata\"\n        \n        results.append({\n            'value': spef_value,\n            'source_file': source_file,\n            'line_number': 1,  # Aggregate record\n            'matched_content': f\"SPEF metadata extracted from {source_file}\",\n            'parsed_fields': {\n                'spef': {\n                    'loaded': spef_info['loaded'],\n                    'tool_name': spef_info['tool_name'],\n                    'tool_version': spef_info['tool_version'],\n                    'timestamp': spef_info['timestamp'],\n                    'standard_version': spef_info['standard_version']\n                }\n            }\n        })\n    \n    # If no data found, return empty structure to indicate files were checked\n    if not results:\n        results.append({\n            'value': 'No version metadata found',\n            'source_file': source_file,\n            'line_number': 0,\n            'matched_content': 'File parsed but no version information detected',\n            'parsed_fields': {\n                'netlist': {\n                    'loaded': False,\n                    'tool_name': '',\n                    'tool_version': '',\n                    'timestamp': '',\n                    'format': ''\n                },\n                'spef': {\n                    'loaded': False,\n                    'tool_name': '',\n                    'tool_version': '',\n                    'timestamp': '',\n                    'standard_version': ''\n                }\n            }\n        })\n    \n    # [Locked] Standardization Layer - DO NOT MODIFY\n    standardized_output = []\n    for item in results:\n        safe_value = str(item.get(\"value\", \"\"))\n        standardized_item = {\n            \"value\": safe_value,\n            \"source_file\": source_file,\n            \"line_number\": item.get(\"line_number\"),\n            \"matched_content\": str(item.get(\"matched_content\", \"\")),\n            \"parsed_fields\": item.get(\"parsed_fields\", {})\n        }\n        standardized_output.append(standardized_item)\n    return standardized_output\n\n---\n\n# Check Logic from ItemSpec\n{\n  \"raw_content\": \"# ItemSpec: IMP-10-0-0-00\\n\\n## 1. Parsing Logic\\n\\n**Information to Extract**:\\n\\n### 1.1 Netlist File Information\\n- **Purpose**: Extract version metadata from netlist files to verify tool, version, and generation timestamp information\\n- **Key Fields**:\\n  - `loaded`: Boolean indicating whether netlist file was successfully accessed and parsed\\n  - `tool_name`: String representing the EDA tool that generated the netlist (e.g., \\\"Innovus\\\", \\\"Genus\\\", \\\"ICC2\\\", \\\"DC\\\")\\n  - `tool_version`: String representing the tool version number (e.g., \\\"21.1\\\", \\\"2023.03-SP2\\\")\\n  - `timestamp`: String representing the generation date/time of the netlist\\n  - `format`: String representing the netlist format (e.g., \\\"Verilog\\\", \\\"VHDL\\\", \\\"DEF\\\")\\n\\n### 1.2 SPEF File Information\\n- **Purpose**: Extract version metadata from SPEF (Standard Parasitic Exchange Format) files to verify extraction tool, version, standard compliance, and generation timestamp\\n- **Key Fields**:\\n  - `loaded`: Boolean indicating whether SPEF file was successfully accessed and parsed\\n  - `tool_name`: String representing the parasitic extraction tool (e.g., \\\"StarRC\\\", \\\"Quantus\\\", \\\"PrimeTime\\\")\\n  - `tool_version`: String representing the extraction tool version number\\n  - `timestamp`: String representing the generation date/time of the SPEF file\\n  - `standard_version`: String representing the IEEE standard version (e.g., \\\"IEEE 1481-1999\\\", \\\"IEEE 1481-2009\\\")\\n\\n### 1.3 File Metadata\\n- **Purpose**: Provide traceability information for debugging and audit purposes\\n- **Key Fields**:\\n  - `source_file`: Absolute path to the input file where information was extracted\\n  - `line_number`: Line number where version information was found\\n  - `matched_content`: The actual text line that was matched during extraction\\n\\n**Data Structure**: Output structure follows global_rules.md Section 2.4.1 (Required metadata + parsed_fields)\\n\\n**parsed_fields Example**:\\n```python\\n{\\n  \\\"netlist\\\": {\\n    \\\"loaded\\\": True,\\n    \\\"tool_name\\\": \\\"Innovus\\\",\\n    \\\"tool_version\\\": \\\"21.10-s080_1\\\",\\n    \\\"timestamp\\\": \\\"2025-01-15 14:23:45\\\",\\n    \\\"format\\\": \\\"Verilog\\\"\\n  },\\n  \\\"spef\\\": {\\n    \\\"loaded\\\": True,\\n    \\\"tool_name\\\": \\\"StarRC\\\",\\n    \\\"tool_version\\\": \\\"2022.06-SP1\\\",\\n    \\\"timestamp\\\": \\\"2025-01-15 16:45:12\\\",\\n    \\\"standard_version\\\": \\\"IEEE 1481-2009\\\"\\n  }\\n}\\n```\\n\\n**Complete Output Structure Example**:\\n```python\\n[\\n  {\\n    \\\"value\\\": \\\"Netlist version: Innovus 21.10-s080_1\\\",\\n    \\\"source_file\\\": \\\"/project/design/netlist/top.v.gz\\\",\\n    \\\"line_number\\\": 3,\\n    \\\"matched_content\\\": \\\"// Generator: Cadence Innovus 21.10-s080_1\\\",\\n    \\\"parsed_fields\\\": {\\n      \\\"netlist\\\": {\\n        \\\"loaded\\\": True,\\n        \\\"tool_name\\\": \\\"Innovus\\\",\\n        \\\"tool_version\\\": \\\"21.10-s080_1\\\",\\n        \\\"timestamp\\\": \\\"2025-01-15 14:23:45\\\",\\n        \\\"format\\\": \\\"Verilog\\\"\\n      }\\n    }\\n  },\\n  {\\n    \\\"value\\\": \\\"SPEF version: IEEE 1481-2009\\\",\\n    \\\"source_file\\\": \\\"/project/design/spef/top.spef.gz\\\",\\n    \\\"line_number\\\": 1,\\n    \\\"matched_content\\\": \\\"*SPEF \\\\\\\"IEEE 1481-2009\\\\\\\"\\\",\\n    \\\"parsed_fields\\\": {\\n      \\\"spef\\\": {\\n        \\\"loaded\\\": True,\\n        \\\"tool_name\\\": \\\"StarRC\\\",\\n        \\\"tool_version\\\": \\\"2022.06-SP1\\\",\\n        \\\"timestamp\\\": \\\"2025-01-15 16:45:12\\\",\\n        \\\"standard_version\\\": \\\"IEEE 1481-2009\\\"\\n      }\\n    }\\n  }\\n]\\n```\\n\\n## 2. Check Logic\\n\\nBased on description \\\"Confirm the netlist/spef version is correct\\\", the following items require validation:\\n\\n**Validation Items**:\\n\\n### 2.1 Netlist File Loading Status\\n- **Purpose**: Verify netlist file was successfully accessed and parsed\\n- **Completeness definition**: \\n  - `parsed_fields.netlist.loaded == True`\\n  - File path is accessible and readable\\n- **Validation type**: Existence check (Boolean)\\n- **PASS condition**: Netlist file successfully loaded\\n- **FAIL condition**: File not found, access denied, or parsing error\\n\\n### 2.2 Netlist Version Completeness\\n- **Purpose**: Verify netlist contains complete version metadata\\n- **Completeness definition**:\\n  - `parsed_fields.netlist.tool_name` exists and is non-empty\\n  - `parsed_fields.netlist.tool_version` exists and is non-empty\\n  - `parsed_fields.netlist.timestamp` exists and is non-empty\\n  - `parsed_fields.netlist.format` exists and is non-empty\\n- **Validation type**: Existence check (Boolean)\\n- **PASS condition**: All mandatory version fields present and non-empty\\n- **FAIL condition**: Any mandatory field missing or empty\\n\\n### 2.3 SPEF File Loading Status\\n- **Purpose**: Verify SPEF file was successfully accessed and parsed\\n- **Completeness definition**:\\n  - `parsed_fields.spef.loaded == True`\\n  - File path is accessible and readable\\n- **Validation type**: Existence check (Boolean)\\n- **PASS condition**: SPEF file successfully loaded\\n- **FAIL condition**: File not found, access denied, or parsing error\\n\\n### 2.4 SPEF Version Completeness\\n- **Purpose**: Verify SPEF contains complete version metadata\\n- **Completeness definition**:\\n  - `parsed_fields.spef.tool_name` exists and is non-empty\\n  - `parsed_fields.spef.tool_version` exists and is non-empty\\n  - `parsed_fields.spef.timestamp` exists and is non-empty\\n  - `parsed_fields.spef.standard_version` exists and is non-empty\\n- **Validation type**: Existence check (Boolean)\\n- **PASS condition**: All mandatory version fields present and non-empty\\n- **FAIL condition**: Any mandatory field missing or empty\\n\\n**Pattern Matching**:\\n- Items requiring pattern matching: None (Type 4 checker - Boolean validation only)\\n- Items with existence check only: All items (2.1, 2.2, 2.3, 2.4)\\n\\n**Pattern Correspondence Order**: \\n- Not applicable (requirements.value = N/A, no pattern_items defined)\\n\\n**Overall Pass/Fail Logic**:\\n- **PASS**: All four validation items pass (both netlist and SPEF files loaded successfully with complete version information)\\n- **FAIL**: Any validation item fails (file loading failure OR incomplete version metadata)\\n- **Edge Cases**:\\n  - If netlist loads but SPEF fails \\u2192 FAIL (unless waived)\\n  - If version fields exist but contain only whitespace \\u2192 FAIL (treated as empty)\\n  - If files are compressed (.gz) \\u2192 Must decompress before parsing\\n  - If multiple version headers exist \\u2192 Use first occurrence\\n\\n**Validation Sequence**:\\n1. Check netlist loading status (Item 2.1)\\n2. If loaded, validate netlist version completeness (Item 2.2)\\n3. Check SPEF loading status (Item 2.3)\\n4. If loaded, validate SPEF version completeness (Item 2.4)\\n5. Return PASS only if all items pass\\n\\n## 3. Waiver Logic\\n\\nBased on description \\\"Confirm the netlist/spef version is correct\\\", analyze waiver scenarios for validation items:\\n\\n**Waivable Items and Matching Keywords**:\\n\\n### 3.1 SPEF File Loading Status (Item 2.3)\\n- **Waiver scenario**: Early design stages where parasitic extraction has not yet been performed\\n  - Synthesis stage: Only netlist exists, SPEF generation occurs later in P&R flow\\n  - Pre-layout timing analysis: Using wireload models instead of extracted parasitics\\n  - Floorplanning stage: Physical design not finalized for extraction\\n- **Typical waiver reason**: \\\"Pre-extraction design stage - SPEF file not yet available. Using wireload models for timing analysis.\\\"\\n- **Matching keywords**: `\\\"SPEF\\\"`, `\\\"synthesis\\\"`, `\\\"pre-extraction\\\"`, `\\\"wireload\\\"`, `\\\"early-stage\\\"`, `\\\"floorplan\\\"`\\n- **Business justification**: SPEF files are only generated after place-and-route completion. Earlier design stages legitimately operate without parasitic data.\\n\\n### 3.2 SPEF Version Completeness (Item 2.4)\\n- **Waiver scenario**: Legacy or third-party SPEF files with non-standard headers\\n  - Regression testing: Golden reference files from previous tool versions may lack complete metadata\\n  - Vendor-provided IP blocks: SPEF files may use proprietary header formats\\n  - Format conversion: SPEF files converted from other formats may have incomplete version information\\n- **Typical waiver reason**: \\\"Legacy SPEF file from regression suite - version metadata grandfathered for compatibility\\\"\\n- **Matching keywords**: `\\\"SPEF\\\"`, `\\\"legacy\\\"`, `\\\"golden\\\"`, `\\\"regression\\\"`, `\\\"vendor\\\"`, `\\\"third-party\\\"`, `\\\"converted\\\"`\\n- **Business justification**: Historical data used for validation may predate current version tracking requirements. Functional correctness takes precedence over metadata completeness.\\n\\n### 3.3 Netlist Version Completeness (Item 2.2)\\n- **Waiver scenario**: Hand-edited or merged netlists lacking tool-generated headers\\n  - ECO (Engineering Change Order) flows: Manual netlist modifications for bug fixes\\n  - Netlist merging: Combining multiple sub-netlists may strip original headers\\n  - Custom scripting: Automated netlist transformations may not preserve version comments\\n- **Typical waiver reason**: \\\"ECO-modified netlist - original tool version information removed during manual editing\\\"\\n- **Matching keywords**: `\\\"netlist\\\"`, `\\\"ECO\\\"`, `\\\"manual\\\"`, `\\\"hand-edit\\\"`, `\\\"merged\\\"`, `\\\"custom\\\"`\\n- **Business justification**: Engineering change orders require direct netlist modification. Version tracking shifts to ECO documentation rather than file headers.\\n\\n### 3.4 Both Netlist and SPEF Version Information (Items 2.2 and 2.4)\\n- **Waiver scenario**: Ideal/academic test cases without real tool provenance\\n  - Benchmark circuits: Standard test designs (ISCAS, ITC) without tool metadata\\n  - Simulation-only flows: Behavioral models not requiring production tool versions\\n  - Algorithm validation: Synthetic test cases for checker development\\n- **Typical waiver reason**: \\\"Academic benchmark circuit - no production tool version information available\\\"\\n- **Matching keywords**: `\\\"benchmark\\\"`, `\\\"test\\\"`, `\\\"simulation\\\"`, `\\\"academic\\\"`, `\\\"synthetic\\\"`, `\\\"ISCAS\\\"`, `\\\"ITC\\\"`\\n- **Business justification**: Research and development activities use standardized test cases that lack production tool metadata but serve valid verification purposes.\\n\\n---\\n\\n**Waiver Modes**:\\n\\n### Global Waiver Mode (waivers.value = 0)\\n- **Behavior**: All validation items (2.1, 2.2, 2.3, 2.4) are waived unconditionally\\n- **Use cases**:\\n  - Initial checker deployment: Gradual rollout without breaking existing flows\\n  - Tool migration periods: Transitioning between EDA tool versions\\n  - Emergency bypass: Critical tapeout schedules requiring temporary relaxation\\n- **Application**: Set `waivers.value = 0` in configuration\\n- **Traceability**: Global waiver reason must be documented in `waivers.waive_reasons[0]`\\n\\n### Selective Waiver Mode (waivers.value > 0)\\n- **Behavior**: Only validation items matching keywords in `waivers.waive_items` are waived\\n- **Matching strategy**:\\n  - **Exact matching**: Item identifier must exactly match waive_items entry\\n    - Example: `waive_items = [\\\"2.3\\\"]` waives only SPEF loading status\\n  - **Keyword matching**: Waive_items entries matched against scenario keywords\\n    - Example: `waive_items = [\\\"SPEF\\\", \\\"synthesis\\\"]` waives items 2.3 and 2.4 in synthesis context\\n  - **Wildcard matching**: Use `\\\"*\\\"` for pattern-based matching\\n    - Example: `waive_items = [\\\"SPEF*\\\"]` waives all SPEF-related items (2.3, 2.4)\\n- **Application**: \\n  - Set `waivers.value = N` where N = number of items in `waivers.waive_items`\\n  - Populate `waivers.waive_items` with item identifiers or keywords\\n  - Provide corresponding reasons in `waivers.waive_reasons`\\n- **Traceability**: Each waived item must have corresponding entry in waive_reasons at same index\\n\\n**Implementation Guidance**:\\n\\n1. **Waiver-to-Item Mapping**:\\n   - Item 2.1 (Netlist loading): Rarely waived - indicates fundamental file access problem\\n   - Item 2.2 (Netlist version): Waivable via keywords `\\\"netlist\\\"`, `\\\"ECO\\\"`, `\\\"manual\\\"`, `\\\"benchmark\\\"`\\n   - Item 2.3 (SPEF loading): Waivable via keywords `\\\"SPEF\\\"`, `\\\"synthesis\\\"`, `\\\"pre-extraction\\\"`\\n   - Item 2.4 (SPEF version): Waivable via keywords `\\\"SPEF\\\"`, `\\\"legacy\\\"`, `\\\"vendor\\\"`\\n\\n2. **Keyword Matching Logic**:\\n   ```python\\n   # Pseudo-code for selective waiver matching\\n   for validation_item in failed_items:\\n       item_id = validation_item.id  # e.g., \\\"2.3\\\"\\n       item_keywords = validation_item.keywords  # e.g., [\\\"SPEF\\\", \\\"loading\\\"]\\n       \\n       for waive_entry in waivers.waive_items:\\n           if waive_entry == item_id:  # Exact match\\n               apply_waiver(validation_item)\\n           elif any(keyword in waive_entry for keyword in item_keywords):  # Keyword match\\n               apply_waiver(validation_item)\\n   ```\\n\\n3. **Traceability Requirements**:\\n   - Each waiver must reference specific validation item(s) by ID\\n   - Waiver reason must include business justification and approver information\\n   - Waiver application must be logged with timestamp and user context\\n   - Audit trail must link waived failures to original check results\\n\\n4. **Best Practices**:\\n   - Prefer selective waivers over global waivers for better traceability\\n   - Document waiver expiration conditions (e.g., \\\"valid until P&R completion\\\")\\n   - Review and refresh waivers periodically (recommend quarterly)\\n   - Escalate repeated waivers as potential flow issues requiring root cause analysis\\n\\n## 4. Implementation Guide\\n\\n### 4.1 Item-Specific Implementation Points\\n\\n**Data Source Inference**:\\n- **Primary data source**: Static Timing Analysis (STA) log files\\n  - Recommended file patterns: `sta*.log`, `timing*.log`, `primetime*.log`, `tempus*.log`\\n  - These logs typically contain file loading messages and version information\\n- **Secondary data source**: Netlist and SPEF file headers\\n  - Netlist files: `*.v`, `*.v.gz`, `*.vg`\\n  - SPEF files: `*.spef`, `*.spef.gz`\\n  - File headers contain generator tool and version metadata\\n- **Fallback strategy**: If STA logs unavailable, parse netlist/SPEF files directly\\n\\n**Information Extraction Methods**:\\n\\n- **File Loading Status**: Extract from STA log file loading messages\\n  - **Innovus/Tempus**: Search for keywords:\\n    - `\\\"Reading netlist\\\"`, `\\\"read_netlist\\\"`, `\\\"Netlist loaded\\\"`\\n    - `\\\"Reading SPEF\\\"`, `\\\"read_spef\\\"`, `\\\"SPEF loaded\\\"`\\n  - **PrimeTime**: Search for keywords:\\n    - `\\\"read_verilog\\\"`, `\\\"Reading Verilog netlist\\\"`\\n    - `\\\"read_parasitics\\\"`, `\\\"Reading SPEF\\\"`\\n  - **Genus**: Search for keywords:\\n    - `\\\"read_hdl\\\"`, `\\\"Reading design\\\"`\\n  - **Extraction pattern**: `(?i)(reading|loaded|read_\\\\w+).*?(netlist|spef|verilog|parasitics)`\\n  - **Success indicators**: Look for \\\"successfully\\\", \\\"completed\\\", or absence of error messages\\n\\n- **Netlist Version Information**: Extract from netlist file headers (first 50-100 lines)\\n  - **Location**: Comment blocks at file beginning\\n  - **Comment formats**: \\n    - Verilog: `//` or `/* ... */`\\n    - VHDL: `--`\\n  - **Keywords to search**:\\n    - Tool name: `\\\"Generator\\\"`, `\\\"Created by\\\"`, `\\\"Tool\\\"`, `\\\"Synthesized by\\\"`\\n    - Version: `\\\"version\\\"`, `\\\"Version\\\"`, `\\\"Ver\\\"`, `\\\"Release\\\"`\\n    - Date: `\\\"Date\\\"`, `\\\"Generated on\\\"`, `\\\"Timestamp\\\"`\\n  - **Parsing pattern**: `(?i)(generator|created by|tool):\\\\s*(\\\\w+)\\\\s+(version\\\\s+)?([0-9.]+)`\\n  - **Date pattern**: `(?i)(date|generated on):\\\\s*(\\\\d{4}[-/]\\\\d{2}[-/]\\\\d{2}|\\\\d{2}[-/]\\\\d{2}[-/]\\\\d{4})`\\n\\n- **SPEF Version Information**: Extract from SPEF file headers\\n  - **Location**: First 20-30 lines of SPEF file\\n  - **Standard format**: IEEE 1481-1999 or IEEE 1481-2009\\n  - **Keywords to search**:\\n    - `*SPEF`, `*DESIGN`, `*DATE`, `*VENDOR`, `*PROGRAM`, `*VERSION`\\n  - **Parsing pattern**: `\\\\*(\\\\w+)\\\\s+\\\"([^\\\"]+)\\\"`\\n  - **Version extraction**: Combine `*PROGRAM` and `*VERSION` fields\\n  - **Date extraction**: `*DATE` field (format varies by tool)\\n\\n**Adaptive Learning Strategy**:\\n- **Do not assume fixed formats**: Different EDA tools use different header formats\\n  - Learn from actual file content structure\\n  - Use flexible regex patterns with case-insensitive matching\\n  - Extract all comment blocks and search for version-related keywords\\n- **Fallback handling**:\\n  - If netlist file not found in STA log: Search for `*.v` or `*.vg` files in design directory\\n  - If SPEF file not found: Mark `spef.loaded = False`, set other SPEF fields to `null`\\n  - If version information incomplete: Mark corresponding completeness fields as `False`\\n- **Error tolerance**:\\n  - Compressed files (`.gz`): Decompress before parsing\\n  - Encoding issues: Try UTF-8, then Latin-1, then ignore errors\\n  - Malformed headers: Continue parsing, mark fields as missing rather than failing completely\\n  - Multiple files: If multiple netlist/SPEF files found, extract from all and report in metadata\\n\\n**Multi-Stage Extraction Strategy**:\\n1. **Stage 1**: Parse STA log to identify file paths\\n   - Extract netlist file path from loading messages\\n   - Extract SPEF file path from loading messages\\n2. **Stage 2**: Parse identified files for version metadata\\n   - Open netlist file, read header comments\\n   - Open SPEF file, read header directives\\n3. **Stage 3**: Combine information\\n   - Merge loading status from Stage 1 with version info from Stage 2\\n   - Populate all required fields in structured output\\n\\n### 4.2 Special Scenario Handling\\n\\n#### Scenario 1: SPEF Unavailable During Synthesis Stage\\n- **Context**: In synthesis flow, parasitic extraction has not yet occurred\\n- **Check result**: \\n  - Item 2.3 (SPEF loading status): `missing_items` (file not found)\\n  - Item 2.4 (SPEF version completeness): `missing_items` (no data to validate)\\n- **Waiver handling**: \\n  - If `waive_items` contains keywords: `\\\"synthesis\\\"`, `\\\"SPEF\\\"`, `\\\"pre-layout\\\"`, `\\\"wireload\\\"`\\n  - Apply waiver to Items 2.3 and 2.4 \\u2192 move to `waived` field\\n  - Final status: `PASS` (netlist items still validated)\\n- **Implementation note**: Check STA log for stage indicators like \\\"synthesis mode\\\" or \\\"wireload model\\\"\\n\\n#### Scenario 2: Golden Netlist with Historical Timestamp\\n- **Context**: Using archived golden netlist from previous tapeout or reference design\\n- **Check result**:\\n  - Item 2.1 (Netlist loading): `found_items` (file exists)\\n  - Item 2.2 (Netlist version completeness): `missing_items` if timestamp pattern requires current year\\n- **Waiver handling**:\\n  - If `waive_items` contains keywords: `\\\"golden\\\"`, `\\\"reference\\\"`, `\\\"historical\\\"`, `\\\"archive\\\"`, or specific old year like `\\\"2023\\\"`\\n  - Apply waiver to Item 2.2 timestamp validation \\u2192 move to `waived` field\\n  - Final status: `PASS` (tool name and version still validated)\\n- **Implementation note**: Extract year from netlist date field and compare against pattern requirements\\n\\n#### Scenario 3: Vendor-Specific SPEF Format Extensions\\n- **Context**: Some EDA tools add proprietary extensions to standard SPEF format\\n- **Check result**:\\n  - Item 2.3 (SPEF loading): `found_items` (file loaded)\\n  - Item 2.4 (SPEF version completeness): May fail if expecting strict IEEE format\\n- **Waiver handling**:\\n  - If `waive_items` contains tool-specific keywords: `\\\"Innovus\\\"`, `\\\"Calibre\\\"`, `\\\"StarRC\\\"`, `\\\"vendor extension\\\"`\\n  - Apply waiver to strict format validation \\u2192 move to `waived` field\\n  - Final status: `PASS` (basic version information still validated)\\n- **Implementation note**: Parse `*PROGRAM` field to identify tool vendor, adjust validation accordingly\\n\\n#### Scenario 4: Multiple Netlist/SPEF Files in Hierarchical Design\\n- **Context**: Large designs may have multiple netlist files (top-level + sub-blocks) or multiple SPEF files (per corner)\\n- **Check result**:\\n  - Items 2.1-2.4: Multiple entries in `found_items` (one per file)\\n  - Validation applies to each file independently\\n- **Waiver handling**:\\n  - If `waive_items` contains block-specific patterns: `\\\"block_*\\\"`, `\\\"sub_module_*\\\"`, or corner patterns: `\\\"*_slow\\\"`, `\\\"*_fast\\\"`\\n  - Apply selective waivers to specific files \\u2192 move matching entries to `waived` field\\n  - Final status: `PASS` if all required files validated or waived\\n- **Implementation note**: Preserve file path in metadata to enable pattern matching against specific files\\n\\n#### Scenario 5: Compressed Files Not Accessible\\n- **Context**: Netlist/SPEF files compressed (`.gz`) but decompression fails due to corruption or permissions\\n- **Check result**:\\n  - Item 2.1 or 2.3 (File loading): `missing_items` (decompression error)\\n  - Subsequent version checks: `missing_items` (no data available)\\n- **Waiver handling**:\\n  - If `waive_items` contains: `\\\"compressed\\\"`, `\\\"decompression error\\\"`, or specific file pattern\\n  - Apply waiver to affected items \\u2192 move to `waived` field\\n  - Final status: `PASS` if waived, otherwise `FAIL`\\n- **Implementation note**: Catch decompression exceptions, report clear error message with file path\\n\\n### 4.3 Test Data Generation Guidance\\n\\n**Note**: The following guidance is for generating test configurations covering all 6 test scenarios.\\n\\n#### Test Scenario Matrix\\n\\nBased on requirements.value and waivers.value combinations, generate 6 test scenarios:\\n\\n| Scenario | requirements.value | waivers.value | Test Objective |\\n|----------|-------------------|---------------|----------------|\\n| 1 | N/A | N/A | Basic existence validation |\\n| 2 | N/A | 0 | Global waiver mechanism |\\n| 3 | N/A | >0 | Selective waiver matching mechanism |\\n| 4 | >0 | N/A | Pattern matching - PASS path |\\n| 5 | >0 | 0 | Pattern matching - FAIL path + global waiver |\\n| 6 | >0 | >0 | Pattern matching - FAIL path + selective waiver |\\n\\n#### Inference Strategy\\n\\n**Step 1: Run Parsing Logic to obtain actual metadata**\\n\\nAfter Parsing Logic execution, analyze the actual output structure and content. Expected fields:\\n- `netlist.tool_name`: e.g., \\\"Genus\\\", \\\"Innovus\\\", \\\"Design Compiler\\\"\\n- `netlist.version`: e.g., \\\"21.1\\\", \\\"19.12-s090_1\\\"\\n- `netlist.date`: e.g., \\\"2025-01-15\\\", \\\"Jan 15 2025\\\"\\n- `spef.generator_info`: e.g., \\\"Innovus 21.1\\\", \\\"StarRC 2023.06\\\"\\n- `spef.date`: e.g., \\\"2025-01-15\\\"\\n\\n**Step 2: Extract representative keywords**\\n\\nFrom the `value` field of parsed objects, extract characteristic keywords:\\n\\n- **Tool names**: Extract from `netlist.tool_name` and `spef.generator_info`\\n  - Examples: `\\\"Genus\\\"`, `\\\"Innovus\\\"`, `\\\"PrimeTime\\\"`, `\\\"StarRC\\\"`, `\\\"Calibre\\\"`\\n  - Use for pattern matching in Scenarios 4-6\\n\\n- **Version numbers**: Extract from `netlist.version` and `spef.generator_info`\\n  - Examples: `\\\"21.1\\\"`, `\\\"19.12\\\"`, `\\\"2023.06\\\"`\\n  - Use for pattern matching in Scenarios 4-6\\n\\n- **Timestamps**: Extract year from `netlist.date` and `spef.date`\\n  - Examples: `\\\"2025\\\"`, `\\\"2024\\\"`, `\\\"2023\\\"`\\n  - Use for pattern matching in Scenarios 4-6\\n\\n- **Stage indicators**: Infer from file presence/absence\\n  - Examples: `\\\"synthesis\\\"` (if SPEF missing), `\\\"post-route\\\"` (if SPEF present)\\n  - Use for waiver matching in Scenarios 2-3, 5-6\\n\\n**Step 3: Generate test YAML configurations**\\n\\n```yaml\\n# Scenario 1: Basic existence check\\n# IMP-10-0-0-00_base.yaml\\nrequirements:\\n  value: N/A\\n  pattern_items: []\\nwaivers:\\n  value: N/A\\n  waive_items: []\\n\\n# Scenario 2: Global waiver\\n# IMP-10-0-0-00_global_waiver.yaml\\nrequirements:\\n  value: N/A\\n  pattern_items: []\\nwaivers:\\n  value: 0\\n  waive_items: [\\\"All netlist/SPEF version checks waived for legacy design\\\"]\\n\\n# Scenario 3: Selective waiver\\n# IMP-10-0-0-00_selective_waiver.yaml\\nrequirements:\\n  value: N/A\\n  pattern_items: []\\nwaivers:\\n  value: 2\\n  waive_items:\\n    - \\\"SPEF\\\"           # Waive SPEF-related failures (synthesis stage)\\n    - \\\"synthesis\\\"      # Waive synthesis-stage specific issues\\n\\n# Scenario 4: Pattern matching - PASS\\n# IMP-10-0-0-00_pattern_pass.yaml\\nrequirements:\\n  value: 2  # Two items require pattern matching: netlist version (2.2) and SPEF version (2.4)\\n  pattern_items:\\n    - \\\"Genus|Innovus|2025\\\"     # Netlist version: matches if contains tool name OR current year\\n    - \\\"Innovus|StarRC|2025\\\"    # SPEF version: matches if contains tool name OR current year\\nwaivers:\\n  value: N/A\\n  waive_items: []\\n\\n# Scenario 5: Pattern matching - FAIL + global waiver\\n# IMP-10-0-0-00_pattern_fail_global.yaml\\nrequirements:\\n  value: 2\\n  pattern_items:\\n    - \\\"DesignCompiler|2026\\\"    # Netlist version: does NOT match (wrong tool/future year)\\n    - \\\"PrimeTime|2026\\\"         # SPEF version: does NOT match (wrong tool/future year)\\nwaivers:\\n  value: 0\\n  waive_items: [\\\"Version mismatch waived for regression testing\\\"]\\n\\n# Scenario 6: Pattern matching - FAIL + selective waiver\\n# IMP-10-0-0-00_pattern_fail_selective.yaml\\nrequirements:\\n  value: 2\\n  pattern_items:\\n    - \\\"DesignCompiler|2026\\\"    # Netlist version: does NOT match\\n    - \\\"PrimeTime|2026\\\"         # SPEF version: does NOT match\\nwaivers:\\n  value: 3\\n  waive_items:\\n    - \\\"golden\\\"                 # Waive historical netlist timestamp\\n    - \\\"SPEF\\\"                   # Waive SPEF version mismatch\\n    - \\\"synthesis\\\"              # Waive synthesis-stage SPEF absence\\n```\\n\\n**Key Principles**:\\n1. **PASS scenarios (Scenario 4)**: Use patterns that match actual data values\\n   - Extract actual tool names and years from Parsing Logic output\\n   - Use OR (`|`) to combine multiple valid alternatives\\n   - Ensure at least one alternative matches for each pattern_item\\n\\n2. **FAIL scenarios (Scenarios 5-6)**: Use patterns that do NOT match actual data\\n   - Use wrong tool names (e.g., if actual is \\\"Genus\\\", use \\\"DesignCompiler\\\")\\n   - Use future years (e.g., \\\"2026\\\" when actual is \\\"2025\\\")\\n   - Ensure patterns intentionally mismatch to trigger validation failures\\n\\n3. **OR relationships**: Connect multiple keywords with `|` for higher match probability\\n   - Example: `\\\"Genus|Innovus|2025\\\"` matches if value contains ANY of these strings\\n   - Increases robustness across different tool versions and configurations\\n\\n4. **waive_items**: Reference matching keywords defined in Section 3\\n   - Use keywords from Section 3.1-3.4 for selective waivers\\n   - Ensure waiver patterns match the violation descriptions\\n\\n**Pattern Matching Correspondence**:\\n- **pattern_items[0]** \\u2192 Item 2.2 (Netlist version completeness)\\n  - Matches against `netlist.tool_name`, `netlist.version`, `netlist.date` combined value\\n- **pattern_items[1]** \\u2192 Item 2.4 (SPEF version completeness)\\n  - Matches against `spef.generator_info`, `spef.date` combined value\\n\\n**Important**: These are recommendations based on expected Parsing Logic output. After actual Parsing Logic execution, adjust patterns according to real metadata structure and content values.\\n\",\n  \"_item_id\": \"IMP-10-0-0-00\",\n  \"_source_path\": \"C:\\\\Users\\\\wentao\\\\Desktop\\\\AAI\\\\Main_work\\\\ACL\\\\Agentic-AI\\\\Agents\\\\codegen\\\\IMP-10-0-0-00_ItemSpec.md\"\n}\n",
  "model": "claude-sonnet-4-5",
  "atom_a_code_length": 11861
}