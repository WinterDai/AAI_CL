---

# Hierarchical Checker Architecture 10.2: The Verified Implementation Master (FINAL LOCKED)

**Status**: **DEPLOYMENT READY**. Use this document for coding, testing, and QA.
**Scope**: This **10.2** is the single source of truth and includes all locked constraints from 7.0–10.1 plus 10.2 audit fixes.
**Rule**: This spec must not contain “or / optional / if you want” branches.
**Note (Locked Override)**: This spec is **stricter than** `/mnt/data/global_rules.md` in specific areas (e.g., `value` type, wildcard matching uses `fnmatchcase`, alternatives trimming/empty handling). When conflict exists, **this 10.2 spec wins**.

---

## 1. Atomic Contracts (Layer 2: LLM Plugin)

All LLM-generated code MUST implement these Pure Functions. **No IO allowed.**
**PR5**: Atoms MUST NOT filter based on requirements/waivers patterns.
### 1. ATOM A: `extract_context`

```python
from typing import List, Dict, Any

# [Locked] Interface Definition
ParsedItem = Dict[str, Any]

def extract_context(text: str, source_file: str) -> List[ParsedItem]:
    """
    Layer 2 Atom A: Context Extractor
    Constraints: 
    1. NO IO allowed.
    2. PR5: Do NOT filter results based on patterns.
    3. Value Type Hard Lock: 'value' MUST be cast to str.
    """
    results = []
    
    # --- [AGENT FILL AREA START] ---
    # 开发者在此处编写解析逻辑，将结果存入 results 列表
    # 示例结构: results.append({"value": "raw_val", "line_number": 1, ...})
    # --- [AGENT FILL AREA END] ---

    # [Locked] Standardization Layer
    # 强制执行数据接口契约，防止 Layer 3 崩溃
    standardized_output = []
    for item in results:
        # [Critical] Ensure value is string (Gate 1 Requirement)
        safe_value = str(item.get("value", ""))
        
        standardized_item = {
            "value": safe_value,
            "source_file": source_file,           # 透传元数据
            "line_number": item.get("line_number"), # 允许 None
            "matched_content": str(item.get("matched_content", "")),
            "parsed_fields": item.get("parsed_fields", {}) # 必须是非 None 字典
        }
        standardized_output.append(standardized_item)
        
    return standardized_output
```

---

### 2. ATOM B: `validate_logic`

```python
import re
import fnmatch
from typing import Dict, Optional, Any

MatchResult = Dict[str, Any]

def validate_logic(
    text: str, 
    pattern: str, 
    parsed_fields: Optional[Dict] = None,
    default_match: str = "contains",  # Layer 3/4 注入点
    regex_mode: str = "search"        # Layer 3/4 注入点
) -> MatchResult:
    """
    Layer 2 Atom B: Universal Logic Validator
    Logic: Alternatives > Regex > Wildcard > Default
    Supports: Check Logic (contains/search) AND Waiver Logic (exact/match)
    """
    # [Locked] None Safety
    if parsed_fields is None:
        parsed_fields = {}

    # 1. Alternatives Logic ('|') - Highest Precedence
    # Note: Regex/Wildcard chars inside alternatives are treated as LITERALS
    if '|' in pattern:
        segments = [s.strip() for s in pattern.split('|') if s.strip()]
        for seg in segments:
            # Alternatives always use 'contains' semantics
            if seg in text:
                return {'is_match': True, 'reason': f"Alternative '{seg}' found", 'kind': 'alternatives'}
        return {'is_match': False, 'reason': "No alternatives found", 'kind': 'alternatives'}

    # 2. Regex Logic (startswith 'regex:')
    if pattern.startswith("regex:"):
        raw_regex = pattern[6:]
        try:
            # Policy Injection: Check uses 'search', Waiver uses 'match'
            mode = regex_mode if regex_mode in {"search", "match"} else "search"
            
            if mode == 'match':
                match = re.match(raw_regex, text)
            else:
                match = re.search(raw_regex, text)
                
            if match:
                return {'is_match': True, 'reason': "Regex matched", 'kind': 'regex'}
            else:
                return {'is_match': False, 'reason': "Regex not matched", 'kind': 'regex'}
        except re.error as e:
            # [Locked] Must handle bad regex gracefully
            return {'is_match': False, 'reason': f"Invalid Regex: {str(e)}", 'kind': 'regex'}

    # 3. Wildcard Logic ('*' or '?')
    # [Locked] Must use fnmatchcase for case sensitivity
    if '*' in pattern or '?' in pattern:
        if fnmatch.fnmatchcase(text, pattern):
            return {'is_match': True, 'reason': "Wildcard matched", 'kind': 'wildcard'}
        else:
            return {'is_match': False, 'reason': "Wildcard not matched", 'kind': 'wildcard'}

    # 4. Default Logic (String Literal)
    # Policy Injection: Check uses 'contains', Waiver uses 'exact'
    mode = default_match if default_match in {"contains", "exact"} else "contains"
    
    if mode == "exact":
        is_hit = (text == pattern)
    else:
        is_hit = (pattern in text)

    return {
        'is_match': is_hit, 
        'reason': f"Default {mode} check", 
        'kind': mode
    }
```

---

### 3. ATOM C: `check_existence`

```python
from typing import List, Dict, Any

def check_existence(items: List[Dict]) -> Dict:
    """
    Layer 2 Atom C: Existence Checker
    Used ONLY by Type 1 / Type 4 runners.
    Required for Gate 1 Signature Compliance.
    """
    # Logic: If items extracted > 0, existence is proved.
    if items and len(items) > 0:
        return {
            'is_match': True, 
            'reason': f"Found {len(items)} items", 
            'evidence': items  # [Locked] Must pass evidence back to Framework
        }
    else:
        return {
            'is_match': False, 
            'reason': "No items found", 
            'evidence': []
        }
```

---

## 2. Framework Specification (Fixed Python Code)

### Layer 0: Orchestrator

**Runtime Dispatch (Locked)**: `TYPE_RUNNERS = {1:..., 2:..., 3:..., 4:...}`.

#### Config Normalization & Validation (Locked)

Framework MUST normalize `req.value` and `waiver.value` before type decision:

* **N/A Definition (Locked)**: missing key OR null OR (string after strip equals `"N/A"`). Numeric `0` is **NOT** N/A.
* If value is a string numeric (e.g., `"0"`, `"2"`), Framework MUST parse to integer.
* **Valid domain (Locked)**:

  * `req.value` MUST be either N/A or an integer **>= 1**.
  * `waiver.value` MUST be either N/A or an integer **>= 0**.
* If outside domain, Framework MUST raise a **ConfigError** and MUST NOT dispatch any runner.

#### Type Decider (Locked Mapping)

After normalization:

* `req.value = N/A`, `waiver.value = N/A` → **Type 1**
* `req.value >= 1`, `waiver.value = N/A` → **Type 2**
* `req.value >= 1`, `waiver.value >= 0` → **Type 3**
* `req.value = N/A`, `waiver.value >= 0` → **Type 4**

#### Internal Result State (Locked)

Framework internal result state MUST always initialize list keys (empty lists by default), regardless of Type:

`found_items`, `missing_items`, `extra_items`, `waived`, `unused_waivers`.

Output Controller applies CR5 filtering only at final output.

Integration MUST traverse all Types via Gate 3 test matrix.

---

### Layer 1: IO Engine (Locked)

* Handles `open`, `gzip`, encoding fallback, absolute path normalization.
* Supplies `text` to Atom A; Atoms never see file I/O.
* Indirect Reference Resolution: Resolve relative paths against current file directory, normalize to absolute.

---

### Layer 2: Parsing Orchestration (Locked)

#### Indirect Reference Normalization

* If `parsed_fields["indirect_reference"]` is `str` → convert to `List[str]`
* If `List[str]` → use as is

Each indirect reference path MUST be resolved to absolute path using IO Engine rules.

#### Recursion Guard

* `max_depth = 5`
* `visited_paths = set()` loop detection: revisiting a path MUST skip recursion (no infinite loop).

#### Traversal Order (Locked)

* Root files follow `input_files` list order (insertion order)
* Indirect refs follow DFS discovery order

#### Stable Sort Order (Locked) for `ParsedItems_All`

`ParsedItems_All` MUST be sorted stably by:

1. File Order: insertion + DFS recursion discovery order
2. Line Order: ascending `line_number` (`None` treated as +∞, last)
3. Extraction Order: preserve Atom A list order for same file & same line

#### searched_files Source (Locked)

`searched_files` MUST include all **successfully read** absolute paths in parsing traversal (root + indirect refs), then be **deduplicated and sorted alphabetically**.

---

### Layer 3: Check Assembler (Locked)

#### Type 2 / Type 3 (Pattern Check Path)

Consumption Strategy (Locked): **First Unconsumed Match**

* For each requirement pattern (in order), scan `ParsedItems_All` (stable order)
* First item that matches AND is not consumed → consume it, append to `found_items`, break inner loop
* If no match found → produce one `missing_item` for that pattern

**Policy Injection (Locked)**: Requirements matching MUST call Atom B with:

* `default_match="contains"`, `regex_mode="search"`

**Atom B Call Form (Locked)**:
Framework MUST call Atom B exactly as:

`validate_logic(text=item['value'], pattern=str(req_pattern), parsed_fields=item['parsed_fields'], default_match="contains", regex_mode="search")`.

**Output Schema Enforcer (2.4.2 + Locked Extensions)**:

* `found_items`: each item MUST contain full ParsedItem fields + `description`
* `missing_items` MUST contain:

  * `description`
  * `expected` = `str(req_pattern)`
  * `searched_files` = (abs paths, dedup + alpha sorted)
  * `line_number = None`
  * Ghost Fields (Locked):

    * `source_file = ""`
    * `matched_content = ""`
    * `parsed_fields = {}`
* `extra_items`: all unconsumed ParsedItems + `description`

**Status Rule (Locked)**:

* Type 2: `status = PASS` iff `missing_items` and `extra_items` are both empty; else `FAIL`.
* Type 3: this rule is evaluated **after selective waiver MOVE**, and is **overridden to PASS** in global waiver mode (`waiver.value=0`).

#### Type 1 / Type 4 (Existence Path)

Framework MUST call Atom C on `ParsedItems_All` and map outputs deterministically:

* If `AtomC.is_match=True`:

  * `found_items = evidence` (each evidence item augmented with `description`)
  * `missing_items = []`
  * `status = PASS`
* If `AtomC.is_match=False` (Locked — no optional branch):

  * `found_items = []`
  * `missing_items` MUST contain **exactly 1** ghost record:

    * `description` (from item.yaml item description)
    * `expected` MUST be exactly `"Existence check failed"`
    * `searched_files` (abs paths, dedup + sorted)
    * `line_number = None`
    * Ghost Fields:

      * `source_file = ""`
      * `matched_content = ""`
      * `parsed_fields = {}`
  * `status = FAIL` (may be changed by waiver engine rules in Type 4)

---

## 3. Waiver Engine (Locked)

### Global Waiver (`waiver.value = 0`) — Locked

* **Invariant (Persistence)**: Violations remain in `missing_items` / `extra_items` (do NOT remove).
* **Allowed Mutation Only (Locked, overwrite semantics)**:

  * Set `severity = "INFO"`
  * Set `tag = "[WAIVED_AS_INFO]"`
* **Forbidden Mutation**: MUST NOT delete/rename existing keys.

**Comment Injection to `waived` (Locked)**:
For each string in `waivers.waive_items` (normalized to list and cast to str), append:

`{'waiver_pattern': str(item_str), 'waiver_reason': "Global Waiver", 'tag': "[WAIVED_INFO]"}`

**Global Status (Locked)**: Force `status = "PASS"`.

**unused_waivers (Locked)**:
In global mode, `unused_waivers` MUST be `[]` (Types that output this key).

### Selective Waiver (`waiver.value > 0`) — Locked

**Policy Injection (Locked)**: Framework MUST call Atom B with:

* `default_match="exact"`, `regex_mode="match"`.

**Target Set (Locked)**:

* Type 4: `missing_items` only
* Type 3: `missing_items` then `extra_items`

**Violation Iteration Order (Locked)**:
Iterate violations in order: `missing_items` list order first, then `extra_items` list order.

**Violation Text Source (Locked)**:
`violation_text = v.get("expected") or v.get("value") or v.get("description") or ""`
Framework MUST cast `violation_text = str(violation_text)` before matching.

**Atom B Call Form (Locked)**:
Selective waiver matching MUST call:

`validate_logic(text=violation_text, pattern=str(waive_pattern), parsed_fields=None, default_match="exact", regex_mode="match")`.

**N-to-M Matching (Locked)**:

* One waive pattern may match multiple violations.
* Track match count per pattern.
* `unused_waivers` contains only patterns with zero matches, preserving waive_items order:
  `{'pattern': str(waive_pattern), 'reason': "Not matched"}`

**Conflict Determinism (Locked)**:

* For each violation, evaluate `waive_items` in order.
* First matched pattern wins.
* A violation MUST be moved at most once.

**Invariant (Removal) + Order Stability (Locked)**:

* Matched violations MUST be **MOVED** out of `missing_items`/`extra_items` into `waived`.
* Remaining `missing_items` and `extra_items` MUST preserve original order.
* `waived` MUST preserve the violation iteration order (missing then extra) and within each, original list order.

**Waived Output Schema (2.4.3, Locked overwrite tag semantics)**:
Each waived item = original violation fields +:

* `waiver_pattern` (matched pattern string)
* `waiver_reason` (default `"N/A"`)
* set `tag = "[WAIVER]"`

**Type 4 status after selective waiver (Locked)**:

* After MOVE, `status = PASS` iff `missing_items` is empty; else `FAIL`.

---

## 4. Output Controller (CR5 Strict Keys, Locked)

Must filter keys to exact set by Type ID; keys must exist even if empty lists:

* Type 1: `status`, `found_items`, `missing_items`
* Type 2: `status`, `found_items`, `missing_items`, `extra_items`
* Type 3: `status`, `found_items`, `missing_items`, `extra_items`, `waived`, `unused_waivers`
* Type 4: `status`, `found_items`, `missing_items`, `waived`, `unused_waivers`

---

## 5. Sandbox Gatekeepers (QA Layer, Locked)

Generated code MUST pass ALL tests before Runtime integration.

### Gate 1: Atomic Integrity (Signature + Schema + Value Type)

**Signature Check (Locked)**:

* Atom A/B/C functions MUST exist with exact names.
* Atom B MUST accept `default_match` and `regex_mode` parameters.

**Schema Check (Locked)**:
Every ParsedItem from Atom A MUST contain keys:
`{'value','source_file','line_number','matched_content','parsed_fields'}` with types:

* `value`: str
* `source_file`: str
* `matched_content`: str
* `parsed_fields`: dict
* `line_number`: int or None

**Value Type Safety (Locked)**:

* Assert `isinstance(item['value'], str)` for every ParsedItem
* Failure message MUST include: `"ParsedItem['value'] must be str"`

### Gate 2: Matcher Robustness & Precedence (Atom B)

Required test vectors (all MUST pass, no exceptions):

1. None-Safety
   `validate_logic("abc","a", parsed_fields=None)` → no exception

2. Empty Alternatives
   `validate_logic("abc","|a||")` → `is_match=True`, `kind="alternatives"`

3. Bad Regex
   `validate_logic("abc","regex:[", regex_mode="search")` → `is_match=False`, `kind="regex"`, reason startswith `"Invalid Regex:"`

4. Literal Alternatives
   `validate_logic("regex:^a", "regex:^a|zzz")` → match (contains literal)
   `validate_logic("abc", "regex:^a|zzz")` → no match

5. Wildcard Priority
   `validate_logic("abc","a*c")` → wildcard branch (`kind="wildcard"`)

6. Default Strategy Policy
   `validate_logic("abc","b", default_match="contains")` → match (`kind="contains"`)
   `validate_logic("abc","b", default_match="exact")` → no match (`kind="exact"`)

7. regex_mode Invalid Value
   `validate_logic("abc","regex:^a", regex_mode="BAD")` → MUST NOT raise; behavior equals `regex_mode="search"`

### Gate 3: Integration Schema (CR5 + Waiver Logic + Sorting) — Locked Test Matrix

Gate 3 MUST run the pipeline with the following **6 configurations** (minimum locked set):

1. Type 1: `req=N/A`, `waiver=N/A`
2. Type 2: `req=1`, `waiver=N/A`
3. Type 3 (Global): `req=1`, `waiver=0`
4. Type 3 (Selective): `req=1`, `waiver=1`
5. Type 4 (Global): `req=N/A`, `waiver=0`
6. Type 4 (Selective): `req=N/A`, `waiver=1`

For each run, assert:

* **Exact key set per Type** (CR5)
* **missing_items schema**:

  * `searched_files` is a sorted list of absolute paths (dedup + alpha sort)
  * Ghost fields exist where required: `source_file=""`, `matched_content=""`, `parsed_fields={}`
* **Parsing recursion (PR2)**:

  * Mock Atom A returns `parsed_fields={"indirect_reference":"file2"}`
  * Verify Framework loads `file2` and merges `ParsedItems_All`
* **Stable sorting**:

  * Verify final `ParsedItems_All` respects File>Line(None last)>Extraction order
* **Global waiver mode** (runs 3 and 5):

  * `missing_items`/`extra_items` carry `severity="INFO"` and `tag="[WAIVED_AS_INFO]"`
  * `waived` contains comment records with `tag="[WAIVED_INFO]"` and `waiver_reason="Global Waiver"`
  * `unused_waivers == []` for types that output it
* **Selective waiver mode** (runs 4 and 6):

  * Any item moved to `waived` MUST NOT remain in `missing_items`/`extra_items`
  * `unused_waivers` MUST contain only patterns with zero matches, preserving waive_items order

---



graph TD
    %% Define Styles
    classDef framework fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
    classDef plugin fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,stroke-dasharray: 5 5;
    classDef qa fill:#ffebee,stroke:#c62828,stroke-width:2px;
    classDef data fill:#f3e5f5,stroke:#4a148c,stroke-width:1px;

    subgraph Layer0_Orchestrator [Layer 0: Orchestrator]
        Config[item.yaml] --> Dispatcher{Type Decider}
    end

    subgraph Layer1_IO [Layer 1: IO Engine]
        IO[File Reader & Path Resolver]
    end

    subgraph Layer2_Parsing [Layer 2: Parsing Orchestration]
        PE[Parsing Engine]
        Sort[Stable Sort: File>Line>Extraction]
        Recurse[Recursion Guard: Max Depth 5]
    end

    subgraph Layer2_Plugin [Layer 2: LLM Plugin Atoms]
        AtomA(Atom A: extract_context<br/>Value=str)
        AtomB(Atom B: validate_logic<br/>Precedence: Alt>Regex>Wildcard)
        AtomC(Atom C: check_existence)
    end

    subgraph Layer3_Check [Layer 3: Check Assembler]
        CA[Check Logic]
        Strat[Strategy: First Unconsumed Match]
        Ghost[Add Ghost Fields]
    end

    subgraph Layer4_Waiver [Layer 4: Waiver Engine]
        WE{Waiver Value?}
        Global[Global Mode: value=0]
        Select[Selective Mode: value>0]
    end

    subgraph Layer5_Output [Layer 5: Output Controller]
        OC[CR5 Strict Key Filtering]
    end

    %% Data Flow
    Dispatcher -->|Type 1-4| IO
    IO -->|Text| AtomA
    AtomA -->|ParsedItems| PE
    PE --> Recurse -->|Indirect Ref| IO
    PE --> Sort -->|ParsedItems_All| CA

    %% Check Logic Flow
    CA -->|Type 2/3 Requirements| AtomB
    CA -->|Type 1/4 Existence| AtomC
    
    %% Policy Injection Arrows
    CA -- "Policy: contains / search" --> AtomB
    
    %% Waiver Flow
    CA -->|Violations| WE
    WE -- "0" --> Global
    WE -- ">0" --> Select
    
    Select -- "Policy: exact / match" --> AtomB
    AtomB -->|Match?| Select
    
    Global -->|Mutated Items| OC
    Select -->|Moved Items| OC
    
    %% Styling
    class Dispatcher,IO,PE,Sort,Recurse,CA,Strat,Ghost,WE,Global,Select,OC framework;
    class AtomA,AtomB,AtomC plugin;



----


flowchart TD
    Start([Violations Input]) --> Decision{waivers.value?}
    
    %% Global Waiver Path
    subgraph Global_Mode [Global Waiver (value=0)]
        direction TB
        G1[Target: missing_items + extra_items]
        G2[Action: MUTATE]
        G3[Set severity='INFO']
        G4[Add tag='WAIVED_AS_INFO']
        G5[Inject Comments to 'waived']
        G6[Force Status = PASS]
        
        G1 --> G2 --> G3 --> G4 --> G5 --> G6
    end
    
    %% Selective Waiver Path
    subgraph Selective_Mode [Selective Waiver (value>0)]
        direction TB
        S1[Target: missing + extra]
        S2[Load Waive Patterns]
        Loop[Loop: For each Violation]
        
        subgraph Matching [N-to-M Matching]
            M1{Match vs Patterns?}
            Policy[Policy: exact / match]
            AtomB[[Call Atom B]]
        end
        
        Move[Action: MOVE]
        S_Waived[Add to 'waived' list]
        S_Keep[Keep in missing/extra]
        CheckUnused{Pattern used?}
        WARN[unused_waivers]
        
        S1 --> S2 --> Loop
        Loop --> M1
        Policy -.-> AtomB
        M1 -- Input Text --> AtomB
        AtomB -- is_match? --> Result{Result}
        
        Result -- Yes --> Move --> S_Waived
        Result -- No --> S_Keep
        
        S_Waived --> CheckUnused
        S_Keep --> CheckUnused
        CheckUnused -- Count=0 --> WARN
    end
    
    Decision -- "0" --> G1
    Decision -- "> 0" --> S1
    
    G6 --> Output([Final Output])
    WARN --> Output
    
    %% Styling
    classDef mutation fill:#ffecb3,stroke:#ff6f00,stroke-width:2px;
    classDef movement fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px;
    
    class G1,G2,G3,G4,G5,G6 mutation;
    class S1,S2,Move,S_Waived,S_Keep movement;
