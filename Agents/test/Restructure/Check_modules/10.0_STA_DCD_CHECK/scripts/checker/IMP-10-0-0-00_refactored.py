################################################################################
# Script Name: IMP-10-0-0-00_refactored.py
#
# Purpose:
#   Refactored version using Template Method pattern.
#   Only 4 _execute_type methods are simplified to 4-line calls.
#   Business logic (_parse_input_files) remains unchanged.
#
# Refactoring Scope:
#   - Type 1/2/3/4 methods: Simplified to Template Method calls
#   - Business logic: Unchanged (full compatibility)
#   - Framework: Extended OutputBuilderMixin with execute_boolean_check/execute_value_check
#
# Changes from Original:
#   - _execute_type1/2/3/4: 150 lines → 16 lines (89% reduction)
#   - waiver handling: Moved to Framework
#   - Format conversion: Moved to Framework
#   - Parameter passing: Eliminated
#
# Date: 2026-01-02
################################################################################

from pathlib import Path
import re
import sys
import gzip
from typing import List, Dict, Tuple, Optional, Any


# Add common module to path
_SCRIPT_DIR = Path(__file__).resolve().parent
_CHECK_MODULES_DIR = _SCRIPT_DIR.parents[2]  # Go up to Check_modules/
_COMMON_DIR = _CHECK_MODULES_DIR / 'common'
if str(_COMMON_DIR) not in sys.path:
    sys.path.insert(0, str(_COMMON_DIR))

from base_checker import BaseChecker, CheckResult, ConfigurationError
from output_formatter import DetailItem, Severity, create_check_result
from checker_templates.waiver_handler_template import WaiverHandlerMixin
from checker_templates.output_builder_template_refactored import OutputBuilderMixinRefactored


class NetlistSpefVersionCheckerRefactored(BaseChecker, WaiverHandlerMixin, OutputBuilderMixinRefactored):
    """
    Refactored checker using Template Method pattern.
    
    Check Target: Confirm the netlist/spef version is correct
    
    Refactoring Benefits:
    - Code reduction: 150 lines → 16 lines (Type methods)
    - Error reduction: Eliminated parameter passing errors
    - Maintainability: Business logic separated from framework code
    """
    
    def __init__(self):
        super().__init__(
            check_module="10.0_STA_DCD_CHECK",
            item_id="IMP-10-0-0-00",
            item_desc="Confirm the netlist/spef version is correct"
        )
        self._metadata: Dict[str, Dict[str, Any]] = {}
        self._netlist_info: Dict[str, Any] = {}
        self._spef_info: Dict[str, Any] = {}
        self._sta_log_info: Dict[str, Any] = {}
    
    # =========================================================================
    # Business Logic (Unchanged - LLM Core Value)
    # =========================================================================
    
    def _read_file_content(self, file_path: Path, max_lines: int = 100) -> List[str]:
        """Read file content, supporting both plain text and gzip compressed files."""
        if not file_path.exists():
            return []
        
        try:
            # Try gzip first
            if file_path.suffix == '.gz' or str(file_path).endswith('.gz'):
                try:
                    with gzip.open(file_path, 'rt', encoding='utf-8', errors='ignore') as f:
                        lines = []
                        for i, line in enumerate(f):
                            if i >= max_lines:
                                break
                            lines.append(line.strip())
                        return lines
                except:
                    pass
            
            # Fallback to plain text
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = []
                for i, line in enumerate(f):
                    if i >= max_lines:
                        break
                    lines.append(line.strip())
                return lines
        except Exception as e:
            print(f"Warning: Failed to read {file_path}: {e}")
            return []
    
    def _parse_netlist_version(self, netlist_path: Path) -> Dict[str, str]:
        """Parse netlist file to extract version information."""
        version_info = {
            'tool': '',
            'version': '',
            'date': '',
            'time': '',
            'full_timestamp': ''
        }
        
        if not netlist_path.exists():
            return version_info
        
        lines = self._read_file_content(netlist_path, max_lines=50)
        
        for line in lines:
            # Extract tool and version
            if 'Generated by' in line and 'Genus' in line:
                match = re.search(r'Synthesis Solution\s+([\d\.\-\w]+)', line)
                if match:
                    version_info['tool'] = 'Cadence Genus Synthesis Solution'
                    version_info['version'] = match.group(1)
            
            # Extract generation date
            elif 'Generated on:' in line:
                match = re.search(r'Generated on:\s+(\w+\s+\d+\s+\d+)\s+([\d:]+)', line)
                if match:
                    version_info['date'] = match.group(1)
                    version_info['time'] = match.group(2)
                    version_info['full_timestamp'] = f"{match.group(1)} {match.group(2)}"
        
        return version_info
    
    def _parse_spef_version(self, spef_path: Path) -> Dict[str, str]:
        """Parse SPEF file to extract version information."""
        version_info = {
            'design': '',
            'date': '',
            'vendor': '',
            'program': '',
            'version': '',
            'spef_standard': ''
        }
        
        if not spef_path.exists():
            return version_info
        
        lines = self._read_file_content(spef_path, max_lines=100)
        
        for line in lines:
            if line.startswith('*SPEF'):
                match = re.search(r'\*SPEF\s+"([^"]+)"', line)
                if match:
                    version_info['spef_standard'] = match.group(1)
            
            elif line.startswith('*DESIGN'):
                match = re.search(r'\*DESIGN\s+"([^"]+)"', line)
                if match:
                    version_info['design'] = match.group(1)
            
            elif line.startswith('*DATE'):
                match = re.search(r'\*DATE\s+"([^"]+)"', line)
                if match:
                    version_info['date'] = match.group(1)
            
            elif line.startswith('*VENDOR'):
                match = re.search(r'\*VENDOR\s+"([^"]+)"', line)
                if match:
                    version_info['vendor'] = match.group(1)
            
            elif line.startswith('*PROGRAM'):
                match = re.search(r'\*PROGRAM\s+"([^"]+)"', line)
                if match:
                    version_info['program'] = match.group(1)
            
            elif line.startswith('*VERSION'):
                match = re.search(r'\*VERSION\s+"([^"]+)"', line)
                if match:
                    version_info['version'] = match.group(1)
        
        return version_info
    
    def _resolve_relative_path(self, relative_path: str, sta_log_dir: Path) -> Optional[Path]:
        """Resolve relative path from STA log to absolute path."""
        if not relative_path:
            return None
        
        try:
            clean_path = relative_path.strip().strip('"').strip("'")
            abs_path = (sta_log_dir / clean_path).resolve()
            
            if abs_path.exists():
                return abs_path
            
            if self.root:
                abs_path = (self.root / clean_path).resolve()
                if abs_path.exists():
                    return abs_path
        except Exception as e:
            print(f"Warning: Failed to resolve path {relative_path}: {e}")
        
        return None
    
    def _parse_sta_log(self) -> Dict[str, Any]:
        """Parse STA log file to extract netlist/SPEF information."""
        sta_info = {
            'netlist_path': None,
            'netlist_status': 'Not Found',
            'spef_path': None,
            'spef_status': 'Not Found',
            'errors': [],
            'warnings': []
        }
        
        if not self.item_data or 'input_files' not in self.item_data:
            raise ConfigurationError("No input_files specified in configuration")
        
        input_files = self.item_data['input_files']
        
        if not input_files or len(input_files) == 0:
            raise ConfigurationError("input_files list is empty")
        
        sta_log_path = Path(input_files[0]).resolve()
        
        if not sta_log_path.exists():
            raise ConfigurationError(f"STA log file not found: {sta_log_path}")
        
        sta_log_dir = sta_log_path.parent
        current_section = None
        
        try:
            with open(sta_log_path, 'r', encoding='utf-8', errors='ignore') as f:
                for line_num, line in enumerate(f, 1):
                    line_stripped = line.strip()
                    
                    # Track sections
                    if 'Reading netlist' in line:
                        current_section = 'netlist'
                        self._metadata['netlist_section_start'] = {
                            'line_number': line_num,
                            'file_path': str(sta_log_path)
                        }
                    elif 'Reading SPEF' in line or 'Skipping SPEF reading' in line:
                        current_section = 'spef'
                        if 'Skipping SPEF reading' in line:
                            sta_info['spef_status'] = 'Skipped'
                            self._metadata['spef_skipped'] = {
                                'line_number': line_num,
                                'file_path': str(sta_log_path),
                                'reason': line_stripped
                            }
                    
                    # Extract netlist path
                    if current_section == 'netlist':
                        if '[INFO] ' in line and '.v' in line:
                            match = re.search(r'\[INFO\]\s+(.+\.v(?:\.gz)?)', line)
                            if match:
                                relative_path = match.group(1).strip()
                                absolute_path = self._resolve_relative_path(relative_path, sta_log_dir)
                                if absolute_path:
                                    sta_info['netlist_path'] = str(absolute_path)
                                else:
                                    sta_info['netlist_path'] = relative_path
                                
                                self._metadata['netlist_path_found'] = {
                                    'line_number': line_num,
                                    'file_path': str(sta_log_path)
                                }
                        
                        elif 'Successfully created' in line and 'netlist' in line.lower():
                            sta_info['netlist_status'] = 'Success'
                            self._metadata['netlist_success'] = {
                                'line_number': line_num,
                                'file_path': str(sta_log_path)
                            }
                    
                    # Extract SPEF path
                    elif current_section == 'spef':
                        if '[INFO] ' in line and '.spef' in line:
                            match = re.search(r'\[INFO\]\s+(.+\.spef(?:\.gz)?)', line)
                            if match:
                                relative_path = match.group(1).strip()
                                absolute_path = self._resolve_relative_path(relative_path, sta_log_dir)
                                if absolute_path:
                                    sta_info['spef_path'] = str(absolute_path)
                                else:
                                    sta_info['spef_path'] = relative_path
                                
                                self._metadata['spef_path_found'] = {
                                    'line_number': line_num,
                                    'file_path': str(sta_log_path)
                                }
                        
                        elif 'Step ended' in line and 'SPEF' in line:
                            if sta_info['spef_status'] != 'Skipped':
                                sta_info['spef_status'] = 'Success'
                            self._metadata['spef_step_end'] = {
                                'line_number': line_num,
                                'file_path': str(sta_log_path)
                            }
                    
                    # Detect errors
                    if '[ERROR]' in line:
                        sta_info['errors'].append(line_stripped)
                    elif '[WARN]' in line:
                        sta_info['warnings'].append(line_stripped)
        
        except Exception as e:
            raise ConfigurationError(f"Failed to parse STA log: {e}")
        
        return sta_info
    
    def _parse_input_files(self) -> Tuple[Dict[str, Any], Dict[str, Any], List[str]]:
        """
        Parse input files and extract netlist/SPEF version information.
        
        Returns:
            Tuple of (netlist_info, spef_info, errors)
        """
        sta_info = self._parse_sta_log()
        
        netlist_info = {
            'status': sta_info['netlist_status'],
            'path': None,
            'relative_path': None,
            'tool': '',
            'version': '',
            'date': '',
            'full_timestamp': ''
        }
        
        spef_info = {
            'status': sta_info['spef_status'],
            'path': None,
            'relative_path': None,
            'design': '',
            'date': '',
            'vendor': '',
            'program': '',
            'version': '',
            'skip_reason': ''
        }
        
        # Parse netlist version
        if sta_info['netlist_path']:
            netlist_path = Path(sta_info['netlist_path'])
            if netlist_path.exists():
                netlist_info['path'] = str(netlist_path)
                version_info = self._parse_netlist_version(netlist_path)
                netlist_info.update(version_info)
            else:
                netlist_info['relative_path'] = sta_info['netlist_path']
        
        # Parse SPEF version
        if sta_info['spef_status'] == 'Skipped':
            spef_info['skip_reason'] = self._metadata.get('spef_skipped', {}).get('reason', '')
        elif sta_info['spef_path']:
            spef_path = Path(sta_info['spef_path'])
            if spef_path.exists():
                spef_info['path'] = str(spef_path)
                version_info = self._parse_spef_version(spef_path)
                spef_info.update(version_info)
            else:
                spef_info['relative_path'] = sta_info['spef_path']
        
        errors = sta_info['errors']
        
        return netlist_info, spef_info, errors
    
    # =========================================================================
    # Helper Methods for Framework (LLM Core Value)
    # =========================================================================
    
    def _build_name_extractor(self):
        """Return name_extractor function for output formatting."""
        def extract_name(name, metadata):
            if isinstance(metadata, dict):
                version = metadata.get('version', '')
                date = metadata.get('date', '')
                note = metadata.get('note', '')
                if version and date:
                    return f"{name}, Version: {version}, Date: {date}"
                elif note:
                    return f"{name} ({note})"
            return name
        return extract_name
    
    def _determine_found_items(self, netlist_info: Dict, spef_info: Dict) -> Dict[str, Dict]:
        """Determine found items (LLM business logic)."""
        found_items = {}
        
        # Check netlist
        if netlist_info.get('status') == 'Success':
            if netlist_info.get('path'):
                netlist_path = netlist_info.get('path', 'Unknown')
                version_str = netlist_info.get('version', 'Unknown')
                date_str = netlist_info.get('full_timestamp', netlist_info.get('date', 'Unknown'))
                
                metadata = self._metadata.get('netlist_success', {})
                item_name = f"Netlist: {netlist_path}"
                found_items[item_name] = {
                    'line_number': metadata.get('line_number', ''),
                    'file_path': metadata.get('file_path', ''),
                    'version': version_str,
                    'date': date_str
                }
            elif netlist_info.get('relative_path'):
                netlist_rel_path = netlist_info['relative_path']
                metadata = self._metadata.get('netlist_success', {})
                item_name = f"Netlist: {netlist_rel_path}"
                found_items[item_name] = {
                    'line_number': metadata.get('line_number', ''),
                    'file_path': metadata.get('file_path', ''),
                    'note': 'found in log, file not accessible'
                }
        
        # Check SPEF
        if spef_info.get('status') == 'Success':
            if spef_info.get('path'):
                spef_path = spef_info.get('path', 'Unknown')
                version_str = spef_info.get('version', 'Unknown')
                date_str = spef_info.get('date', 'Unknown')
                
                metadata = self._metadata.get('spef_step_end', {})
                item_name = f"SPEF: {spef_path}"
                found_items[item_name] = {
                    'line_number': metadata.get('line_number', ''),
                    'file_path': metadata.get('file_path', ''),
                    'version': version_str,
                    'date': date_str
                }
        
        return found_items
    
    def _determine_violations(self, netlist_info: Dict, spef_info: Dict, errors: List[str]) -> List[str]:
        """Determine violations (LLM business logic)."""
        missing_items = []
        
        # Check netlist
        netlist_status = netlist_info.get('status', 'Not Found')
        if netlist_status != 'Success':
            missing_items.append(f"Netlist (Status: {netlist_status})")
        
        # Check SPEF
        spef_status = spef_info.get('status', 'Not Found')
        if spef_status == 'Skipped':
            metadata = self._metadata.get('spef_skipped', {})
            skip_reason = metadata.get('reason', 'SPEF reading was skipped')
            skip_reason = skip_reason.replace('[INFO] ', '')
            missing_items.append(f"SPEF Reading was skipped ({skip_reason})")
        elif spef_status != 'Success':
            missing_items.append(f"SPEF (Status: {spef_status})")
        
        # Add other errors
        for error in errors:
            if not any(e in error for e in ["SPEF reading was skipped"]):
                missing_items.append(f"Error: {error}")
        
        return missing_items
    
    def _determine_pattern_matches(self, netlist_info: Dict, spef_info: Dict) -> List[str]:
        """Determine pattern matches for Type 2/3 (LLM business logic)."""
        requirements = self.get_requirements()
        pattern_items = requirements.get('pattern_items', []) if requirements else []
        
        # Collect all content to search
        all_content = []
        
        # Add netlist version info
        if netlist_info.get('tool'):
            all_content.append(f"Tool: {netlist_info['tool']}")
        if netlist_info.get('version'):
            all_content.append(f"Genus Synthesis Solution {netlist_info['version']}")
        if netlist_info.get('full_timestamp'):
            all_content.append(f"Generated on: {netlist_info['full_timestamp']}")
        
        # Add SPEF version info
        if spef_info.get('program'):
            all_content.append(f"Program: {spef_info['program']}")
        if spef_info.get('version'):
            all_content.append(f"VERSION {spef_info['version']}")
        if spef_info.get('date'):
            all_content.append(f"DATE {spef_info['date']}")
        
        # Match patterns
        matched_patterns = []
        for pattern in pattern_items:
            for content in all_content:
                if self._match_pattern(content, [pattern]):
                    matched_patterns.append(pattern)
                    break
        
        return matched_patterns
    
    def _match_pattern(self, text: str, patterns: List[str]) -> Optional[str]:
        """Match text against pattern list (supports wildcard)."""
        if not text or not patterns:
            return None
        
        for pattern in patterns:
            # Try wildcard match
            if '*' in pattern:
                regex_pattern = pattern.replace('*', '.*')
                try:
                    if re.search(regex_pattern, text, re.IGNORECASE):
                        return pattern
                except re.error:
                    if pattern.lower() in text.lower():
                        return pattern
        return None
    
    # =========================================================================
    # Refactored Type Methods (Template Method Pattern)
    # =========================================================================
    
    def _execute_type1(self) -> CheckResult:
        """
        Type 1: Boolean check with automatic waiver.value=0 support.
        
        Refactored: Business logic → Framework Template Method
        """
        netlist_info, spef_info, errors = self._parse_input_files()
        return self.execute_boolean_check(
            netlist_info=netlist_info,
            spef_info=spef_info,
            errors=errors,
            has_waiver=False
        )
    
    def _execute_type2(self) -> CheckResult:
        """
        Type 2: Value comparison with automatic waiver.value=0 support.
        
        Refactored: Business logic → Framework Template Method
        """
        netlist_info, spef_info, errors = self._parse_input_files()
        return self.execute_value_check(
            netlist_info=netlist_info,
            spef_info=spef_info,
            errors=errors,
            has_waiver=False
        )
    
    def _execute_type3(self) -> CheckResult:
        """
        Type 3: Value comparison with waiver logic.
        
        Refactored: Business logic → Framework Template Method
        """
        netlist_info, spef_info, errors = self._parse_input_files()
        return self.execute_value_check(
            netlist_info=netlist_info,
            spef_info=spef_info,
            errors=errors,
            has_waiver=True
        )
    
    def _execute_type4(self) -> CheckResult:
        """
        Type 4: Boolean check with waiver logic.
        
        Refactored: Business logic → Framework Template Method
        """
        netlist_info, spef_info, errors = self._parse_input_files()
        return self.execute_boolean_check(
            netlist_info=netlist_info,
            spef_info=spef_info,
            errors=errors,
            has_waiver=True
        )
    
    # =========================================================================
    # Entry Point
    # =========================================================================
    
    def execute_check(self) -> CheckResult:
        """Execute the check by auto-detecting type and calling appropriate method."""
        if self.root is None:
            raise RuntimeError("Checker not initialized. Call init_checker() first.")
        
        # Detect checker type
        checker_type = self.detect_checker_type()
        
        # Execute appropriate check based on type
        if checker_type == 1:
            return self._execute_type1()
        elif checker_type == 2:
            return self._execute_type2()
        elif checker_type == 3:
            return self._execute_type3()
        else:  # Type 4
            return self._execute_type4()


if __name__ == '__main__':
    checker = NetlistSpefVersionCheckerRefactored()
    checker.run()
