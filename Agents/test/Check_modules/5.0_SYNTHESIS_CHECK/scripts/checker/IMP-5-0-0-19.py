################################################################################
# Script Name: IMP-5-0-0-19.py
#
# Purpose:
#   1. Document DFT Transition % generated by the DFT flow.
#   2. Extract coverage percentage from ATPG dynamic delay log files.
#   3. Compare actual coverage against expected value from DATA_INTERFACE.yaml.
#
# Usage:
#   python IMP-5-0-0-19.py
#   (Normally invoked by module runner 5.0_SYNTHESIS_CHECK.py)
#
#
# Logic:
#   - Parse DFT ATPG log to extract Transition coverage percentage
#   - Compare coverage against DFT CoE expected value
#   - Verify coverage meets or exceeds requirements
# Author: yyin
# Date:   2025-11-04
# Refactored: 2025-11-27 (BaseChecker)
################################################################################

"""IMP-5-0-0-19: DFT Transition Coverage Check

Refactored to use BaseChecker for all 4 types with automatic detection.
Extracts ATCov% from ATPG dynamic delay log and compares against requirements.
"""

import sys
import re
from pathlib import Path
from typing import List, Dict, Optional, Tuple

# Add common modules to path
sys.path.insert(0, str(Path(__file__).resolve().parents[3] / 'common'))

from base_checker import BaseChecker, CheckResult, ConfigurationError
from output_formatter import DetailItem, Severity

ITEM_ID = "IMP-5-0-0-19"
ITEM_DESC = "Document DFT Transition % meets or exceeds expected value?"


class DFTTransitionChecker(BaseChecker):
    """
    Check DFT Transition coverage percentage against requirements.
    
    Supports all 4 checker types with automatic detection:
    - Type 1: Boolean check - verify coverage exists (no pattern, no waiver)
    - Type 2: Value check - verify coverage >= threshold (has pattern, no waiver)
    - Type 3: Boolean check with waiver (no pattern, has waiver)
    - Type 4: Value check with waiver (has pattern, has waiver)
    
    Extracts ATCov% from ATPG dynamic delay log file (2nd percentage value).
    """
    
    def __init__(self):
        super().__init__(
            check_module="5.0_SYNTHESIS_CHECK",
            item_id=ITEM_ID,
            item_desc=ITEM_DESC
        )
        self._missing_input_files: List[str] = []
        # Store coverage metadata: {percentage_str: {'line': int, 'file': Path, 'value': float}}
        self.coverage_metadata: Dict[str, Dict] = {}
    
    # ========================================================================
    # Main Execution
    # ========================================================================
    
    def execute_check(self) -> 'CheckResult':
        """
        Main execution logic that automatically detects checker type.
        
        Returns:
            CheckResult object with pass/fail status and details
        """
        try:
            # Auto-detect checker type
            checker_type = self.detect_checker_type()
            
            # Execute based on detected type
            if checker_type == 1:
                return self._execute_type1()
            elif checker_type == 2:
                return self._execute_type2()
            elif checker_type == 3:
                return self._execute_type3()
            elif checker_type == 4:
                return self._execute_type4()
            else:
                raise ValueError(f"Unknown checker type: {checker_type}")
        except ConfigurationError as e:
            return e.check_result
    
    def _get_input_files(self) -> Tuple[List[Path], List[str], bool]:
        """Retrieve configured input files using BaseChecker validation."""
        configured = bool(self.item_data and self.item_data.get('input_files'))
        valid_files, missing_files = self.validate_input_files()
        self._missing_input_files = missing_files
        return valid_files, missing_files, configured
    
    # ========================================================================
    # Core Parsing Methods
    # ========================================================================
    
    def _parse_atpg_log(self, log_path: Path) -> Optional[float]:
        """
        Extract ATCov% from ATPG dynamic delay log file.
        
        Format in log:
        INFO (TDA-221):   1425    1210          0    49.56%   40.60%       140052           09:10.89
                                                              ^^^^^^ This is ATCov% (2nd percentage)
        
        Returns:
            Coverage percentage as float, or None if not found
        """
        try:
            lines = log_path.read_text(encoding='utf-8', errors='ignore').splitlines()
        except Exception as e:
            self.logger.error(f"Failed to read log file {log_path}: {e}")
            return None
        
        # Look for INFO (TDA-220) or INFO (TDA-221) data lines
        for i, line in enumerate(lines, start=1):
            if 'INFO (TDA-220)' in line or 'INFO (TDA-221)' in line:
                # Skip header lines
                if '--- Tests ---' in line or 'Faults' in line or 'ATCov' in line:
                    continue
                
                # Extract all percentage values
                if '%' in line:
                    parts = line.split()
                    percentages = []
                    for part in parts:
                        if part.endswith('%'):
                            try:
                                val = float(part.rstrip('%'))
                                percentages.append(val)
                            except ValueError:
                                continue
                    
                    # Return second percentage (ATCov%)
                    if len(percentages) >= 2:
                        coverage_str = str(percentages[1])
                        self.coverage_metadata[coverage_str] = {
                            'line': i,
                            'file': log_path,
                            'value': percentages[1]
                        }
                        return percentages[1]
        
        return None
    
    # ========================================================================
    # Type 1: Boolean Check (No Pattern Items, No Waiver)
    # ========================================================================
    
    def _execute_type1(self) -> 'CheckResult':
        """
        Type 1: Boolean check - verify coverage data exists.
        
        Logic:
        - Parse ATPG log for ATCov%
        - PASS if coverage found (informational)
        - FAIL if coverage not found (execution error)
        
        Returns:
            CheckResult with coverage info or error
        """
        from output_formatter import create_check_result
        
        # Get waiver value for display mode check
        waivers = self.get_waivers()
        waiver_value = waivers.get('value', 'N/A') if waivers else 'N/A'
        waive_items = waivers.get('waive_items', []) if waivers else []
        
        # Check if waiver=0 (display mode)
        is_waiver_zero = (waiver_value == 0)
        
        # Parse input files
        input_files, missing_files, _ = self._get_input_files()
        if missing_files:
            missing_result = self.create_missing_files_error(missing_files)
            if missing_result:
                return missing_result
        if not input_files:
            return self.create_config_error("ATPG transition log file not configured")
        
        # Extract coverage
        coverage = self._parse_atpg_log(input_files[0])
        
        if coverage is None:
            return create_check_result(
                is_pass=False,
                value="ERROR",
                has_pattern_items=False,
                has_waiver_value=False,
                details=[],
                basic_errors=["ATCov% not found in ATPG dynamic delay log file"],
                item_desc=self.item_desc
            )
        
        # Coverage found - informational PASS
        coverage_str = str(coverage)
        metadata = self.coverage_metadata[coverage_str]
        
        reason = f"DFT Transition coverage: {coverage}%[WAIVED_AS_INFO]" if is_waiver_zero else f"DFT Transition coverage: {coverage}%"
        
        details = [DetailItem(
            severity=Severity.INFO,
            name=f"ATCov%:{coverage}%",
            line_number=str(metadata['line']),
            file_path=str(metadata['file']),
            reason=reason
        )]
        
        # Add waive_items if waiver=0
        if is_waiver_zero and waive_items:
            for item in waive_items:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=item,
                    line_number=0,
                    file_path="N/A",
                    reason="Waiver item[WAIVED_INFO]"
                ))
        
        info_groups = {
            "INFO01": {
                "description": "DFT Transition Coverage",
                "items": [detail.name for detail in details]
            }
        }
        
        return create_check_result(
            is_pass=True,
            value=coverage,
            has_pattern_items=False,
            has_waiver_value=bool(waive_items),
            details=details,
            info_groups=info_groups,
            item_desc=self.item_desc
        )
    
    # ========================================================================
    # Type 2: Value Check (Has Pattern Items, No Waiver)
    # ========================================================================
    
    def _execute_type2(self) -> 'CheckResult':
        """
        Type 2: Value check - verify coverage >= expected threshold.
        
        Logic:
        - Extract ATCov% from log
        - Compare against pattern_items threshold
        - PASS if actual >= expected
        - FAIL if actual < expected
        
        Returns:
            CheckResult with comparison result
        """
        from output_formatter import create_check_result
        
        # Get waiver value for display mode check
        waivers = self.get_waivers()
        waiver_value = waivers.get('value', 'N/A') if waivers else 'N/A'
        waive_items = waivers.get('waive_items', []) if waivers else []
        
        # Check if waiver=0 (display mode)
        is_waiver_zero = (waiver_value == 0)
        
        # Parse input files
        input_files, missing_files, _ = self._get_input_files()
        if missing_files:
            missing_result = self.create_missing_files_error(missing_files)
            if missing_result:
                return missing_result
        if not input_files:
            return self.create_config_error("ATPG dynamic delay log file not configured")
        
        # Extract coverage
        coverage = self._parse_atpg_log(input_files[0])
        
        if coverage is None:
            return create_check_result(
                is_pass=False,
                value="ERROR",
                has_pattern_items=True,
                has_waiver_value=False,
                details=[],
                basic_errors=["ATCov% not found in ATPG dynamic delay log file"],
                item_desc=self.item_desc
            )
        
        # Get expected threshold
        expected_items = self.item_data.get('requirements', {}).get('value', [])
        if not expected_items:
            # No threshold configured - treat as informational
            coverage_str = str(coverage)
            metadata = self.coverage_metadata[coverage_str]
            
            details = [
                DetailItem(
                    severity=Severity.WARN,
                    name="",
                    line_number="0",
                    file_path="N/A",
                    reason="Golden value expected but not provided"
                ),
                DetailItem(
                    severity=Severity.INFO,
                    name=f"ATCov%:{coverage}%",
                    line_number=str(metadata['line']),
                    file_path=str(metadata['file']),
                    reason=f"Current DFT Transition coverage: {coverage}%"
                )
            ]
            
            return create_check_result(
                is_pass=True,
                value=0,
                has_pattern_items=False,
                has_waiver_value=False,
                details=details,
                item_desc=self.item_desc
            )
        
        # Compare against threshold
        expected_threshold = float(expected_items[0])
        coverage_str = str(coverage)
        metadata = self.coverage_metadata[coverage_str]
        
        if is_waiver_zero:
            # waiver=0: Force PASS and convert to INFO
            reason = f"DFT Transition coverage: {coverage}% (threshold: {expected_threshold}%)[WAIVED_AS_INFO]"
            details = [DetailItem(
                severity=Severity.INFO,
                name=f"ATCov%:{coverage}%",
                line_number=str(metadata['line']),
                file_path=str(metadata['file']),
                reason=reason
            )]
            
            # Add waive_items
            for item in waive_items:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=item,
                    line_number=0,
                    file_path="N/A",
                    reason="Waiver item[WAIVED_INFO]"
                ))
            
            info_groups = {
                "INFO01": {
                    "description": "DFT Transition Coverage (waiver=0 display mode)",
                    "items": [f"ATCov%:{coverage}%"]
                }
            }
            
            return create_check_result(
                is_pass=True,
                value=coverage,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                info_groups=info_groups,
                item_desc=self.item_desc
            )
        
        if coverage >= expected_threshold:
            # PASS - meets or exceeds threshold
            details = [DetailItem(
                severity=Severity.INFO,
                name=f"ATCov%:{coverage}%",
                line_number=str(metadata['line']),
                file_path=str(metadata['file']),
                reason=f"Meets or exceeds expected value {expected_threshold}%"
            )]
            
            info_groups = {
                "INFO01": {
                    "description": "DFT Transition Coverage",
                    "items": [detail.name for detail in details]
                }
            }
            
            return create_check_result(
                is_pass=True,
                value=coverage,
                has_pattern_items=True,
                has_waiver_value=False,
                details=details,
                info_groups=info_groups,
                item_desc=self.item_desc
            )
        else:
            # FAIL - below threshold
            details = [DetailItem(
                severity=Severity.FAIL,
                name=f"ATCov%:{coverage}%",
                line_number=str(metadata['line']),
                file_path=str(metadata['file']),
                reason=f"Below expected value {expected_threshold}%"
            )]
            
            error_groups = {
                "ERROR01": {
                    "description": "DFT Transition coverage below requirement",
                    "items": [f"ATCov%:{coverage}%"]
                }
            }
            
            return create_check_result(
                is_pass=False,
                value=coverage,
                has_pattern_items=True,
                has_waiver_value=False,
                details=details,
                error_groups=error_groups,
                item_desc=self.item_desc
            )
    
    # ========================================================================
    # Type 3: Boolean Check with Waiver
    # ========================================================================
    
    def _execute_type3(self) -> 'CheckResult':
        """
        Type 3: Boolean check with waiver - informational only.
        
        This type is rarely used for coverage checks, but included for completeness.
        
        Returns:
            CheckResult with coverage info
        """
        from output_formatter import create_check_result
        
        # Parse input files
        input_files, missing_files, _ = self._get_input_files()
        if missing_files:
            missing_result = self.create_missing_files_error(missing_files)
            if missing_result:
                return missing_result
        if not input_files:
            return self.create_config_error("ATPG dynamic delay log file not configured")
        
        # Extract coverage
        coverage = self._parse_atpg_log(input_files[0])
        
        if coverage is None:
            return create_check_result(
                is_pass=False,
                value="ERROR",
                has_pattern_items=False,
                has_waiver_value=True,
                details=[],
                basic_errors=["ATCov% not found in ATPG dynamic delay log file"],
                item_desc=self.item_desc
            )
        
        # Coverage found - informational
        coverage_str = str(coverage)
        metadata = self.coverage_metadata[coverage_str]
        
        details = [DetailItem(
            severity=Severity.INFO,
            name=f"ATCov%",
            line_number=str(metadata['line']),
            file_path=str(metadata['file']),
            reason=f"DFT Transition coverage: {coverage}%"
        )]
        
        return create_check_result(
            is_pass=True,
            value=coverage,
            has_pattern_items=False,
            has_waiver_value=True,
            details=details,
            item_desc=self.item_desc
        )
    
    # ========================================================================
    # Type 4: Value Check with Waiver
    # ========================================================================
    
    def _execute_type4(self) -> 'CheckResult':
        """
        Type 4: Value check with waiver - verify coverage with waiver allowance.
        
        Logic:
        - Extract ATCov% from log
        - Compare against pattern_items threshold
        - If below threshold, check against waiver minimum
        - PASS if actual >= expected OR actual >= waiver_minimum
        - FAIL if actual < waiver_minimum
        
        Returns:
            CheckResult with comparison and waiver logic
        """
        from output_formatter import create_check_result
        
        # Parse input files
        input_files, missing_files, _ = self._get_input_files()
        if missing_files:
            missing_result = self.create_missing_files_error(missing_files)
            if missing_result:
                return missing_result
        if not input_files:
            return self.create_config_error("ATPG dynamic delay log file not configured")
        
        # Extract coverage
        coverage = self._parse_atpg_log(input_files[0])
        
        if coverage is None:
            return create_check_result(
                is_pass=False,
                value="ERROR",
                has_pattern_items=True,
                has_waiver_value=True,
                details=[],
                basic_errors=["ATCov% not found in ATPG dynamic delay log file"],
                item_desc=self.item_desc
            )
        
        # Get threshold and waiver
        expected_items = self.item_data.get('requirements', {}).get('value', [])
        waiver_value = self.item_data.get('waivers', {}).get('value', 0)
        
        if not expected_items:
            # No threshold - informational only
            coverage_str = str(coverage)
            metadata = self.coverage_metadata[coverage_str]
            
            details = [DetailItem(
                severity=Severity.INFO,
                name=f"ATCov%:{coverage}%",
                line_number=str(metadata['line']),
                file_path=str(metadata['file']),
                reason=f"DFT Transition coverage: {coverage}%"
            )]
            
            return create_check_result(
                is_pass=True,
                value=coverage,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                item_desc=self.item_desc
            )
        
        # Compare against threshold and waiver
        expected_threshold = float(expected_items[0])
        waiver_minimum = float(waiver_value)
        coverage_str = str(coverage)
        metadata = self.coverage_metadata[coverage_str]
        
        if coverage >= expected_threshold:
            # PASS - meets expected threshold
            details = [DetailItem(
                severity=Severity.INFO,
                name=f"ATCov%:{coverage}%",
                line_number=str(metadata['line']),
                file_path=str(metadata['file']),
                reason=f"Meets or exceeds expected value {expected_threshold}%"
            )]
            
            info_groups = {
                "INFO01": {
                    "description": "DFT Transition Coverage",
                    "items": [detail.name for detail in details]
                }
            }
            
            return create_check_result(
                is_pass=True,
                value=coverage,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                info_groups=info_groups,
                item_desc=self.item_desc
            )
        elif coverage >= waiver_minimum:
            # WAIVED - below expected but above waiver minimum
            details = [DetailItem(
                severity=Severity.WAIVE,
                name=f"ATCov%:{coverage}%",
                line_number=str(metadata['line']),
                file_path=str(metadata['file']),
                reason=f"Below expected {expected_threshold}% but above waiver minimum {waiver_minimum}%"
            )]
            
            waive_groups = {
                "WAIVE01": {
                    "description": "DFT Transition coverage waived",
                    "items": [f"ATCov%:{coverage}%"]
                }
            }
            
            return create_check_result(
                is_pass=True,
                value=coverage,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                waive_groups=waive_groups,
                item_desc=self.item_desc
            )
        else:
            # FAIL - below waiver minimum
            details = [DetailItem(
                severity=Severity.FAIL,
                name=f"ATCov%:{coverage}%",
                line_number=str(metadata['line']),
                file_path=str(metadata['file']),
                reason=f"Below waiver minimum {waiver_minimum}%"
            )]
            
            error_groups = {
                "ERROR01": {
                    "description": "DFT Transition coverage below waiver minimum",
                    "items": [f"ATCov%:{coverage}%"]
                }
            }
            
            return create_check_result(
                is_pass=False,
                value=coverage,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                error_groups=error_groups,
                item_desc=self.item_desc
            )


def run():
    """Execute the DFT Transition coverage checker."""
    checker = DFTTransitionChecker()
    checker.init_checker(script_path=Path(__file__))
    result = checker.execute_check()
    checker.write_output(result)


if __name__ == '__main__':
    run()
