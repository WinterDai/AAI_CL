# -*- coding: utf-8 -*-
"""
SynthesisTimingModelChecker.py - Checker Implementation for IMP-5-0-0-00

Description:
    Confirm synthesis is using lib models for timing?

Author: CodeGen Agent
Created: 2026-01-06
Version: v1.0.0

This file was auto-generated by CodeGen Agent.
Manual modifications may be overwritten on regeneration.
"""


from pathlib import Path
import gzip
import re
import sys
from typing import List, Dict, Tuple, Optional, Any


# Add common module to path
_SCRIPT_DIR = Path(__file__).resolve().parent
_CHECK_MODULES_DIR = _SCRIPT_DIR.parents[2]  # Go up to Check_modules/
_COMMON_DIR = _CHECK_MODULES_DIR / 'common'
if str(_COMMON_DIR) not in sys.path:
    sys.path.insert(0, str(_COMMON_DIR))

# Framework imports
from base_checker import BaseChecker, CheckResult, ConfigurationError
from output_formatter import DetailItem, Severity, create_check_result
from checker_templates.waiver_handler_template import WaiverHandlerMixin
from checker_templates.output_builder_template import OutputBuilderMixin

from checker_templates.input_file_parser_template import InputFileParserMixin


# MANDATORY: Inherit mixins in correct order (InputFileParserMixin first if used)
class SynthesisTimingModelChecker(InputFileParserMixin, OutputBuilderMixin, WaiverHandlerMixin, BaseChecker):
    """
    IMP-5-0-0-00: Confirm synthesis is using lib models for timing?
    
    Checking Types:
    - Type 1: requirements=N/A, pattern_items [], waivers=N/A/0 → Boolean Check
    - Type 2: requirements>0, pattern_items [...], waivers=N/A/0 → Value Check
    - Type 3: requirements>0, pattern_items [...], waivers>0 → Value Check with Waiver Logic
    - Type 4: requirements=N/A, pattern_items [], waivers>0 → Boolean Check with Waiver Logic
    
    Template Library v1.1.0:
    - Uses InputFileParserMixin for parsing (parse_log_with_patterns, normalize_command)
    - Uses WaiverHandlerMixin for waiver processing (parse_waive_items, match_waiver_entry)
    - Uses OutputBuilderMixin for result construction (build_complete_output)
    """
    
    # =========================================================================
    # UNIFIED DESCRIPTIONS - Class-level constants (LLM-Generated)
    # =========================================================================
    FOUND_DESC = "Library-based timing models confirmed in synthesis"
    MISSING_DESC = "Wireload models detected or library timing models not confirmed"
    EXTRA_DESC = "Additional timing model configuration details"
    FOUND_REASON = "Technology libraries with CCS/NLDM timing models found in QoR report"
    MISSING_REASON = "Wireload model references found or library model indicators absent in QoR report"
    WAIVED_REASON = "Library timing model check waived"
    
    def __init__(self):
        """Initialize the checker."""
        super().__init__(
            check_module="5.0_SYNTHESIS_CHECK",
            item_id="IMP-5-0-0-00",
            item_desc="Confirm synthesis is using lib models for timing?"
        )
        # MANDATORY: Metadata tracking for debug (Golden pattern)
        # Used by helper methods to track line numbers for DetailItem
        self._metadata: Dict[str, Dict[str, Any]] = {}
        # Store parsed data
        self._parsed_items: List[Dict] = []
    
    # =========================================================================
    # Main Check Execution (Template - Fixed, v2.1 Golden-Aligned)
    # =========================================================================
    
    def execute_check(self) -> CheckResult:
        """
        Execute check with automatic type detection and delegation.
        
        v2.1: Aligned with Golden design pattern:
        1. Parse input files first via _parse_input_files()
        2. Pass parsed data to _execute_typeN(parsed_data)
        
        Returns:
            CheckResult based on detected checker type
        """
        try:
            if self.root is None:
                raise RuntimeError("Checker not initialized. Call init_checker() first.")
            
            # Parse input files first (Golden pattern)
            parsed_data = self._parse_input_files()
            
            # Detect checker type (use BaseChecker method)
            checker_type = self.detect_checker_type()
            
            # Execute based on type, passing parsed data
            if checker_type == 1:
                return self._execute_type1(parsed_data)
            elif checker_type == 2:
                return self._execute_type2(parsed_data)
            elif checker_type == 3:
                return self._execute_type3(parsed_data)
            else:  # checker_type == 4
                return self._execute_type4(parsed_data)
        except ConfigurationError as e:
            return e.check_result
    
    # =========================================================================
    # Input Parsing (LLM-Generated)
    # =========================================================================
    
    def _parse_input_files(self) -> Dict[str, Any]:
        """
        Parse QoR report to extract timing model configuration.
        
        Layer 1: Parsing layer - shared by all 4 Types, called only once
        
        Returns:
            Dict with keys:
            - timing_model_info: Dict with timing model configuration
            - library_info: Dict with technology library details
            - errors: List of error messages
        """
        # Initialize metadata storage
        self._metadata = {}
        
        # Validate input files
        valid_files, missing_files = self.validate_input_files()
        if not valid_files:
            return {
                'timing_model_info': {},
                'library_info': {},
                'errors': ['No valid QoR report files found']
            }
        
        # Parse QoR report
        qor_report_path = valid_files[0]  # Expect single QoR report
        qor_data = self._parse_qor_report(qor_report_path)
        
        timing_model_info = qor_data.get('timing_model_info', {})
        library_info = qor_data.get('library_info', {})
        errors = qor_data.get('errors', [])
        
        return {
            'timing_model_info': timing_model_info,
            'library_info': library_info,
            'errors': errors
        }
    
    # =========================================================================
    # Type 1: Boolean Check (LLM-Generated)
    # =========================================================================
    
    def _execute_type1(self, parsed_data: Dict[str, Any]) -> CheckResult:
        """
        Type 1: Boolean check - verify library-based timing models are used
        
        Layer 3: Execution layer - calls framework method
        Architecture: Boolean Logic + no Waiver
        Pass Condition: CCS/NLDM indicators found AND no wireload model references
        Fail Condition: Wireload model found OR no library model indicators
        """
        def parse_data():
            """Call shared Boolean Check Logic"""
            return self._boolean_check_logic(parsed_data)
        
        return self.execute_boolean_check(
            parse_data_func=parse_data,
            has_waiver=False,
            found_desc=self.FOUND_DESC,
            missing_desc=self.MISSING_DESC,
            extra_desc=self.EXTRA_DESC,
            name_extractor=self._build_name_extractor()
        )
    
    # =========================================================================
    # Type 2: Value Check (LLM-Generated)
    # =========================================================================
    
    def _execute_type2(self, parsed_data: Dict[str, Any]) -> CheckResult:
        """
        Type 2: Value check - match library model indicators from pattern_items
        
        Layer 3: Execution layer - calls framework method
        Architecture: Pattern Logic + no Waiver
        Pass Condition: Pattern items (lib model indicators) found in libraries
        Fail Condition: Pattern items not found
        """
        def parse_data():
            """Call shared Pattern Check Logic"""
            return self._pattern_check_logic(parsed_data)
        
        return self.execute_value_check(
            parse_data_func=parse_data,
            has_waiver=False,
            found_desc="Library timing model indicators found",
            missing_desc="Library timing model indicators not found",
            extra_desc=self.EXTRA_DESC,
            name_extractor=self._build_name_extractor()
        )
    
    # =========================================================================
    # Type 3: Value Check with Waiver Logic (LLM-Generated)
    # =========================================================================
    
    def _execute_type3(self, parsed_data: Dict[str, Any]) -> CheckResult:
        """
        Type 3: Value check with waiver - match library model indicators with waiver support
        
        Layer 3: Execution layer - calls framework method
        Architecture: Pattern Logic (reuse Type2) + Waiver filtering
        Pass Condition: Pattern items found or waived
        Fail Condition: Pattern items not found and not waived
        """
        # Prepare info_items for display
        timing_model_info = parsed_data.get('timing_model_info', {})
        library_info = parsed_data.get('library_info', {})
        info_items = {}
        
        # Add synthesis tool info as informational item
        if timing_model_info.get('tool_name'):
            tool_metadata = self._metadata.get('tool_info', {})
            info_items[f"Synthesis Tool: {timing_model_info['tool_name']}"] = {
                'line_number': tool_metadata.get('line_number', 0),
                'file_path': tool_metadata.get('file_path', ''),
                'reason': f"Version: {timing_model_info.get('tool_version', 'Unknown')}"
            }
        
        # Add library domain info
        if library_info.get('domain_name'):
            domain_metadata = self._metadata.get('library_domain', {})
            info_items[f"Library Domain: {library_info['domain_name']}"] = {
                'line_number': domain_metadata.get('line_number', 0),
                'file_path': domain_metadata.get('file_path', ''),
                'reason': 'Operating conditions for timing analysis'
            }
        
        def parse_data():
            """Call shared Pattern Check Logic (same as Type2)"""
            return self._pattern_check_logic(parsed_data)
        
        return self.execute_value_check(
            parse_data_func=parse_data,
            has_waiver=True,  # Type3 specific: enable waiver handling
            info_items=info_items,
            found_desc="Library timing model indicators found",
            missing_desc="Library timing model indicators not found",
            extra_desc=self.EXTRA_DESC,
            extra_severity=Severity.FAIL,
            name_extractor=self._build_name_extractor()
        )
    
    # =========================================================================
    # Type 4: Boolean Check with Waiver Logic (LLM-Generated)
    # =========================================================================
    
    def _execute_type4(self, parsed_data: Dict[str, Any]) -> CheckResult:
        """
        Type 4: Boolean check with waiver - verify library models with waiver support
        
        Layer 3: Execution layer - calls framework method
        Architecture: Boolean Logic (reuse Type1) + Waiver filtering
        Pass Condition: Library models confirmed or waived
        Fail Condition: Wireload models found and not waived
        """
        def parse_data():
            """Call shared Boolean Check Logic (same as Type1)"""
            return self._boolean_check_logic(parsed_data)
        
        return self.execute_boolean_check(
            parse_data_func=parse_data,
            has_waiver=True,  # Type4 specific: enable waiver handling
            found_desc=self.FOUND_DESC,
            missing_desc=self.MISSING_DESC,
            extra_desc=self.EXTRA_DESC,
            name_extractor=self._build_name_extractor()
        )

    # =========================================================================
    # Helper Methods (LLM-Generated)
    # =========================================================================
    
    def _build_name_extractor(self):
        """Return name_extractor function for formatting output names"""
        def extract_name(name: str, metadata: Any) -> str:
            if isinstance(metadata, dict):
                library_count = metadata.get('library_count', '')
                model_type = metadata.get('model_type', '')
                wireload_name = metadata.get('wireload_name', '')
                reason = metadata.get('reason', '')
                
                if library_count:
                    return f"{name} ({library_count} libraries with CCS/NLDM models)"
                elif model_type:
                    return f"{name}: {model_type}"
                elif wireload_name:
                    return f"{name}: {wireload_name}"
                elif reason:
                    return f"{name}: {reason}"
            return name
        return extract_name

    def _boolean_check_logic(self, parsed_data: Dict[str, Any]) -> tuple:
        """
        Boolean Check Logic (Type1/4 shared)
        
        Layer 2: Logic layer - core business logic
        Core Business Logic: Check if library-based timing models are used (existence check)
        
        Returns:
            tuple: (found_items, missing_items, extra_items) - all are Dict
        """
        timing_model_info = parsed_data.get('timing_model_info', {})
        library_info = parsed_data.get('library_info', {})
        errors = parsed_data.get('errors', [])
        
        found_items = {}
        missing_items = {}
        extra_items = {}
        
        # Check for library-based timing models (CCS/NLDM indicators)
        has_lib_models = library_info.get('has_ccs_models', False)
        library_count = library_info.get('library_count', 0)
        
        if has_lib_models and library_count > 0:
            metadata = self._metadata.get('technology_libraries', {})
            found_items["Library-based Timing Models"] = {
                'line_number': metadata.get('line_number', 0),
                'file_path': metadata.get('file_path', ''),
                'library_count': library_count,
                'reason': f"Found {library_count} technology libraries with CCS/NLDM timing models"
            }
        else:
            missing_items["Library-based Timing Models"] = {
                'reason': "No CCS/NLDM timing model indicators found in technology libraries"
            }
        
        # Check for wireload model usage (failure condition)
        wireload_model = timing_model_info.get('wireload_model')
        if wireload_model and wireload_model.lower() not in ['none', 'n/a', '']:
            metadata = self._metadata.get('wireload_model', {})
            missing_items["Wireload Model Detected"] = {
                'line_number': metadata.get('line_number', 0),
                'file_path': metadata.get('file_path', ''),
                'wireload_name': wireload_model,
                'reason': f"Wireload model '{wireload_model}' is being used instead of library models"
            }
        
        # Check timing model type if explicitly stated
        timing_model_type = timing_model_info.get('timing_model_type')
        if timing_model_type:
            metadata = self._metadata.get('timing_model_type', {})
            if timing_model_type.lower() == 'lib':
                found_items["Timing Model Type"] = {
                    'line_number': metadata.get('line_number', 0),
                    'file_path': metadata.get('file_path', ''),
                    'model_type': timing_model_type,
                    'reason': "Timing model type explicitly set to 'lib'"
                }
            else:
                extra_items[f"Timing Model Type: {timing_model_type}"] = {
                    'line_number': metadata.get('line_number', 0),
                    'file_path': metadata.get('file_path', ''),
                    'reason': f"Unexpected timing model type: {timing_model_type}"
                }
        
        # Add errors as extra items
        for error in errors:
            extra_items[f"Error: {error}"] = {
                'reason': 'Parsing or configuration issue'
            }
        
        return found_items, missing_items, extra_items

    def _pattern_check_logic(self, parsed_data: Dict[str, Any]) -> tuple:
        """
        Pattern Check Logic (Type2/3 shared)
        
        Layer 2: Logic layer - core business logic
        Core Business Logic: Match library model indicators from pattern_items
        
        Returns:
            tuple: (found_items, missing_items, extra_items) - all are Dict
        """
        timing_model_info = parsed_data.get('timing_model_info', {})
        library_info = parsed_data.get('library_info', {})
        errors = parsed_data.get('errors', [])
        
        # Get pattern_items from requirements
        requirements = self.item_data.get('requirements', {})
        pattern_items = requirements.get('pattern_items', [])
        
        found_items = {}
        missing_items = {}
        extra_items = {}
        
        # Collect all content to search
        all_content = []
        
        # Add tool information
        if timing_model_info.get('tool_name'):
            all_content.append(timing_model_info['tool_name'])
        if timing_model_info.get('tool_version'):
            all_content.append(f"Genus(TM) Synthesis Solution {timing_model_info['tool_version']}")
        
        # Add library information
        if library_info.get('domain_name'):
            all_content.append(f"Library domain: {library_info['domain_name']}")
        
        # Add technology libraries content
        tech_libraries = library_info.get('libraries', [])
        for lib in tech_libraries:
            all_content.append(lib)
        
        # Add timing model type
        if timing_model_info.get('timing_model_type'):
            all_content.append(f"Timing Model: {timing_model_info['timing_model_type']}")
        
        # Add wireload model info
        if timing_model_info.get('wireload_model'):
            all_content.append(f"Wireload Model: {timing_model_info['wireload_model']}")
        
        # Match patterns
        matched_patterns = set()
        for pattern in pattern_items:
            found = False
            matched_content = None
            
            for content in all_content:
                if self._match_pattern(content, [pattern]):
                    found = True
                    matched_content = content
                    break
            
            if found:
                matched_patterns.add(pattern)
                # Determine metadata source based on pattern content
                if 'ccs' in pattern.lower() or 'nldm' in pattern.lower() or 'library' in pattern.lower():
                    metadata = self._metadata.get('technology_libraries', {})
                elif 'timing model' in pattern.lower():
                    metadata = self._metadata.get('timing_model_type', {})
                else:
                    metadata = self._metadata.get('tool_info', {})
                
                found_items[pattern] = {
                    'line_number': metadata.get('line_number', 0),
                    'file_path': metadata.get('file_path', ''),
                    'matched': matched_content
                }
        
        # Find unmatched patterns
        for pattern in pattern_items:
            if pattern not in matched_patterns:
                missing_items[pattern] = {
                    'reason': 'Required pattern not found in QoR report'
                }
        
        # Check for wireload model as extra item (warning in pattern check)
        wireload_model = timing_model_info.get('wireload_model')
        if wireload_model and wireload_model.lower() not in ['none', 'n/a', '']:
            metadata = self._metadata.get('wireload_model', {})
            extra_items["Wireload Model Detected"] = {
                'line_number': metadata.get('line_number', 0),
                'file_path': metadata.get('file_path', ''),
                'reason': f"Wireload model '{wireload_model}' found (should use library models)"
            }
        
        # Add errors as extra items
        for error in errors:
            extra_items[f"Error: {error}"] = {
                'reason': 'Parsing or configuration issue'
            }
        
        return found_items, missing_items, extra_items

    def _parse_qor_report(self, qor_report_path: Path) -> Dict[str, Any]:
        """
        Parse QoR report to extract timing model configuration.
        
        Returns:
            Dict with keys:
            - timing_model_info: Dict with timing model configuration
            - library_info: Dict with technology library details
            - errors: List of error messages
        """
        timing_model_info = {}
        library_info = {}
        errors = []
        
        try:
            with open(qor_report_path, 'r', errors='ignore') as f:
                lines = f.readlines()
                
                in_tech_libraries_section = False
                tech_libraries = []
                
                for line_num, line in enumerate(lines, 1):
                    line_stripped = line.strip()
                    
                    # Extract synthesis tool name
                    if 'Generated by:' in line:
                        match = re.search(r'Generated by:\s+([^\n]+)', line)
                        if match:
                            timing_model_info['tool_name'] = match.group(1).strip()
                            self._metadata['tool_info'] = {
                                'line_number': line_num,
                                'file_path': str(qor_report_path)
                            }
                            
                            # Extract tool version
                            version_match = re.search(r'Genus\(TM\) Synthesis Solution\s+([\d._a-z]+)', line)
                            if version_match:
                                timing_model_info['tool_version'] = version_match.group(1)
                    
                    # Extract generation timestamp
                    elif 'Generated on:' in line:
                        match = re.search(r'Generated on:\s+([^\n]+)', line)
                        if match:
                            timing_model_info['generation_timestamp'] = match.group(1).strip()
                    
                    # Extract top module name
                    elif 'Module:' in line:
                        match = re.search(r'Module:\s+(\S+)', line)
                        if match:
                            timing_model_info['top_module'] = match.group(1)
                    
                    # Extract library domain
                    elif 'Library domain:' in line:
                        match = re.search(r'Library domain:\s+([^\n]+)', line)
                        if match:
                            library_info['domain_name'] = match.group(1).strip()
                            self._metadata['library_domain'] = {
                                'line_number': line_num,
                                'file_path': str(qor_report_path)
                            }
                    
                    # Extract technology libraries section
                    elif 'Technology libraries:' in line:
                        in_tech_libraries_section = True
                        self._metadata['technology_libraries'] = {
                            'line_number': line_num,
                            'file_path': str(qor_report_path)
                        }
                        # Extract first library on same line if present
                        remainder = line.split('Technology libraries:', 1)[1].strip()
                        if remainder:
                            tech_libraries.append(remainder)
                        continue
                    
                    # Collect technology library entries
                    if in_tech_libraries_section:
                        # End of section detection (empty line or new section)
                        if not line_stripped or ':' in line_stripped and not line_stripped.startswith('tcbn'):
                            in_tech_libraries_section = False
                        else:
                            tech_libraries.append(line_stripped)
                    
                    # Extract timing model type (if explicitly stated)
                    elif 'Timing Model:' in line:
                        match = re.search(r'Timing Model:\s+(\S+)', line)
                        if match:
                            timing_model_info['timing_model_type'] = match.group(1)
                            self._metadata['timing_model_type'] = {
                                'line_number': line_num,
                                'file_path': str(qor_report_path)
                            }
                    
                    # Extract wireload model (failure indicator)
                    elif 'Wireload Model:' in line:
                        match = re.search(r'Wireload Model:\s+(\S+)', line)
                        if match:
                            wireload_name = match.group(1)
                            if wireload_name.lower() not in ['none', 'n/a']:
                                timing_model_info['wireload_model'] = wireload_name
                                self._metadata['wireload_model'] = {
                                    'line_number': line_num,
                                    'file_path': str(qor_report_path)
                                }
                    
                    # Extract operating conditions
                    elif 'Operating Conditions:' in line:
                        match = re.search(r'Operating Conditions:\s+([^\n]+)', line)
                        if match:
                            timing_model_info['operating_conditions'] = match.group(1).strip()
                
                # Process technology libraries
                if tech_libraries:
                    library_info['libraries'] = tech_libraries
                    library_info['library_count'] = len(tech_libraries)
                    
                    # Check for CCS/NLDM indicators
                    has_ccs = any('_ccs' in lib.lower() for lib in tech_libraries)
                    has_nldm = any('_nldm' in lib.lower() for lib in tech_libraries)
                    library_info['has_ccs_models'] = has_ccs or has_nldm
                else:
                    errors.append("No technology libraries found in QoR report")
        
        except Exception as e:
            errors.append(f"Failed to parse QoR report: {str(e)}")
        
        return {
            'timing_model_info': timing_model_info,
            'library_info': library_info,
            'errors': errors
        }

    def _match_pattern(self, text: str, patterns: List[str]) -> bool:
        """
        Check if text matches any of the given patterns.
        
        Args:
            text: Text to search in
            patterns: List of patterns to match
        
        Returns:
            bool: True if any pattern matches
        """
        for pattern in patterns:
            # Try exact substring match first
            if pattern.lower() in text.lower():
                return True
            
            # Try regex match
            try:
                if re.search(pattern, text, re.IGNORECASE):
                    return True
            except re.error:
                # Invalid regex, skip
                pass
        
        return False


# ============================================================================
# Entry Point (Template - Fixed, Golden-Aligned)
# ============================================================================

def init_checker() -> SynthesisTimingModelChecker:
    """Initialize and return the checker instance."""
    checker = SynthesisTimingModelChecker()
    checker.init_checker()
    return checker


if __name__ == '__main__':
    checker = init_checker()
    result = checker.execute_check()
    checker.write_output(result)
