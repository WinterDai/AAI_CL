<section4>
## 4. Implementation Guide

### 4.1 Item-Specific Implementation Points

**Data Source Inference**:
- Inferred data source: Static Timing Analysis (STA) log files
- Recommended file: `sta_post_syn.log`, `sta_post_pnr.log`, or similar timing analysis logs
- Rationale: STA tools typically log file loading operations and version information when reading netlist and SPEF files

**Information Extraction Methods**:

- **Netlist Loading Status and Version**:
  - **Primary source**: STA log file sections containing netlist reading operations
  - **Keywords to search**: 
    - Loading indicators: `"Reading netlist"`, `"Loading netlist"`, `"Netlist file"`, `"read_verilog"`, `"read_hdl"`
    - Success indicators: `"successfully"`, `"completed"`, `"loaded"`, `"OK"`
    - Failure indicators: `"failed"`, `"error"`, `"not found"`, `"cannot open"`
  - **Version extraction**: 
    - Look for generator comments in netlist file headers (if accessible): `"// Generator:"`, `"// Tool:"`, `"/* Created by"`, `"# Generated by"`
    - Common patterns: `"Genus"`, `"Innovus"`, `"DC Compiler"`, `"RTL Compiler"` followed by version numbers
    - Date patterns: `YYYY-MM-DD`, `DD-MMM-YYYY`, timestamps in ISO format

- **SPEF Loading Status and Version**:
  - **Primary source**: STA log file sections containing SPEF reading operations
  - **Keywords to search**:
    - Loading indicators: `"Reading SPEF"`, `"Loading SPEF"`, `"read_spef"`, `"SPEF file"`, `"Parasitic file"`
    - Success indicators: Same as netlist
    - Failure indicators: Same as netlist
  - **Version extraction**:
    - SPEF file headers (if accessible): `"*SPEF"`, `"*DESIGN"`, `"*DATE"`, `"*VENDOR"`, `"*PROGRAM"`
    - Standard version: `"IEEE 1481-1999"`, `"IEEE 1481-2009"`
    - Generator info: Tool name and version in SPEF comments

**Adaptive Learning Strategy**:
- Do not assume fixed formats; learn from actual file content
  - Different STA tools (PrimeTime, Tempus, ETS) use different log formats
  - Netlist generators (Genus, Innovus, DC) have varying comment styles
  - SPEF formats may include vendor-specific extensions
- Fallback handling:
  - If STA log not found, attempt to read netlist/SPEF files directly for version headers
  - If file loading status cannot be determined from logs, check file existence on filesystem
  - If version information incomplete, mark specific missing fields (e.g., missing date but has tool name)
- Error tolerance:
  - Partial matches are acceptable (e.g., tool name found but version missing → mark as incomplete)
  - Multiple file references in logs → extract all and let Check Logic validate
  - Malformed version strings → preserve original text in `matched_content` for debugging

**Multi-Stage Extraction Pattern**:
1. **Stage 1**: Parse STA log to find file paths and loading status
2. **Stage 2**: If version info not in log, use extracted file paths to read actual netlist/SPEF headers
3. **Stage 3**: Normalize extracted data into structured format with metadata

### 4.2 Special Scenario Handling

#### Scenario 1: SPEF Unavailable During Synthesis Stage
- **Context**: In synthesis flow, SPEF files are not yet generated (require place-and-route completion)
- **Check result**: 
  - SPEF loading status → `missing_items` (Item 2.2 fails)
  - SPEF version completeness → `missing_items` (Item 2.4 fails)
  - Netlist items may still pass
- **Waiver handling**: 
  - If `waive_items` contains keywords: `"synthesis"`, `"SPEF"`, `"pre-layout"`, `"syn stage"`
  - Apply waiver to Items 2.2 and 2.4 → move to `waived` field
  - Final status: PASS (if netlist items pass and SPEF items waived)
- **Implementation note**: Check Logic should clearly separate netlist vs SPEF failures for targeted waiving

#### Scenario 2: Golden Netlist with Historical Timestamps
- **Context**: Using archived "golden" netlists from previous tapeouts for regression testing
- **Check result**:
  - Netlist loading status → PASS (file loads successfully)
  - Netlist version completeness → FAIL if timestamp doesn't match current year/date
  - Pattern matching against `requirements.pattern_items` (e.g., `"2025"`) → `missing_items`
- **Waiver handling**:
  - If `waive_items` contains: `"golden"`, `"historical"`, `"archive"`, `"2024"`, `"2023"` (old years)
  - Apply waiver to timestamp mismatch → move to `waived`
  - Preserve tool name/version validation (should still match requirements)
- **Implementation note**: Consider separating timestamp validation from tool/version validation for granular waiving

#### Scenario 3: Multiple Netlist/SPEF Files Loaded
- **Context**: Hierarchical designs may load multiple netlist files or SPEF files for different blocks
- **Check result**:
  - Parsing Logic extracts multiple entries (one per file)
  - Check Logic validates each entry independently
  - If any file missing version info → partial failure
  - `extra_items` may appear if more files loaded than expected
- **Waiver handling**:
  - If `waive_items` contains specific block names: `"block_A"`, `"test_module_*"`, `"*_wrapper"`
  - Apply waiver to specific blocks' version issues
  - Use wildcard patterns to waive entire categories (e.g., `"test_*"` for all test modules)
- **Implementation note**: Ensure `source_file` metadata clearly identifies which file each validation result corresponds to

#### Scenario 4: Compressed or Encrypted Netlist Files
- **Context**: Netlist files may be gzipped (`.v.gz`) or encrypted (vendor IP)
- **Check result**:
  - STA log shows successful loading, but direct file access for version extraction may fail
  - Parsing Logic should rely on log messages rather than direct file reading
  - If version info only available in file headers → may be incomplete
- **Waiver handling**:
  - If `waive_items` contains: `"encrypted"`, `"IP block"`, `"vendor"`, `"*.gz"`
  - Apply waiver to version completeness checks for these files
  - Loading status should still pass (STA tool can read them)
- **Implementation note**: Prioritize log-based extraction over direct file parsing for robustness

### 4.3 Test Data Generation Guidance

**Note**: The following guidance is for generating test configurations covering all 6 test scenarios.

#### Test Scenario Matrix

Based on requirements.value and waivers.value combinations, generate 6 test scenarios:

| Scenario | requirements.value | waivers.value | Test Objective |
|----------|-------------------|---------------|----------------|
| 1 | N/A | N/A | Basic existence validation |
| 2 | N/A | 0 | Global waiver mechanism |
| 3 | N/A | >0 | Selective waiver matching mechanism |
| 4 | >0 | N/A | Pattern matching - PASS path |
| 5 | >0 | 0 | Pattern matching - FAIL path + global waiver |
| 6 | >0 | >0 | Pattern matching - FAIL path + selective waiver |

#### Inference Strategy

**Step 1: Run Parsing Logic to obtain actual metadata**

After Parsing Logic execution, analyze the actual output structure and content. Expected fields:
- `parsed_fields.netlist.tool_name` (e.g., "Genus", "Innovus", "DC Compiler")
- `parsed_fields.netlist.version` (e.g., "21.1", "19.12-s090_1")
- `parsed_fields.netlist.date` (e.g., "2025-01-05", "05-Jan-2025")
- `parsed_fields.spef.generator_info` (e.g., "Innovus 21.1", "StarRC 2024.06")
- `parsed_fields.spef.date` (e.g., "2025-01-05")

**Step 2: Extract representative keywords**

From the `value` field of parsed objects, extract characteristic keywords:
- **Timestamps**: Year patterns like `"2025"`, `"2024"`, month patterns like `"Jan"`, `"January"`
- **Tool names**: `"Genus"`, `"Innovus"`, `"DC"`, `"RTL Compiler"`, `"PrimeTime"`, `"StarRC"`
- **Version numbers**: Major versions like `"21"`, `"19"`, `"2024"`, full versions like `"21.1"`
- **Status indicators**: `"Success"`, `"Loaded"`, `"Complete"`
- **File types**: `"netlist"`, `"SPEF"`, `"verilog"`, `"parasitic"`

**Step 3: Generate test YAML configurations**

```yaml
# Scenario 1: Basic existence check
# IMP-10-0-0-00_base.yaml
requirements:
  value: N/A
  pattern_items: []
waivers:
  value: N/A
  waive_items: []

# Scenario 2: Global waiver
# IMP-10-0-0-00_global_waiver.yaml
requirements:
  value: N/A
  pattern_items: []
waivers:
  value: 0
  waive_items: ["All netlist/SPEF version checks waived for legacy design"]

# Scenario 3: Selective waiver
# IMP-10-0-0-00_selective_waiver.yaml
requirements:
  value: N/A
  pattern_items: []
waivers:
  value: 2
  waive_items:
    - "SPEF"           # Waive all SPEF-related failures
    - "synthesis"      # Waive failures in synthesis stage

# Scenario 4: Pattern matching - PASS
# IMP-10-0-0-00_pattern_pass.yaml
requirements:
  value: 2  # Two items require pattern matching: netlist version (2.2) and SPEF version (2.4)
  pattern_items:
    - "2025|Genus|Innovus"     # Netlist version: match year OR tool names
    - "2025|StarRC|Innovus"    # SPEF version: match year OR generator tools
waivers:
  value: N/A
  waive_items: []

# Scenario 5: Pattern matching - FAIL + global waiver
# IMP-10-0-0-00_pattern_fail_global.yaml
requirements:
  value: 2
  pattern_items:
    - "2026"           # Future year - will not match current data
    - "2026"           # Future year - will not match current data
waivers:
  value: 0
  waive_items: ["Using historical netlist/SPEF from previous tapeout"]

# Scenario 6: Pattern matching - FAIL + selective waiver
# IMP-10-0-0-00_pattern_fail_selective.yaml
requirements:
  value: 2
  pattern_items:
    - "2026|FutureTool"        # Will not match - triggers missing_items
    - "2026|FutureTool"        # Will not match - triggers missing_items
waivers:
  value: 3
  waive_items:
    - "golden"                 # Waive historical netlist issues
    - "SPEF"                   # Waive SPEF version mismatches
    - "synthesis"              # Waive synthesis stage limitations
```

**Key Principles**:
1. **PASS scenarios**: Use patterns that match actual data values
   - Combine multiple alternatives with `|` for robustness (e.g., `"2025|Genus"` matches if either appears)
   - Include both temporal (year) and tool-specific keywords
2. **FAIL scenarios**: Use patterns that do NOT match actual data
   - Future years (`"2026"`) guaranteed to fail for current data
   - Non-existent tool names (`"FutureTool"`)
3. **OR relationships**: Connect multiple keywords with `|` for higher match probability
   - Example: `"2025|Genus|Innovus"` matches any of the three keywords
4. **waive_items**: Reference matching keywords defined in Section 3
   - Use domain-specific terms: `"synthesis"`, `"SPEF"`, `"golden"`, `"historical"`
   - Use wildcard patterns for flexibility: `"*_wrapper"`, `"test_*"`

**Important**: These are recommendations based on typical Parsing Logic output. Adjust according to actual metadata structure and content observed in your specific design flow.

</section4>