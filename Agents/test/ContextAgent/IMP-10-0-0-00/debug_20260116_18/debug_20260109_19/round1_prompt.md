<!-- ========================================
     USER PROMPT: ItemSpec Generation Guide
     (From user_prompt.md)
========================================= -->

# User Prompt - ItemSpec Generation Guide

---

## Task Overview

Generate a complete ItemSpec document by filling in the template based on:
- **Input**: Item description from YAML configuration
- **Reference**: global_rules.md for framework requirements
- **Output**: Completed ItemSpec with all TODO sections filled

---

## Input Structure

You will receive:

```yaml
description: "<Brief description of what to verify>"
requirements:
  value: N/A  # Will be determined during implementation
  pattern_items: []
input_files: []
waivers:
  value: N/A
  waive_items: []
```

### Placeholder Handling

When generating the ItemSpec:
- Replace `{ITEM_ID}` with the actual item identifier (e.g., "IMP-10-0-0-00")
- Replace `{DESCRIPTION}` with the description from the YAML input
- Replace all `{TODO: ...}` placeholders with your specific content
- Use EDA industry-standard terminology consistently

---

## Description Interpretation Patterns

**Critical**: Understand common description formats correctly:

### Pattern 1: Slash Notation (Multiple Objects)
- **Format**: "Confirm A/B/C is correct"
- **Meaning**: Validate **ALL** of A, B, and C (not alternatives)
- **Example**: "netlist/spef version" → validate **both** netlist version **AND** spef version
- **Rule**: Unless explicitly using "or", slash notation means "and all"

### Pattern 2: Explicit Alternatives
- **Format**: "Confirm A or B exists"
- **Meaning**: At least one must be present (true alternatives)
- **Example**: "DEF or LEF file exists" → check if **either** file is present

### Pattern 3: Optional Components
- **Format**: "Confirm A (optional: B) is correct"
- **Meaning**: A is mandatory, B may be waivable
- **Example**: "timing paths (optional: spef) verified" → paths required, spef may be waived

**Apply this understanding in your analysis and design all sections accordingly.**

---

## Output Requirements

Complete the ItemSpec template with:

### Section 1: Parsing Logic
Define **what information to extract** based on the description:
- Identify relevant data categories (e.g., version info, file status)
- List typical fields for each category
- Design parsed_fields structure
- Consider metadata requirements (file paths, timestamps, etc.)

**Guidelines**:
- Version information typically includes: tool name, version number, timestamp
- File status validation usually checks: existence, accessibility, loading success
- Structure should support downstream validation needs

### Section 2: Check Logic
Define **what to verify** based on the description:
- Determine validation items (2-6 items typical)
- Define completeness criteria for each item
- Decide which items require pattern matching vs. existence checks
- Specify pattern_items correspondence order

**Guidelines**:
- "Confirm X is correct" usually means: existence + completeness + (optionally) format validation
- Pattern matching is appropriate for: version numbers, timestamps, tool names
- Existence checks are appropriate for: file loading status, mandatory fields

### Section 3: Waiver Logic
Define **when failures are acceptable** based on engineering experience:
- Identify 2-4 common waiver scenarios
- Provide typical waiver reasons
- List matching keywords for selective waivers

**Guidelines**:
- Consider different design stages (synthesis may not need SPEF)
- Think about regression testing (historical golden files)
- Account for special file formats or legacy data
- Match keywords to business terminology

### Section 4: Implementation Guide
Provide **practical implementation guidance**:
- Infer likely data sources (log files, input files)
- Suggest common search keywords
- Recommend extraction strategies
- List special scenarios to handle

**Guidelines**:
- Version info is often in file headers or tool logs
- Look for keywords like: "Reading", "Loading", "Generated by", "Version"
- Consider fallback strategies if primary source unavailable

---

## Specific Instructions


<!-- ========================================
     TASK: Round 1 - Analysis
========================================= -->

<task>
Analyze the checker requirements and identify what information needs to be extracted.
</task>

<!-- ========================================
     CONFIGURATION: YAML Input
========================================= -->

<configuration>
```yaml
description: Confirm the netlist/spef version is correct.
requirements:
  value: N/A
  pattern_items: []
input_files: [1 file(s) configured]
waivers:
  value: N/A
  waive_items: []
```
</configuration>

<!-- ========================================
     INSTRUCTIONS: Analysis Steps
========================================= -->

<instructions>
Based on the description "Confirm the netlist/spef version is correct.", perform step-by-step analysis:

1. **Identify Key Entities**: What are the main subjects mentioned? (e.g., "netlist", "spef", "version")

2. **Determine Information Categories**: What types of information validate "correctness"?
   - File loading status?
   - Version information?
   - Format validation?
   - Other domain-specific data?

3. **List Required Fields**: For each category, what specific fields are needed?
   - Example: Version info needs → tool_name, version_number, timestamp

4. **Design Data Structure**: How should parsed_fields be organized?
   - Group by file type or by validation aspect?
   - What metadata is needed (source_file, line_number, etc.)?

5. **Identify Validation Items**: Based on the information categories, what needs to be validated? (typically 2-6 items)

6. **Determine Pattern Matching Needs**: Which validation items require pattern matching vs. existence checks?

7. **Consider Waiver Scenarios**: When might this check legitimately fail?
   - Different design stages?
   - Legacy data?
   - Special circumstances?

Think step-by-step and be specific. Output your analysis inside <analysis></analysis> tags.
</instructions>