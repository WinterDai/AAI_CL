Vibe Coding 落地实施指南：Architecture 10.2 (Final Locked)
目标：构建一个工业级 Developer Agent，实现从“自然语言日志意图”到“通过 Gate 认证的 Python Atom 代码”的端到端自动化。 核心原则：用户体验是随意的 (Vibe)，但执行逻辑是严苛的 (Deterministic)。

--------------------------------------------------------------------------------
1. 架构核心：LangGraph 状态机
为了实现 "Code -> Validate -> Fix" 的闭环，必须使用 LangGraph 来强制执行状态流转。
1.1 定义共享状态 (State Schema)
这是 Agent 的“短期记忆”，必须包含代码、契约和错误日志。
from typing import TypedDict, List, Optional

class DeveloperState(TypedDict):
    user_intent: str          # 用户的原始需求 (e.g., "Extract Error Code 500")
    log_snippet: str          # 用户提供的日志样本
    generated_code: str       # Agent 生成的 Python 源码 (Mechanism)
    pseudo_contract: str      # Agent 生成的 ItemSpec YAML (Policy)
    validation_errors: List[str] # 沙箱运行后的报错信息
    iteration_count: int      # 当前重试次数 (Max: 3)
1.2 图谱逻辑 (The Graph Topology)
1. Draft Node (起草): 接收需求，生成代码和 YAML。
2. Validator Node (守门人): 调用 沙箱工具 进行 IO 检查、类型检查和逻辑验证。
3. Reflect Node (修复): 如果 validation_errors 非空，根据错误修改代码。
4. Fallback Logic (兜底): 如果 iteration_count > 3，输出预设的 "Safe Stub Code"（安全桩代码），防止系统崩溃。

--------------------------------------------------------------------------------
2. 上下文工程：System Prompt (Draft Node)
为了让 Agent 一次性写对，必须将 plan_v2.txt 中的硬锁 (Hard Locks) 注入到 Prompt 中。
# Role
You are a Senior EDA Tool Developer complying with "Hierarchical Checker Architecture 10.2".

# The 10.2 Hard Constraints (NON-NEGOTIABLE)

1. **IO Ban**: You interpret strings only. NO `open()`, `read()`, `print()`, or `import os` [Source 3, 9].
2. **Atom A (Extraction)**:
   - Signature: `extract_context(text: str, source_file: str) -> List[Dict]` [Source 6].
   - **Type Lock**: You MUST cast extracted values to string: `val = str(item.get('val'))` [Source 6].
   - Schema: Return list of dicts with keys: `value`, `source_file`, `line_number`, `matched_content`, `parsed_fields` [Source 9].
   - Standardization: You MUST include the standardized return structure defined in spec.

3. **Atom B (Logic)**:
   - Signature: `validate_logic(text, pattern, parsed_fields=None, default_match="contains", regex_mode="search")` [Source 6].
   - **Precedence Lock**: Alternatives (`|`) > Regex (`regex:`) > Wildcard (`*`) > Default [Source 6].
   - **Binding Constraint**: Inside the function, you MUST use `re.match` when `regex_mode=='match'` and `re.search` when `regex_mode=='search'`.
   - Return Schema: `{'is_match': bool, 'reason': str, 'kind': str}` [Source 7].

4. **Atom C (Existence)**:
   - Signature: `check_existence(items: List[Dict])` [Source 7].
   - Return Schema: `{'is_match': bool, 'reason': str, 'evidence': items}` [Source 7].

# Task
Generate TWO artifacts based on the user's log snippet:
1. **Python Code**: The stateless Atom functions.
2. **YAML Spec**: The `pattern` that drives the code (e.g., `pattern: "regex:^Error"`).

--------------------------------------------------------------------------------
3. 核心工具：Compliance Sandbox (Validator)
这是本指南相对于上一版最大的改进。我们将静态分析 (AST) 与动态执行 (Runtime) 结合，并在 Python 代码中实现验证逻辑。
请将此工具注册给 Agent (Validator Node)：
import ast
import re

def validate_10_2_compliance(code_str: str, yaml_str: str) -> dict:
    """
    Hybrid Validator: AST Static Check + Runtime Sandbox
    Returns: {"valid": bool, "errors": list}
    """
    errors = []

    # --- Level 1: AST Static Security Check (Source 9) ---
    # 严防死守 IO 操作
    try:
        tree = ast.parse(code_str)
        for node in ast.walk(tree):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                if node.func.id in ['open', 'read', 'write', 'print', 'eval']:
                    errors.append(f"CRITICAL: Forbidden IO function '{node.func.id}' detected.")
            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):
                for alias in node.names:
                    if alias.name in ['os', 'sys', 'subprocess']:
                        errors.append(f"CRITICAL: Forbidden import '{alias.name}' detected.")
    except SyntaxError as e:
        return {"valid": False, "errors": [f"Syntax Error: {e}"]}

    if errors: return {"valid": False, "errors": errors}

    # --- Level 2: Runtime Logic Sandbox ---
    # 在隔离环境中真正运行代码，验证 10.2 契约
    local_scope = {}
    try:
        exec(code_str, {}, local_scope) # DANGER: Only run LLM code in containerized env
        
        # [Test 1] Atom A: Type Lock & Schema (Source 6, 9)
        if 'extract_context' in local_scope:
            func = local_scope['extract_context']
            # 注入 Int 类型数据，强制测试 Agent 是否做了 str() 转换
            mock_result = func("Error 123", "test.log")
            if not isinstance(mock_result, list):
                errors.append("Atom A Error: Must return a List.")
            elif len(mock_result) > 0:
                item = mock_result
                if not isinstance(item.get('value'), str):
                    errors.append(f"Atom A Violation: 'value' field is {type(item.get('value'))}, MUST be str.")
                if 'parsed_fields' not in item:
                    errors.append("Atom A Violation: Missing 'parsed_fields' key.")

        # [Test 2] Atom B: Precedence & Binding (Source 4, 6)
        if 'validate_logic' in local_scope:
            func = local_scope['validate_logic']
            # Test: Regex Mode Binding
            res = func("abc", "regex:^a", regex_mode="match")
            if not res['is_match']: errors.append("Atom B Error: regex_mode='match' failed to match prefix.")
            
            # Test: Precedence (Literal Pipe vs Regex Pipe)
            res_pipe = func("a|b", "a|b") # Should be exact match/alternative logic, NOT regex
            if not res_pipe['is_match']: errors.append("Atom B Error: Alternative logic ('|') failed.")

        # [Test 3] Atom C: Passthrough (Source 7, 9)
        if 'check_existence' in local_scope:
            func = local_scope['check_existence']
            evidence = [{'val': 1}]
            res = func(evidence)
            if res.get('evidence') != evidence:
                errors.append("Atom C Error: Failed to pass through 'evidence' list.")

    except Exception as e:
        errors.append(f"Runtime Crash: {str(e)}")

    # --- Level 3: Twin Artifact Consistency ---
    # 检查 YAML 中的 pattern 类型是否与代码逻辑一致
    if "regex:" in yaml_str and "regex" not in code_str:
         errors.append("Consistency Error: YAML specifies regex, but python code lacks regex logic.")

    return {"valid": len(errors) == 0, "errors": errors}

--------------------------------------------------------------------------------
4. 落地步骤总结
1. 初始化 LangGraph: 按照第 1 节定义的 DeveloperState 建立图。
2. 加载 System Prompt: 将第 2 节的 Prompt 填入 Draft Node 和 Reflect Node。
3. 部署 Validator: 将第 3 节的 Python 函数封装为 Tool，挂载到 Validator Node。
4. 前端集成: 监听 LangGraph 的流式输出。
    ◦ 当进入 Validator Node 时，前端显示：“正在进行 Architecture 10.2 合规性测试...”
    ◦ 当触发 Reflect Node 时，前端显示：“检测到类型安全违规，正在自动修正...”