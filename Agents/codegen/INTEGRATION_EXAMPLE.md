# Framework集成示例

## 概述

本文档展示如何将L0-L6框架集成为完整的Checker运行系统，包括端到端代码示例、Atom实现模式、错误处理等。

---

## 1. 完整端到端示例

### 1.1 基础架构

```python
# framework_runner.py - 框架主入口

from typing import Dict, Callable, Optional
from pathlib import Path

# Import各层模块
from L0.type_dispatcher import validate_and_normalize_config, determine_type
from L1.io_engine import IOEngine
from L2.parsing_orchestrator import orchestrate_parsing
from L3.check_assembler import assemble_check_result
from L4.waiver_engine import apply_waivers
from L5.output_controller import filter_output_keys
from L6.log_formatter import write_log_file


def run_checker(
    config: Dict,
    atom_a_func: Callable,
    atom_b_func: Optional[Callable] = None,
    atom_c_func: Optional[Callable] = None
) -> Dict:
    """
    完整Pipeline: L0 → L1 → L2 → L3 → L4 → L5
    
    输入:
        config: YAML配置字典
                {'requirements': {...}, 'waivers': {...}, 
                 'input_files': [...], 'description': str}
        atom_a_func: Atom A函数引用 (domain-specific)
        atom_b_func: Atom B函数引用 (可选，默认使用标准validate_logic)
        atom_c_func: Atom C函数引用 (可选，Type 1/4需要)
        
    输出:
        L5过滤后的结果字典 (CR5 compliant)
    """
    # Step 1: L0 配置验证和Type决策
    normalized = validate_and_normalize_config(
        requirements=config['requirements'],
        waivers=config['waivers'],
        input_files=config['input_files'],
        description=config.get('description', '')
    )
    
    type_id = determine_type(
        req_value=normalized['req_value'],
        waiver_value=normalized['waiver_value']
    )
    
    # Step 2: L2 解析编排
    # Note: L2内部直接导入L1的read_file_text函数
    # L1使用模块函数（read_file_text, resolve_indirect_reference），不需要实例化
    parsed_items_all, searched_files = orchestrate_parsing(
        input_files=normalized['input_files'],
        atom_a_func=atom_a_func
    )
    
    # Step 3: 如果没有提供atom_b，使用标准实现
    if atom_b_func is None:
        from atoms.standard_validate_logic import validate_logic
        atom_b_func = validate_logic
    
    # Step 4: L3 Check组装
    check_result = assemble_check_result(
        type_id=type_id,
        parsed_items_all=parsed_items_all,
        requirements=normalized,  # Pass Dict
        searched_files=searched_files,
        atom_b_func=atom_b_func,
        atom_c_func=atom_c_func,
        description=normalized['description']
    )
    
    # Step 5: L4 Waiver处理 (仅Type 3/4)
    if type_id in [3, 4] and normalized['waiver_value'] != 'N/A':
        check_result = apply_waivers(
            check_result=check_result,
            waiver_config={'value': normalized['waiver_value'], 
                          'waive_items': normalized['waive_items']},
            type_id=type_id,
            atom_b_func=atom_b_func
        )
    
    # Step 6: L5 输出过滤
    final_output = filter_output_keys(
        internal_result=check_result,
        type_id=type_id
    )
    
    return final_output
```

### 1.2 调用示例

```python
# my_checker.py - 具体Checker实现

from framework_runner import run_checker
from pathlib import Path


# Atom A实现：Netlist版本提取
def extract_netlist_version(text: str, source_file: str):
    """
    从netlist文件提取版本信息
    
    符合Atom A契约 (Plan.txt Section 1)
    """
    items = []
    lines = text.split('\n')
    
    for i, line in enumerate(lines[:50], start=1):  # 只扫描前50行
        if '// Generated by' in line and 'Genus' in line:
            # 提取版本号
            import re
            match = re.search(r'Synthesis Solution\s+([\d\.\-\w]+)', line)
            if match:
                items.append({
                    'value': match.group(1),  # MUST be str
                    'source_file': source_file,
                    'line_number': i,
                    'matched_content': line.strip(),
                    'parsed_fields': {}
                })
    
    return items


# 主函数
def main():
    # 配置
    config = {
        'requirements': {
            'value': 1,  # 期望找到至少1个版本
            'pattern_items': ['23.15', '24.10']  # 期望的版本号
        },
        'waivers': {
            'value': 'N/A'  # 无waiver
        },
        'input_files': [
            '/path/to/netlist.v.gz'
        ],
        'description': 'Check netlist version is correct'
    }
    
    # 运行框架
    result = run_checker(
        config=config,
        atom_a_func=extract_netlist_version,
        atom_b_func=None,  # 使用标准validate_logic
        atom_c_func=None   # Type 2不需要
    )
    
    # 结果
    print(f"Status: {result['status']}")
    print(f"Found: {len(result['found_items'])} items")
    print(f"Missing: {len(result['missing_items'])} items")
    
    # L6: 生成Log文件
    from L6.log_formatter import write_log_file
    write_log_file(
        l5_output=result,
        item_id='IMP-10-0-0-00',
        item_desc=config['description'],
        type_id=2,
        log_path=Path('output/IMP-10-0-0-00.log')
    )


if __name__ == '__main__':
    main()
```

---

## 2. Atom实现模式

### 2.1 标准Atom B（共享）

```python
# atoms/standard_validate_logic.py

import re
import fnmatch
from typing import Dict, Optional


def validate_logic(
    text: str,
    pattern: str,
    parsed_fields: Optional[Dict] = None,
    default_match: str = "contains",
    regex_mode: str = "search"
) -> Dict:
    """
    标准Atom B实现 (Plan.txt Section 1)
    
    可被所有checker共享使用
    """
    # None safety
    if parsed_fields is None:
        parsed_fields = {}
    
    # 1. Alternatives (最高优先级)
    if '|' in pattern:
        segments = [seg.strip() for seg in pattern.split('|') if seg.strip()]
        for seg in segments:
            if seg in text:  # contains check, literal
                return {
                    'is_match': True,
                    'reason': f'Matched alternative segment: {seg}',
                    'kind': 'alternatives'
                }
        return {
            'is_match': False,
            'reason': 'No alternative segment matched',
            'kind': 'alternatives'
        }
    
    # 2. Regex
    if pattern.startswith('regex:'):
        regex_pattern = pattern[6:]  # 去除'regex:'前缀
        try:
            if regex_mode not in ['search', 'match']:
                regex_mode = 'search'  # Invalid value fallback
            
            if regex_mode == 'search':
                match = re.search(regex_pattern, text)
            else:
                match = re.match(regex_pattern, text)
            
            if match:
                return {
                    'is_match': True,
                    'reason': f'Regex matched: {regex_pattern}',
                    'kind': 'regex'
                }
            else:
                return {
                    'is_match': False,
                    'reason': f'Regex not matched: {regex_pattern}',
                    'kind': 'regex'
                }
        except re.error as e:
            return {
                'is_match': False,
                'reason': f'Invalid Regex: {str(e)}',
                'kind': 'regex'
            }
    
    # 3. Wildcard
    if '*' in pattern or '?' in pattern:
        # MUST use fnmatchcase (case-sensitive, OS-independent)
        if fnmatch.fnmatchcase(text, pattern):
            return {
                'is_match': True,
                'reason': f'Wildcard matched: {pattern}',
                'kind': 'wildcard'
            }
        else:
            return {
                'is_match': False,
                'reason': f'Wildcard not matched: {pattern}',
                'kind': 'wildcard'
            }
    
    # 4. Default strategy
    if default_match not in ['contains', 'exact']:
        default_match = 'contains'  # Invalid value fallback
    
    if default_match == 'contains':
        if pattern in text:
            return {
                'is_match': True,
                'reason': f'Contains matched: {pattern}',
                'kind': 'contains'
            }
        else:
            return {
                'is_match': False,
                'reason': f'Contains not matched: {pattern}',
                'kind': 'contains'
            }
    else:  # exact
        if pattern == text:
            return {
                'is_match': True,
                'reason': f'Exact matched: {pattern}',
                'kind': 'exact'
            }
        else:
            return {
                'is_match': False,
                'reason': f'Exact not matched: {pattern}',
                'kind': 'exact'
            }
```

### 2.2 自定义Atom A示例

```python
# checkers/IMP-10-0-0-00/atom_a.py

def extract_context(text: str, source_file: str):
    """
    Domain-specific: 提取netlist/SPEF版本
    
    特点：
    - 只扫描前100行（header通常在开头）
    - 支持indirect_reference（触发递归）
    """
    items = []
    lines = text.split('\n')
    
    for i, line in enumerate(lines[:100], start=1):
        # Pattern 1: Netlist version
        if '// Generated by' in line:
            import re
            match = re.search(r'Generated by (.+)', line)
            if match:
                items.append({
                    'value': match.group(1).strip(),
                    'source_file': source_file,
                    'line_number': i,
                    'matched_content': line.strip(),
                    'parsed_fields': {'field_type': 'tool_version'}
                })
        
        # Pattern 2: Indirect reference to SPEF
        if 'Reading SPEF:' in line:
            match = re.search(r'Reading SPEF:\s+(.+)', line)
            if match:
                spef_path = match.group(1).strip()
                items.append({
                    'value': spef_path,
                    'source_file': source_file,
                    'line_number': i,
                    'matched_content': line.strip(),
                    'parsed_fields': {
                        'indirect_reference': spef_path  # 触发L2递归
                    }
                })
    
    return items
```

### 2.3 自定义Atom C示例

```python
# atoms/existence_checkers.py

def check_unique_netlist(items):
    """
    Atom C示例：检查netlist是否unique
    
    逻辑：查找 "*** Netlist is unique" 标记
    """
    for item in items:
        if 'unique' in item.get('value', '').lower():
            # 找到evidence
            return {
                'is_match': True,
                'reason': 'Found unique marker',
                'evidence': [item]
            }
    
    # 未找到
    return {
        'is_match': False,
        'reason': 'Unique marker not found',
        'evidence': []
    }
```

---

## 3. 错误处理

### 3.1 ConfigError处理

```python
from L0.exceptions import ConfigError

try:
    result = run_checker(config, atom_a, atom_b, atom_c)
except ConfigError as e:
    print(f"Configuration error: {e}")
    # 记录到日志
    # 返回CONFIG_ERROR状态
```

### 3.2 FileReadError处理

```python
from L1.io_engine import FileReadError

try:
    result = run_checker(config, atom_a, atom_b, atom_c)
except FileReadError as e:
    print(f"File read error: {e}")
    # 生成missing files error report
```

### 3.3 完整错误处理包装

```python
def safe_run_checker(config, atom_a, atom_b=None, atom_c=None):
    """带完整错误处理的wrapper"""
    try:
        return run_checker(config, atom_a, atom_b, atom_c)
    
    except ConfigError as e:
        # 配置错误
        return {
            'status': 'CONFIG_ERROR',
            'error_message': str(e),
            'found_items': [],
            'missing_items': [],
            'extra_items': []
        }
    
    except FileReadError as e:
        # 文件读取错误
        return {
            'status': 'FILE_ERROR',
            'error_message': str(e),
            'found_items': [],
            'missing_items': [{
                'expected': 'Input file',
                'reason': str(e),
                'source_file': '',
                'line_number': None,
                'matched_content': '',
                'parsed_fields': {}
            }]
        }
    
    except Exception as e:
        # 未预期的错误
        return {
            'status': 'EXECUTION_ERROR',
            'error_message': str(e),
            'found_items': [],
            'missing_items': []
        }
```

---

## 4. 批量Checker执行

### 4.1 多Checker批处理

```python
# batch_runner.py

from typing import List, Dict
from pathlib import Path


def run_checklist(checkers: List[Dict]) -> List[Dict]:
    """
    批量执行多个checker
    
    输入:
        checkers: [
            {
                'item_id': 'IMP-10-0-0-00',
                'config': {...},
                'atom_a': func,
                'atom_b': func,
                'atom_c': func
            },
            ...
        ]
        
    输出:
        List of results
    """
    results = []
    
    for checker in checkers:
        print(f"Running {checker['item_id']}...")
        
        try:
            result = run_checker(
                config=checker['config'],
                atom_a_func=checker['atom_a'],
                atom_b_func=checker.get('atom_b'),
                atom_c_func=checker.get('atom_c')
            )
            
            results.append({
                'item_id': checker['item_id'],
                'status': result['status'],
                'result': result
            })
        
        except Exception as e:
            results.append({
                'item_id': checker['item_id'],
                'status': 'ERROR',
                'error': str(e)
            })
    
    return results


def generate_summary(results: List[Dict], output_dir: Path):
    """生成汇总报告"""
    from L6.summary_generator import generate_summary_yaml
    
    # 提取L5输出
    l5_outputs = [r['result'] for r in results if r['status'] != 'ERROR']
    
    # 提取元数据
    metadata = [
        {
            'item_id': r['item_id'],
            'item_desc': r['result'].get('description', ''),
            'type_id': r.get('type_id', 2)  # 需要从结果推断
        }
        for r in results if r['status'] != 'ERROR'
    ]
    
    # 生成Summary YAML
    generate_summary_yaml(
        l5_outputs=l5_outputs,
        item_metadata=metadata,
        module_name='top_module',
        stage_name='signoff',
        output_path=output_dir / 'summary.yaml'
    )
```

### 4.2 并行执行（可选）

```python
from concurrent.futures import ProcessPoolExecutor, as_completed


def run_checklist_parallel(checkers: List[Dict], max_workers: int = 4):
    """并行执行checkers"""
    results = []
    
    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        # 提交任务
        futures = {
            executor.submit(
                run_checker,
                checker['config'],
                checker['atom_a'],
                checker.get('atom_b'),
                checker.get('atom_c')
            ): checker['item_id']
            for checker in checkers
        }
        
        # 收集结果
        for future in as_completed(futures):
            item_id = futures[future]
            try:
                result = future.result()
                results.append({
                    'item_id': item_id,
                    'status': result['status'],
                    'result': result
                })
            except Exception as e:
                results.append({
                    'item_id': item_id,
                    'status': 'ERROR',
                    'error': str(e)
                })
    
    return results
```

---

## 5. 目录结构建议

```
project/
├── framework/                  # 框架核心代码
│   ├── __init__.py
│   ├── runner.py              # run_checker主函数
│   ├── L0/
│   │   ├── type_dispatcher.py
│   │   ├── config_validator.py
│   │   └── exceptions.py
│   ├── L1/
│   │   └── io_engine.py
│   ├── L2/
│   │   └── parsing_orchestrator.py
│   ├── L3/
│   │   └── check_assembler.py
│   ├── L4/
│   │   └── waiver_engine.py
│   ├── L5/
│   │   └── output_controller.py
│   └── L6/
│       ├── log_formatter.py
│       ├── summary_generator.py
│       └── excel_generator.py
│
├── atoms/                      # 共享Atoms
│   ├── __init__.py
│   └── standard_validate_logic.py  # 标准Atom B
│
├── checkers/                   # 各个Checker实现
│   ├── IMP-10-0-0-00/
│   │   ├── __init__.py
│   │   ├── checker.py         # main函数
│   │   ├── atom_a.py          # extract_context
│   │   └── config.yaml        # 配置文件
│   ├── IMP-10-0-1-00/
│   │   └── ...
│   └── ...
│
├── tests/                      # 测试
│   ├── test_l0.py
│   ├── test_l1.py
│   └── ...
│
├── output/                     # 输出目录
│   ├── logs/
│   ├── reports/
│   └── summary.yaml
│
└── requirements.txt
```

---

## 6. Import路径示例

### 6.1 框架内部导入

```python
# L2使用L1
from framework.L1.io_engine import IOEngine

# L3使用L2
from framework.L2.parsing_orchestrator import orchestrate_parsing

# L6使用L5
from framework.L5.output_controller import filter_output_keys
```

### 6.2 Checker导入框架

```python
# checkers/IMP-10-0-0-00/checker.py

from framework.runner import run_checker
from atoms.standard_validate_logic import validate_logic
from .atom_a import extract_context


def main():
    result = run_checker(
        config=config,
        atom_a_func=extract_context,
        atom_b_func=validate_logic
    )
```

---

## 7. 部署和使用

### 7.1 安装

```bash
# 安装框架
pip install -e .

# 或者添加到PYTHONPATH
export PYTHONPATH="${PYTHONPATH}:/path/to/project"
```

### 7.2 命令行接口（可选）

```python
# cli.py

import argparse
import yaml
from pathlib import Path
from framework.runner import run_checker


def main():
    parser = argparse.ArgumentParser(description='Run checker')
    parser.add_argument('--config', required=True, help='Config YAML path')
    parser.add_argument('--checker', required=True, help='Checker module name')
    parser.add_argument('--output', default='output', help='Output directory')
    
    args = parser.parse_args()
    
    # 加载配置
    with open(args.config) as f:
        config = yaml.safe_load(f)
    
    # 动态导入checker
    import importlib
    checker_module = importlib.import_module(f'checkers.{args.checker}.checker')
    
    # 运行
    result = checker_module.run(config)
    
    # 输出
    print(f"Status: {result['status']}")


if __name__ == '__main__':
    main()
```

### 7.3 使用示例

```bash
# 运行单个checker
python cli.py --config configs/IMP-10-0-0-00.yaml --checker IMP-10-0-0-00

# 运行整个checklist
python batch_runner.py --checklist configs/checklist.yaml --output output/
```

---

## 8. 调试技巧

### 8.1 启用详细日志

```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# 在各层添加日志
logger = logging.getLogger(__name__)
logger.debug(f"L2: Parsed {len(items)} items from {source_file}")
```

### 8.2 中间结果检查

```python
def run_checker_debug(config, atom_a, atom_b=None, atom_c=None):
    """Debug版本，输出中间结果"""
    
    # L0
    normalized = validate_and_normalize_config(...)
    type_id = determine_type(normalized['req_value'], normalized['waiver_value'])
    print(f"[L0] Type: {type_id}, req_value: {normalized['req_value']}")
    
    # L2 (returns Tuple)
    parsed_items_all, searched_files = orchestrate_parsing(...)
    print(f"[L2] Parsed items: {len(parsed_items_all)}")
    print(f"[L2] Searched files: {searched_files}")
    
    # L3
    check_result = assemble_check_result(...)
    print(f"[L3] Found: {len(check_result['found_items'])}, "
          f"Missing: {len(check_result['missing_items'])}")
    
    # L4 (if applicable)
    if type_id in [3, 4]:
        check_result = apply_waivers(...)
        print(f"[L4] Waived: {len(check_result['waived'])}")
    
    # L5
    final_output = filter_output_keys(...)
    print(f"[L5] Final keys: {list(final_output.keys())}")
    
    return final_output
```

---

**版本:** 1.0  
**最后更新:** 2026-01-26  
**依赖:** Plan.txt 10.2, L0-L6执行计划  
**状态:** Ready for Use
