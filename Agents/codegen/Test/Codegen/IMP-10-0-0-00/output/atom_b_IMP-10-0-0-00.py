# Generated by Developer Agent
# Item ID: IMP-10-0-0-00
# Model: claude-sonnet-4-5
# Generated at: 2026-01-28T14:06:36.477378

# === ATOM B ===
import re
import fnmatch

def validate_logic(text, pattern, parsed_fields=None, default_match="contains", regex_mode="search"):
    """
    Universal pattern validation with hard precedence rules.
    
    Args:
        text: Text to validate against pattern
        pattern: Pattern string (supports alternatives, regex, wildcard, or plain text)
        parsed_fields: Optional parsed fields dictionary (unused but required for signature)
        default_match: Default matching mode ("contains" or "exact")
        regex_mode: Regex matching mode ("search" or "match")
    
    Returns:
        Dict with keys: is_match (bool), reason (str), kind (str)
    """
    # Handle None text safely
    if text is None:
        text = ""
    
    text = str(text)
    pattern = str(pattern)
    
    # Priority 1: Alternatives (if `|` in pattern)
    if '|' in pattern:
        segments = pattern.split('|')
        for segment in segments:
            segment = segment.strip()
            if segment and segment in text:
                return {
                    'is_match': True,
                    'reason': f"Text contains alternative segment '{segment}'",
                    'kind': 'alternatives'
                }
        return {
            'is_match': False,
            'reason': f"Text does not contain any alternative from pattern '{pattern}'",
            'kind': 'alternatives'
        }
    
    # Priority 2: Regex (if pattern starts with `regex:`)
    if pattern.startswith('regex:'):
        regex_pattern = pattern[6:]  # Remove 'regex:' prefix
        
        # Validate regex_mode parameter
        if regex_mode not in ['search', 'match']:
            regex_mode = 'search'  # Default to search for invalid modes
        
        try:
            if regex_mode == 'match':
                match = re.match(regex_pattern, text)
            else:  # regex_mode == 'search'
                match = re.search(regex_pattern, text)
            
            if match:
                return {
                    'is_match': True,
                    'reason': f"Text matches regex pattern '{regex_pattern}' using {regex_mode} mode",
                    'kind': 'regex'
                }
            else:
                return {
                    'is_match': False,
                    'reason': f"Text does not match regex pattern '{regex_pattern}' using {regex_mode} mode",
                    'kind': 'regex'
                }
        except re.error as e:
            return {
                'is_match': False,
                'reason': f"Invalid Regex: {str(e)}",
                'kind': 'regex'
            }
    
    # Priority 3: Wildcard (if `*` or `?` in pattern)
    if '*' in pattern or '?' in pattern:
        is_match = fnmatch.fnmatchcase(text, pattern)
        return {
            'is_match': is_match,
            'reason': f"Wildcard pattern '{pattern}' {'matches' if is_match else 'does not match'} text",
            'kind': 'wildcard'
        }
    
    # Priority 4: Default (string containment or equality)
    if default_match == "exact":
        is_match = (text == pattern)
        return {
            'is_match': is_match,
            'reason': f"Text {'equals' if is_match else 'does not equal'} pattern '{pattern}' (exact match)",
            'kind': 'exact'
        }
    else:  # default_match == "contains"
        is_match = (pattern in text)
        return {
            'is_match': is_match,
            'reason': f"Text {'contains' if is_match else 'does not contain'} pattern '{pattern}'",
            'kind': 'contains'
        }


# === ATOM C ===