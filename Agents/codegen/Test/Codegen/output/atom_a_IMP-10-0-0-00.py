# Generated by Developer Agent - Agent A
# Model: claude-sonnet-4-5
# ItemSpec: IMP-10-0-0-00
# Generated at: 2026-01-28T11:42:02.434317

import re
from typing import List, Dict

def extract_context(text: str, source_file: str) -> List[Dict]:
    """
    Extract netlist/SPEF version confirmation patterns from STA log files.
    
    Searches for:
    1. Date patterns in format MM/DD (converted to year 2025 context)
    2. "Generated on:" patterns with year 2025
    3. Netlist reading confirmation lines with dates
    4. SPEF-related messages
    
    Args:
        text: Log file content as string
        source_file: Source file path
        
    Returns:
        List of dicts with standardized schema
    """
    results = []
    lines = text.split('\n')
    
    # Pattern 1: "Generated on:*2025*" - direct match
    pattern_generated_on = re.compile(r'Generated on:.*2025.*', re.IGNORECASE)
    
    # Pattern 2: Date patterns that could indicate 2025 context
    # Looking for date=MM/DD format which appears in the logs
    pattern_date_context = re.compile(r'date=(\d{1,2}/\d{1,2})\s+(\d{1,2}:\d{2}:\d{2})', re.IGNORECASE)
    
    # Pattern 3: Netlist reading with date information
    pattern_netlist_date = re.compile(r'(Begin Load netlist data|End Load netlist data|Begin netlist parsing|End netlist parsing).*date=', re.IGNORECASE)
    
    # Pattern 4: SPEF related messages (for waiver detection)
    pattern_spef = re.compile(r'(SPEF|spef|read_parasitics)', re.IGNORECASE)
    
    for line_num, line in enumerate(lines, start=1):
        line_stripped = line.strip()
        if not line_stripped:
            continue
        
        # Check for "Generated on:*2025*" pattern
        match_generated = pattern_generated_on.search(line_stripped)
        if match_generated:
            results.append({
                "value": match_generated.group(0),
                "source_file": source_file,
                "line_number": line_num,
                "matched_content": line_stripped,
                "parsed_fields": {
                    "pattern_type": "generated_on_2025",
                    "match_text": match_generated.group(0)
                }
            })
        
        # Check for date context patterns (MM/DD HH:MM:SS)
        match_date = pattern_date_context.search(line_stripped)
        if match_date:
            date_str = match_date.group(1)
            time_str = match_date.group(2)
            # Assume current context is 2025 based on requirement
            full_date = f"date={date_str} {time_str} (2025 context)"
            results.append({
                "value": full_date,
                "source_file": source_file,
                "line_number": line_num,
                "matched_content": line_stripped,
                "parsed_fields": {
                    "pattern_type": "date_with_2025_context",
                    "date": date_str,
                    "time": time_str,
                    "assumed_year": "2025"
                }
            })
        
        # Check for netlist operations with dates
        match_netlist = pattern_netlist_date.search(line_stripped)
        if match_netlist:
            results.append({
                "value": line_stripped,
                "source_file": source_file,
                "line_number": line_num,
                "matched_content": line_stripped,
                "parsed_fields": {
                    "pattern_type": "netlist_operation_with_date",
                    "operation": match_netlist.group(1)
                }
            })
        
        # Check for SPEF related content (for waiver tracking)
        match_spef = pattern_spef.search(line_stripped)
        if match_spef:
            results.append({
                "value": line_stripped,
                "source_file": source_file,
                "line_number": line_num,
                "matched_content": line_stripped,
                "parsed_fields": {
                    "pattern_type": "spef_related",
                    "keyword": match_spef.group(1),
                    "is_waiver_relevant": True
                }
            })
    
    # [Locked] Standardization Layer
    standardized_output = []
    for item in results:
        safe_value = str(item.get("value", ""))
        standardized_item = {
            "value": safe_value,
            "source_file": source_file,
            "line_number": item.get("line_number"),
            "matched_content": str(item.get("matched_content", "")),
            "parsed_fields": item.get("parsed_fields", {})
        }
        standardized_output.append(standardized_item)
    return standardized_output