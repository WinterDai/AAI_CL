# Generated by Developer Agent - Agent B
# Model: claude-sonnet-4-5
# ItemSpec: IMP-10-0-0-00
# Generated at: 2026-01-28T11:42:31.957054

# === ATOM B ===
import re
import fnmatch
from typing import Dict, Any, Optional

def validate_logic(
    text: str,
    pattern: str,
    parsed_fields: Optional[Dict[str, Any]] = None,
    default_match: str = "contains",
    regex_mode: str = "search"
) -> Dict[str, Any]:
    """
    Universal validation logic with hard precedence rules.
    
    Args:
        text: Text to validate against pattern
        pattern: Pattern to match (supports alternatives, regex, wildcard, string)
        parsed_fields: Optional parsed fields from Atom A (not used in logic, for context)
        default_match: "contains" or "exact" for default string matching
        regex_mode: "search" or "match" for regex matching
        
    Returns:
        Dict with keys: is_match (bool), reason (str), kind (str)
    """
    # Handle None/empty inputs
    if text is None:
        text = ""
    if pattern is None:
        pattern = ""
    
    text = str(text)
    pattern = str(pattern)
    
    # Priority 1: Alternatives (if | in pattern)
    if '|' in pattern:
        segments = [seg.strip() for seg in pattern.split('|')]
        for segment in segments:
            # Recursively check each segment (will apply regex/wildcard/default rules)
            result = validate_logic(text, segment, parsed_fields, default_match, regex_mode)
            if result['is_match']:
                return {
                    'is_match': True,
                    'reason': f"Matched alternative segment: '{segment}' ({result['kind']})",
                    'kind': 'alternatives'
                }
        return {
            'is_match': False,
            'reason': f"No alternative segment matched from: {segments}",
            'kind': 'alternatives'
        }
    
    # Priority 2: Regex (if pattern starts with regex:)
    if pattern.startswith('regex:'):
        regex_pattern = pattern[6:]  # Remove 'regex:' prefix
        try:
            if regex_mode == "match":
                match = re.match(regex_pattern, text)
            else:  # default to search
                match = re.search(regex_pattern, text)
            
            if match:
                return {
                    'is_match': True,
                    'reason': f"Regex matched: '{regex_pattern}' in text",
                    'kind': 'regex'
                }
            else:
                return {
                    'is_match': False,
                    'reason': f"Regex did not match: '{regex_pattern}'",
                    'kind': 'regex'
                }
        except re.error as e:
            return {
                'is_match': False,
                'reason': f"Invalid Regex: {str(e)}",
                'kind': 'regex'
            }
    
    # Priority 3: Wildcard (if * or ? in pattern)
    if '*' in pattern or '?' in pattern:
        is_match = fnmatch.fnmatchcase(text, pattern)
        return {
            'is_match': is_match,
            'reason': f"Wildcard pattern '{pattern}' {'matched' if is_match else 'did not match'}",
            'kind': 'wildcard'
        }
    
    # Priority 4: Default (string containment or equality)
    if default_match == "exact":
        is_match = (text == pattern)
        return {
            'is_match': is_match,
            'reason': f"Exact match {'succeeded' if is_match else 'failed'}: expected '{pattern}'",
            'kind': 'exact'
        }
    else:  # default to contains
        is_match = (pattern in text)
        return {
            'is_match': is_match,
            'reason': f"Contains check: '{pattern}' {'found' if is_match else 'not found'} in text",
            'kind': 'contains'
        }


# === ATOM C ===
from typing import List, Dict, Any