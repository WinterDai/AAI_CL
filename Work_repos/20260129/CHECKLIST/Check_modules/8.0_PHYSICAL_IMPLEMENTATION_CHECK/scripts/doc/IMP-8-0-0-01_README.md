# IMP-8-0-0-01: Confirm all ports are assigned on metal track.

## Overview

**Check ID:** IMP-8-0-0-01  
**Description:** Confirm all ports are assigned on metal track.  
**Category:** Physical Implementation - Pin Assignment Validation  
**Input Files:** Cadence Innovus checkPinAssignment report (*.rpt)

This checker validates that all design ports are properly placed on metal routing tracks. It parses the Cadence Innovus `checkPinAssignment` report to detect unplaced pins and pins not placed on routing tracks. The checker implements a two-tier validation:
1. **PASS Condition 1**: All ports are placed on metal tracks (no violations)
2. **PASS Condition 2**: Only "OVERLAPPED WITH ROUTE BLOCKAGE" warnings exist (acceptable when route blockage is present on ports)
3. **FAIL Condition 1**: Unplaced pins detected in report
4. **FAIL Condition 2**: Pins not placed on metal routing tracks (NOT ON ROUTING TRACK violations)

The checker categorizes violations by failure type and outputs port names with their specific violation reasons for debugging.

---

## Check Logic

### Input Parsing

The checker parses Cadence Innovus checkPinAssignment reports using a state-machine approach to extract design metadata and pin violations.

**Key Patterns:**

```python
# Pattern 1: Extract design name from header
pattern_design = r'^#\s+Design:\s+(\S+)'
# Example: "#  Design:            cdrlf_wrapper"
# Captures: design_name = "cdrlf_wrapper"

# Pattern 2: Extract tool version from header
pattern_tool = r'^#\s+Generated by:\s+Cadence Innovus\s+([\d\.-]+\w*)'
# Example: "#  Generated by:      Cadence Innovus 23.33-s082_1"
# Captures: tool_version = "23.33-s082_1"

# Pattern 3: Detect unplaced pins section marker
pattern_unplaced_section = r'^Unplaced Pins:\s*$'
# Example: "Unplaced Pins:"
# Triggers: State transition to IN_UNPLACED_SECTION

# Pattern 4: Extract individual unplaced pin names
pattern_unplaced_pin = r'^\s+-\s+([\w\[\]]+)\s*$'
# Example: " - rxda_cdrlf_scanmode"
# Example: " - e_pi_ctrl[0]"
# Captures: pin_name with bus notation preserved

# Pattern 5: Detect NOT ON ROUTING TRACK violations
pattern_not_on_track = r'([\w\[\]]+).*NOT ON ROUTING TRACK'
# Example: "port_name[5] ... NOT ON ROUTING TRACK"
# Captures: pin_name from same line as violation

# Pattern 6: Detect OVERLAPPED WITH ROUTE BLOCKAGE warnings
pattern_route_blockage = r'OVERLAPPED WITH ROUTE BLOCKAGE'
# Example: "WARNING: port_x OVERLAPPED WITH ROUTE BLOCKAGE"
# Used to identify acceptable warnings
```

### Detection Logic

**Step 1: Initialize State Machine**
- States: HEADER, IN_UNPLACED_SECTION, CHECKING_VIOLATIONS
- Track current file path and line number for violation reporting

**Step 2: Parse Report Line-by-Line**
```python
for line_num, line in enumerate(report_file, start=1):
    # Extract metadata (design name, tool version)
    if state == HEADER:
        match_design = re.match(pattern_design, line)
        match_tool = re.match(pattern_tool, line)
    
    # Detect unplaced pins section
    if re.match(pattern_unplaced_section, line):
        state = IN_UNPLACED_SECTION
    
    # Extract unplaced pin names
    if state == IN_UNPLACED_SECTION:
        match_pin = re.match(pattern_unplaced_pin, line)
        if match_pin:
            unplaced_pins.append({
                'name': match_pin.group(1),
                'file': file_path,
                'line': line_num,
                'reason': 'Unplaced'
            })
    
    # Detect NOT ON ROUTING TRACK violations
    if 'NOT ON ROUTING TRACK' in line:
        match_track = re.search(pattern_not_on_track, line)
        if match_track:
            track_violations.append({
                'name': match_track.group(1),
                'file': file_path,
                'line': line_num,
                'reason': 'NOT ON ROUTING TRACK'
            })
    
    # Count OVERLAPPED WITH ROUTE BLOCKAGE warnings
    if re.search(pattern_route_blockage, line):
        blockage_warnings += 1
```

**Step 3: Classify Result**
```python
# Determine PASS/FAIL based on violation types
if len(unplaced_pins) == 0 and len(track_violations) == 0:
    # PASS Condition 1: No violations
    status = "PASS"
    reason = "All ports are assigned on metal track"

elif len(unplaced_pins) == 0 and len(track_violations) == 0 and blockage_warnings > 0:
    # PASS Condition 2: Only route blockage warnings (acceptable)
    status = "PASS"
    reason = f"Only OVERLAPPED WITH ROUTE BLOCKAGE warnings ({blockage_warnings} found)"

else:
    # FAIL: Violations detected
    status = "FAIL"
    
    # Categorize violations by type
    violations_by_type = {
        'Unplaced': [v for v in unplaced_pins],
        'NOT ON ROUTING TRACK': [v for v in track_violations]
    }
    
    # Build failure reason
    reason_parts = []
    if unplaced_pins:
        reason_parts.append(f"{len(unplaced_pins)} unplaced pins")
    if track_violations:
        reason_parts.append(f"{len(track_violations)} pins not on routing track")
    
    reason = "Pin assignment violations: " + ", ".join(reason_parts)
```

**Step 4: Format Output**
```python
# For FAIL cases, output violations categorized by type
if status == "FAIL":
    print("FAIL")
    for violation_type, violations in violations_by_type.items():
        for v in violations:
            print(f"{v['name']}:{violation_type}")
else:
    print("PASS")
```

**Edge Cases Handled:**
- Empty unplaced pins section (no violations)
- Missing "Unplaced Pins:" section (assume all placed)
- Bus notation in pin names (e.g., `port[0]`, `signal[63]`)
- Multiple files with different designs (track per-file metadata)
- Mixed violation types in same report

---

## Output Behavior (CRITICAL - Determines Type 2/3 Logic!)

**Check Mode:** `status_check`

**Selected Mode for this checker:** `status_check`

**Rationale:** This checker validates the placement status of design ports. The `pattern_items` represent port names to check, and the checker reports whether each port is correctly placed on metal tracks. Only ports with incorrect status (unplaced or not on track) are reported as violations. This is a status validation check, not an existence check, because:
1. We're checking the placement STATUS of ports (placed vs unplaced, on-track vs off-track)
2. Only ports with WRONG status are reported as violations
3. Ports not in `pattern_items` are ignored (not reported)
4. The check focuses on validating placement correctness, not existence

---

## Output Descriptions (CRITICAL - Code Generator Uses These!)

This section defines the output strings used by `build_complete_output()` in the checker code.

```python
# ‚ö†Ô∏è CRITICAL: Description & Reason parameter usage by Type (API-026)
# Both DESC and REASON constants are split by Type for semantic clarity:
#   Type 1/4 (Boolean): Use DESC_TYPE1_4 & REASON_TYPE1_4 (emphasize "found/not found")
#   Type 2/3 (Pattern): Use DESC_TYPE2_3 & REASON_TYPE2_3 (emphasize "matched/satisfied")

# Item description for this checker
item_desc = "Confirm all ports are assigned on metal track."

# PASS case descriptions - Split by Type semantics (API-026)
# Type 1/4: Boolean checks - emphasize "found/not found" (existence)
found_desc_type1_4 = "All ports found on metal routing tracks"
# Type 2/3: Pattern checks - emphasize "matched/satisfied" (pattern validation)
found_desc_type2_3 = "All ports correctly placed on metal routing tracks"

# PASS reasons - Split by Type semantics (ALL Types need these)
# Type 1/4: Boolean checks - emphasize "found/not found" (existence)
found_reason_type1_4 = "All ports found on metal routing tracks with no placement violations"
# Type 2/3: Pattern checks - emphasize pattern matching terms (matched|satisfied|validated|compliant|fulfilled)
found_reason_type2_3 = "Port placement validated: all ports matched routing track requirements"

# FAIL case descriptions - Split by Type semantics (API-026)
# Type 1/4: Boolean checks - emphasize "not found" (absence)
missing_desc_type1_4 = "Ports not found on metal routing tracks"
# Type 2/3: Pattern checks - emphasize pattern mismatch
missing_desc_type2_3 = "Port placement violations detected"

# FAIL reasons - Split by Type semantics (ALL Types need these)
# Type 1/4: Boolean checks - emphasize "not found" (absence)
missing_reason_type1_4 = "Ports not found on metal routing tracks - placement verification failed"
# Type 2/3: Pattern checks - emphasize pattern mismatch terms (not satisfied|missing|failed)
missing_reason_type2_3 = "Port placement requirements not satisfied - routing track violations detected"

# WAIVED case descriptions (ALL Types need these)
# Type 1/2 use in waiver=0 mode for waive_items comments
# Type 3/4 use for actual waived violations
waived_desc = "Waived port placement violations"

# WAIVED reasons (Type 3/4 ONLY - actual waiver logic)
waived_base_reason = "Port placement violation waived per design review"

# UNUSED waivers (Type 3/4 ONLY)
unused_desc = "Unused waiver entries for port placement"
unused_waiver_reason = "Waiver not matched - no corresponding port placement violation found"
```

### INFO01/ERROR01 Display Format

The checker uses `build_complete_output()` method's default format:

```
INFO01 (Clean/Pass items):
  Format: "- [port_name]: [found_reason]"
  Example: "- vdd_core: Port placement validated: all ports matched routing track requirements"

ERROR01 (Violation/Fail items):
  Format: "- [port_name]: [missing_reason]"
  Example: "- rxda_cdrlf_scanmode: Unplaced"
  Example: "- e_pi_ctrl[0]: NOT ON ROUTING TRACK"
```

Note: The actual output format is controlled by the `found_reason` and `missing_reason` parameters passed to `build_complete_output()`. For this checker, violation-specific reasons are appended:
- Unplaced pins: `"Port placement requirements not satisfied - routing track violations detected: Unplaced"`
- Off-track pins: `"Port placement requirements not satisfied - routing track violations detected: NOT ON ROUTING TRACK"`

---

## Type 1: Boolean Check

**Configuration (copy to item_data.yaml for testing):**
```yaml
IMP-8-0-0-01:
  description: "Confirm all ports are assigned on metal track."
  requirements:
    value: N/A
    pattern_items: []
  input_files:
    - "reports/8.0/IMP-8-0-0-01/IMP-8-0-0-01_case1.rpt"
  waivers:
    value: N/A
    waive_items: []
```

**Check Behavior:**
Type 1 performs custom boolean validation of port placement. The checker parses the checkPinAssignment report and validates:
- No unplaced pins exist
- No pins are off routing tracks
- Only acceptable warnings (OVERLAPPED WITH ROUTE BLOCKAGE) may be present

PASS if all ports are correctly placed on metal tracks.
FAIL if any unplaced pins or routing track violations are detected.

**Sample Output (PASS):**
```
Status: PASS
Reason: All ports found on metal routing tracks with no placement violations
INFO01:
  - cdrlf_wrapper: All ports found on metal routing tracks with no placement violations
```

**Sample Output (FAIL):**
```
Status: FAIL
Reason: Ports not found on metal routing tracks - placement verification failed
ERROR01:
  - rxda_cdrlf_scanmode: Ports not found on metal routing tracks - placement verification failed: Unplaced
  - rxda_cdrlf_scanout[0]: Ports not found on metal routing tracks - placement verification failed: Unplaced
  - e_pi_ctrl[0]: Ports not found on metal routing tracks - placement verification failed: NOT ON ROUTING TRACK
```

### Type 1 Variant: waivers.value=0 (Forced PASS Mode)

**Configuration:**
```yaml
IMP-8-0-0-01:
  description: "Confirm all ports are assigned on metal track."
  requirements:
    value: N/A
    pattern_items: []
  input_files:
    - "reports/8.0/IMP-8-0-0-01/IMP-8-0-0-01_case1.rpt"
  waivers:
    value: 0  # CRITICAL: value=0 triggers forced PASS mode (NOT waiver logic!)
    waive_items:  # IMPORTANT: Use PLAIN STRING format (NOT name/reason dict!)
      - "Explanation: Port placement violations are informational during early design stages"
      - "Note: Unplaced ports will be resolved during final placement optimization"
```

**CRITICAL Behavior (waivers.value=0):**
- NOTE: Type 1 has NO waiver logic. waive=0 is forced PASS mode only
- IMPORTANT: waive_items uses PLAIN STRINGS (NOT name/reason dict like Type 3/4!)
- waive_items serves as COMMENT ONLY (no matching/filtering logic)
- waive_items content printed as INFO with [WAIVED_INFO] tag
- ALL violations force converted: FAIL‚ÜíPASS, displayed as INFO with [WAIVED_AS_INFO] tag
- Check ALWAYS returns PASS (violations shown as INFO for tracking)
- Used when: Check is informational only, violations expected/acceptable

**Sample Output (PASS with violations):**
```
Status: PASS  # Always PASS when waivers.value=0
Reason: All violations waived as informational
INFO01 ([WAIVED_INFO] - waive_items as comment):
  - "Explanation: Port placement violations are informational during early design stages"
  - "Note: Unplaced ports will be resolved during final placement optimization"
INFO02 ([WAIVED_AS_INFO] - violations converted to PASS, shown as INFO):
  - rxda_cdrlf_scanmode: Ports not found on metal routing tracks - placement verification failed: Unplaced [WAIVED_AS_INFO]
  - e_pi_ctrl[0]: Ports not found on metal routing tracks - placement verification failed: NOT ON ROUTING TRACK [WAIVED_AS_INFO]
```

---

## Type 2: Value Check

**Configuration (copy to item_data.yaml for testing):**
```yaml
IMP-8-0-0-01:
  description: "Confirm all ports are assigned on metal track."
  requirements:
    value: 3
    pattern_items:
      - "rxda_cdrlf_scanmode"
      - "rxda_cdrlf_scanout[0]"
      - "e_pi_ctrl[0]"
  input_files:
    - "reports/8.0/IMP-8-0-0-01/IMP-8-0-0-01_case1.rpt"
  waivers:
    value: N/A
    waive_items: []
```

üõë CRITICAL RULE for pattern_items:
- Description: "Confirm all ports are assigned on metal track"
- Semantic level: PORT NAMES (identifiers of ports to validate)
- ‚úÖ Use complete port names with bus notation: "port_name[index]"
- ‚ùå DO NOT use paths or file locations
- ‚ùå DO NOT use status values ("Unplaced", "NOT ON ROUTING TRACK")

**Check Behavior:**
Type 2 searches for specified port names in the checkPinAssignment report and validates their placement status.
- PASS if all pattern_items ports are correctly placed on metal tracks (no violations found)
- FAIL if any pattern_items ports are unplaced or not on routing tracks

This is a **requirement check**: PASS when missing_items is empty (all required ports correctly placed).

**Sample Output (PASS):**
```
Status: PASS
Reason: Port placement validated: all ports matched routing track requirements
INFO01:
  - rxda_cdrlf_scanmode: Port placement validated: all ports matched routing track requirements
  - rxda_cdrlf_scanout[0]: Port placement validated: all ports matched routing track requirements
  - e_pi_ctrl[0]: Port placement validated: all ports matched routing track requirements
```

**Sample Output (FAIL):**
```
Status: FAIL
Reason: Port placement requirements not satisfied - routing track violations detected
ERROR01:
  - rxda_cdrlf_scanmode: Port placement requirements not satisfied - routing track violations detected: Unplaced
  - e_pi_ctrl[0]: Port placement requirements not satisfied - routing track violations detected: NOT ON ROUTING TRACK
INFO01:
  - rxda_cdrlf_scanout[0]: Port placement validated: all ports matched routing track requirements
```

### Type 2 Variant: waivers.value=0 (Forced PASS Mode)

**Configuration:**
```yaml
IMP-8-0-0-01:
  description: "Confirm all ports are assigned on metal track."
  requirements:
    value: 3
    pattern_items:
      - "rxda_cdrlf_scanmode"
      - "rxda_cdrlf_scanout[0]"
      - "e_pi_ctrl[0]"
  input_files:
    - "reports/8.0/IMP-8-0-0-01/IMP-8-0-0-01_case1.rpt"
  waivers:
    value: 0  # CRITICAL: value=0 triggers forced PASS mode (NOT waiver logic!)
    waive_items:  # IMPORTANT: Use PLAIN STRING format (NOT name/reason dict!)
      - "Explanation: Port placement check is informational during floorplanning phase"
      - "Note: Unplaced ports are expected before final pin assignment optimization"
```

**CRITICAL Behavior (waivers.value=0):**
- NOTE: Type 2 has NO waiver logic. waive=0 is forced PASS mode only
- IMPORTANT: waive_items uses PLAIN STRINGS (NOT name/reason dict like Type 3/4!)
- waive_items serves as COMMENT ONLY (no matching/filtering logic)
- waive_items content printed as INFO with [WAIVED_INFO] tag
- ALL errors/mismatches force converted: ERROR‚ÜíPASS, displayed as INFO with [WAIVED_AS_INFO] tag
- Check ALWAYS returns PASS (errors shown as INFO for tracking)
- Used when: Pattern check is informational, mismatches expected

**Sample Output (PASS with mismatches):**
```
Status: PASS  # Always PASS when waivers.value=0
Reason: All mismatches waived as informational
INFO01 ([WAIVED_INFO] - waive_items as comment):
  - "Explanation: Port placement check is informational during floorplanning phase"
  - "Note: Unplaced ports are expected before final pin assignment optimization"
INFO02 ([WAIVED_AS_INFO] - errors converted to PASS, shown as INFO):
  - rxda_cdrlf_scanmode: Unplaced [WAIVED_AS_INFO]
  - e_pi_ctrl[0]: NOT ON ROUTING TRACK [WAIVED_AS_INFO]
```

---

## Type 3: Value Check with Waiver Logic

**Configuration (copy to item_data.yaml for testing):**
```yaml
IMP-8-0-0-01:
  description: "Confirm all ports are assigned on metal track."
  requirements:
    value: 3
    pattern_items:
      - "rxda_cdrlf_scanmode"
      - "rxda_cdrlf_scanout[0]"
      - "e_pi_ctrl[0]"
  input_files:
    - "reports/8.0/IMP-8-0-0-01/IMP-8-0-0-01_case1.rpt"
  waivers:
    value: 2
    waive_items:
      - name: "rxda_cdrlf_scanmode"
        reason: "Waived - scan mode port placement deferred to post-CTS optimization"
      - name: "e_pi_ctrl[63]"
        reason: "Waived - debug port, non-critical timing path"
```

**Check Behavior:**
Type 3 = Type 2 + waiver support.
Same pattern search logic as Type 2, plus waiver classification:
- Match found_items (violations) against waive_items by port name
- Unwaived violations ‚Üí ERROR (need fix)
- Waived violations ‚Üí INFO with [WAIVER] tag (approved)
- Unused waivers ‚Üí WARN with [WAIVER] tag
PASS if all found_items (violations) are waived.

**Sample Output (with waived items):**
```
Status: PASS
Reason: All violations waived
INFO01 (Waived):
  - rxda_cdrlf_scanmode: Port placement violation waived per design review: Waived - scan mode port placement deferred to post-CTS optimization [WAIVER]
WARN01 (Unused Waivers):
  - e_pi_ctrl[63]: Waiver not matched - no corresponding port placement violation found: Waived - debug port, non-critical timing path [WAIVER]
```

**Sample Output (with unwaived violations):**
```
Status: FAIL
Reason: Port placement requirements not satisfied - routing track violations detected
ERROR01:
  - e_pi_ctrl[0]: Port placement requirements not satisfied - routing track violations detected: NOT ON ROUTING TRACK
INFO01 (Waived):
  - rxda_cdrlf_scanmode: Port placement violation waived per design review: Waived - scan mode port placement deferred to post-CTS optimization [WAIVER]
WARN01 (Unused Waivers):
  - e_pi_ctrl[63]: Waiver not matched - no corresponding port placement violation found: Waived - debug port, non-critical timing path [WAIVER]
```

---

## Type 4: Boolean Check with Waiver Logic

**Configuration (copy to item_data.yaml for testing):**
```yaml
IMP-8-0-0-01:
  description: "Confirm all ports are assigned on metal track."
  requirements:
    value: N/A
    pattern_items: []
  input_files:
    - "reports/8.0/IMP-8-0-0-01/IMP-8-0-0-01_case1.rpt"
  waivers:
    value: 2
    waive_items:
      - name: "rxda_cdrlf_scanmode"
        reason: "Waived - scan mode port placement deferred to post-CTS optimization"
      - name: "e_pi_ctrl[63]"
        reason: "Waived - debug port, non-critical timing path"
```

‚ö†Ô∏è CRITICAL: Type 4 waive_items MUST be IDENTICAL to Type 3 waive_items!
- After generating Type 3 configuration, COPY the EXACT waive_items to Type 4
- Use the SAME name values from Type 3 (port names to exempt)
- Use the SAME reason text from Type 3
- This ensures consistency since Type 3 and Type 4 use identical waiver logic

**Check Behavior:**
Type 4 = Type 1 + waiver support.
Same boolean check as Type 1 (no pattern_items), plus waiver classification:
- Match violations against waive_items by port name
- Unwaived violations ‚Üí ERROR
- Waived violations ‚Üí INFO with [WAIVER] tag
- Unused waivers ‚Üí WARN with [WAIVER] tag
PASS if all violations are waived.

**Sample Output (all violations waived):**
```
Status: PASS
Reason: All items waived
INFO01 (Waived):
  - rxda_cdrlf_scanmode: Port placement violation waived per design review: Waived - scan mode port placement deferred to post-CTS optimization [WAIVER]
WARN01 (Unused Waivers):
  - e_pi_ctrl[63]: Waiver not matched - no corresponding port placement violation found: Waived - debug port, non-critical timing path [WAIVER]
```

**Sample Output (with unwaived violations):**
```
Status: FAIL
Reason: Ports not found on metal routing tracks - placement verification failed
ERROR01:
  - e_pi_ctrl[0]: Ports not found on metal routing tracks - placement verification failed: NOT ON ROUTING TRACK
  - rxda_cdrlf_scanout[0]: Ports not found on metal routing tracks - placement verification failed: Unplaced
INFO01 (Waived):
  - rxda_cdrlf_scanmode: Port placement violation waived per design review: Waived - scan mode port placement deferred to post-CTS optimization [WAIVER]
WARN01 (Unused Waivers):
  - e_pi_ctrl[63]: Waiver not matched - no corresponding port placement violation found: Waived - debug port, non-critical timing path [WAIVER]
```

---

## Testing

### Test Commands

```powershell
# Create test snapshots for all types
python common/regression_testing/create_all_snapshots.py --modules 8.0_PHYSICAL_IMPLEMENTATION_CHECK --checkers IMP-8-0-0-01 --force

# Run individual tests
python IMP-8-0-0-01.py
```

---

## Notes

**Limitations:**
- Checker relies on specific Cadence Innovus report format (checkPinAssignment command output)
- Bus notation must be preserved exactly as in report (e.g., `port[0]` not `port_0`)
- Multiple files are aggregated; design name mismatches across files are logged but not enforced

**Known Issues:**
- If report contains non-standard violation types beyond "Unplaced Pins" and "NOT ON ROUTING TRACK", they may not be detected
- Route blockage warnings are counted but not individually tracked by port name

**Best Practices:**
- Run checkPinAssignment after initial placement and before routing
- Review OVERLAPPED WITH ROUTE BLOCKAGE warnings separately (may indicate floorplan issues)
- Use Type 3/4 waivers for known exceptions (e.g., scan ports, debug signals)
- For early design stages, use waivers.value=0 to track violations without failing the check