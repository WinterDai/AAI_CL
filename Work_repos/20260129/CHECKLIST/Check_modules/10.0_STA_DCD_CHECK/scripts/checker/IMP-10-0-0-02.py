################################################################################
# Script Name: IMP-10-0-0-02.py
#
# Purpose:
#   Confirm the clock uncertainty setting is correct.
#   Parse constraint report (constr.rpt) to verify set_clock_uncertainty commands.
#
# Logic:
#   - Parse constr.rpt to extract set_clock_uncertainty commands
#   - Extract metadata (tool version, generation date, design name)
#   - Verify existence and content consistency with expected patterns
#   - Support waiver for missing or mismatched constraints
#
# Auto Type Detection:
#   Type 1: requirements.value=N/A, waivers.value=N/A/0 → Boolean check
#   Type 2: requirements.value>0, pattern_items exists, waivers.value=N/A/0 → Value comparison
#   Type 3: requirements.value>0, pattern_items exists, waivers.value>0 → Value with waiver logic
#   Type 4: requirements.value=N/A, waivers.value>0 → Boolean with waiver logic
#
# Waiver Tag Rules:
#   When waivers.value > 0 (Type 3/4):
#     - All waive_items related INFO/FAIL/WARN reason suffix: [WAIVER]
#   When waivers.value = 0 (Type 1/2):
#     - waive_items output as INFO with suffix: [WAIVED_INFO]
#     - FAIL/WARN converted to INFO with suffix: [WAIVED_AS_INFO]
#   All types support value = N/A
#
# Author: yyin
# Date: 2025-12-08
# Refactored: 2025-12-10 (Using checker_templates - WaiverHandlerMixin & OutputBuilderMixin)
################################################################################

from pathlib import Path
import re
import sys
from typing import List, Dict, Tuple, Optional, Any


# Add common module to path
_SCRIPT_DIR = Path(__file__).resolve().parent
_CHECK_MODULES_DIR = _SCRIPT_DIR.parents[2]  # Go up to Check_modules/
_COMMON_DIR = _CHECK_MODULES_DIR / 'common'
if str(_COMMON_DIR) not in sys.path:
    sys.path.insert(0, str(_COMMON_DIR))

from base_checker import BaseChecker, CheckResult, ConfigurationError
from output_formatter import DetailItem, Severity, create_check_result
from checker_templates.input_file_parser_template import InputFileParserMixin
from checker_templates.waiver_handler_template import WaiverHandlerMixin
from checker_templates.output_builder_template import OutputBuilderMixin


class ClockUncertaintyChecker(BaseChecker, InputFileParserMixin, WaiverHandlerMixin, OutputBuilderMixin):
    """
    Unified checker that auto-detects and handles all 4 checker types.
    
    Check Target: Confirm the clock uncertainty setting is correct
    
    Type Detection Logic:
    - Type 1: requirements.value=N/A AND waivers.value=N/A/0
    - Type 2: requirements.value>0 AND pattern_items AND waivers.value=N/A/0
    - Type 3: requirements.value>0 AND pattern_items AND waivers.value>0
    - Type 4: requirements.value=N/A AND waivers.value>0
    """
    
    def __init__(self):
        super().__init__(
            check_module="10.0_STA_DCD_CHECK",
            item_id="IMP-10-0-0-02",
            item_desc="Confirm the clock uncertainty setting is correct."
        )
        self._metadata: Dict[str, Any] = {}
        self._uncertainty_commands: List[Dict[str, Any]] = []
    
    def _parse_file_metadata(self, file_path: Path) -> Dict[str, str]:
        """
        Extract metadata from constraint report file header.
        
        Expected format:
        #  Generated by:      Cadence Tempus 24.10-d063_1
        #  Generated on:      Mon Dec  1 12:34:31 2025
        #  Design:            phy_cmn_phase_align_digtop
        
        Returns:
            Dict with keys: tool, date, design
        """
        metadata = {
            'tool': '',
            'date': '',
            'design': ''
        }
        
        if not file_path.exists():
            return metadata
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    # Extract tool version
                    if 'Generated by:' in line:
                        match = re.search(r'Generated by:\s+(.+)', line)
                        if match:
                            metadata['tool'] = match.group(1).strip()
                    
                    # Extract generation date
                    elif 'Generated on:' in line:
                        match = re.search(r'Generated on:\s+(.+)', line)
                        if match:
                            metadata['date'] = match.group(1).strip()
                    
                    # Extract design name
                    elif 'Design:' in line:
                        match = re.search(r'Design:\s+(\S+)', line)
                        if match:
                            metadata['design'] = match.group(1).strip()
                    
                    # Stop after header section
                    if line.strip() and not line.strip().startswith('#'):
                        break
        except Exception as e:
            print(f"Warning: Failed to read metadata from {file_path}: {e}")
        
        return metadata
    
    def _parse_clock_uncertainty(self, file_path: Path) -> List[Dict[str, Any]]:
        """
        Parse set_clock_uncertainty commands from constraint report.
        
        Expected format:
        set_clock_uncertainty 0.055 -setup -from [get_clocks { PHASE_ALIGN_CLOCK}] -to [get_clocks {PHASE_ALIGN_CLOCK}]
        set_clock_uncertainty 0.02 -hold -from [get_clocks { PHASE_ALIGN_CLOCK}] -to [get_clocks {PHASE_ALIGN_CLOCK}]
        
        Returns:
            List of dicts with keys:
            - line_number: Line number in file
            - raw_command: Original command string
            - normalized_command: Normalized command for matching
            - value: Uncertainty value (float)
            - type: setup/hold
            - from_clock: Source clock name
            - to_clock: Destination clock name
        """
        commands = []
        
        if not file_path.exists():
            return commands
        
        # Pattern to match set_clock_uncertainty commands
        pattern = r'set_clock_uncertainty\s+([\d\.]+)\s+-(setup|hold)\s+-from\s+\[get_clocks\s+\{([^}]+)\}\]\s+-to\s+\[get_clocks\s+\{([^}]+)\}\]'
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                for line_num, line in enumerate(f, 1):
                    # Skip comments
                    if line.strip().startswith('#'):
                        continue
                    
                    # Check if line contains set_clock_uncertainty
                    if 'set_clock_uncertainty' in line:
                        match = re.search(pattern, line)
                        if match:
                            value = float(match.group(1))
                            constraint_type = match.group(2)  # setup or hold
                            from_clock = match.group(3).strip()
                            to_clock = match.group(4).strip()
                            
                            commands.append({
                                'line_number': line_num,
                                'raw_command': line.strip(),
                                'normalized_command': self.normalize_command(line.strip()),
                                'value': value,
                                'type': constraint_type,
                                'from_clock': from_clock,
                                'to_clock': to_clock
                            })
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        
        return commands
    
    def _parse_input_files(self) -> Dict[str, Any]:
        """
        Parse input files to extract clock uncertainty information.
        Required by BaseChecker.
        
        Returns:
            Dict with keys:
            - uncertainty_commands: List of command dicts
            - file_metadata: Dict with file info
            - errors: List of error strings
        """
        uncertainty_commands = []
        file_metadata = {}
        errors = []
        
        # Validate input files using BaseChecker method
        valid_files, missing_files = self.validate_input_files()
        
        if missing_files:
            raise ConfigurationError(
                self.create_missing_files_error(missing_files)
            )
        
        if not valid_files:
            return {
                'uncertainty_commands': [],
                'file_metadata': {},
                'errors': ['No valid input files found']
            }
        
        # Process each input file
        for file_path in valid_files:
            # Parse file metadata
            file_metadata = self._parse_file_metadata(file_path)
            file_metadata['file_path'] = str(file_path)
            
            # Parse clock uncertainty commands
            commands = self._parse_clock_uncertainty(file_path)
            uncertainty_commands.extend(commands)
        
        return {
            'uncertainty_commands': uncertainty_commands,
            'file_metadata': file_metadata,
            'errors': errors
        }
    
    def _execute_type1(self) -> CheckResult:
        """
        Type 1: Boolean check with automatic waiver.value=0 support
        
        Check if set_clock_uncertainty commands exist.
        
        Waiver Logic (Automatic):
        - waiver.value = 0: Auto-convert FAIL→INFO, force PASS [WAIVED_AS_INFO]
                           Auto-parse waive_items and output as INFO [WAIVED_INFO]
        - waiver.value = N/A: Normal mode
        """
        parsed_data = self._parse_input_files()
        uncertainty_commands = parsed_data['uncertainty_commands']
        file_metadata = parsed_data['file_metadata']
        errors = parsed_data['errors']
        
        # Build found_items dict (commands with metadata)
        found_items = {}
        for cmd in uncertainty_commands:
            found_items[cmd['normalized_command']] = {
                'line_number': cmd['line_number'],
                'file_path': file_metadata.get('file_path', ''),
                'uncertainty_value': cmd['value'],
                'type': cmd['type'],
                'from_clock': cmd['from_clock'],
                'to_clock': cmd['to_clock']
            }
        
        # Build missing_items (if no commands or errors)
        missing_items = []
        if not uncertainty_commands:
            missing_items.append("No set_clock_uncertainty command found")
        if errors:
            missing_items.extend([f"Error: {err}" for err in errors])
        
        # Use automatic waiver handling in build_complete_output
        return self.build_complete_output(
            found_items=found_items,
            missing_items=missing_items,
            value=len(uncertainty_commands),
            default_file=file_metadata.get('file_path', ''),
            found_reason="Clock uncertainty setting found",
            missing_reason="No clock uncertainty settings in constraint report",
            waived_base_reason="Clock uncertainty waived item",
            found_desc="Clock uncertainty settings found",
            missing_desc="Clock uncertainty settings not found"
        )
    
    def _execute_type2(self) -> CheckResult:
        """
        Type 2: Value comparison with automatic waiver.value=0 support
        
        Match required items in pattern_items against found commands.
        Expected value = number of items that should match.
        
        Waiver Logic (Automatic):
        - waiver.value = 0: Auto-convert FAIL/WARN→INFO, force PASS [WAIVED_AS_INFO]
                           Auto-parse waive_items and output as INFO [WAIVED_INFO]
        - waiver.value = N/A: Normal mode
        
        Special: Extra items (not in pattern_items) output as WARN
        """
        parsed_data = self._parse_input_files()
        uncertainty_commands = parsed_data['uncertainty_commands']
        file_metadata = parsed_data['file_metadata']
        errors = parsed_data['errors']
        
        requirements = self.get_requirements()
        pattern_items = requirements.get('pattern_items', []) if requirements else []
        
        # Track which patterns are matched
        matched_patterns = set()
        found_items = {}
        extra_items = {}  # Commands not in pattern_items
        
        # Match each command against patterns
        # Convert pattern_items list to dict format for match_waiver_entry
        pattern_dict = {p: '' for p in pattern_items}
        
        for cmd in uncertainty_commands:
            matched_pattern = self.match_waiver_entry(
                item=cmd['normalized_command'],
                waive_dict=pattern_dict,
                normalizer=self.normalize_command,
                case_sensitive=False
            )
            if matched_pattern:
                matched_patterns.add(matched_pattern)
                found_items[cmd['normalized_command']] = {
                    'line_number': cmd['line_number'],
                    'file_path': file_metadata.get('file_path', ''),
                    'matched_pattern': matched_pattern,
                    'uncertainty_value': cmd['value'],
                    'type': cmd['type'],
                    'from_clock': cmd['from_clock'],
                    'to_clock': cmd['to_clock']
                }
            else:
                # Command exists but not in pattern_items - needs review
                extra_items[cmd['normalized_command']] = {
                    'line_number': cmd['line_number'],
                    'file_path': file_metadata.get('file_path', ''),
                    'uncertainty_value': cmd['value'],
                    'type': cmd['type'],
                    'from_clock': cmd['from_clock'],
                    'to_clock': cmd['to_clock']
                }
        
        # Find unmatched patterns
        missing_items = [p for p in pattern_items if p not in matched_patterns]
        
        # Add errors to missing
        if errors:
            missing_items.extend([f"Error: {err}" for err in errors])
        
        # Use automatic waiver handling with extra_items support
        return self.build_complete_output(
            found_items=found_items,
            missing_items=missing_items,
            extra_items=extra_items,
            value=len(found_items),
            has_pattern_items=True,
            default_file=file_metadata.get('file_path', ''),
            found_reason="clock uncertainty setting is correct and as expected",
            missing_reason="Required clock uncertainty setting not found",
            waived_base_reason="Clock uncertainty waived item",
            extra_reason="Unexpected clock uncertainty setting found and needs to be reviewed",
            found_desc="Clock uncertainty settings correct",
            missing_desc="Required clock uncertainty missing",
            extra_desc="Unexpected clock uncertainty settings need review"
        )
    
    def _execute_type3(self) -> CheckResult:
        """
        Type 3: Value comparison with waiver logic
        
        Match required items in pattern_items, allow waiving missing items.
        Expected value = number of items that should be found (excluding waived items).
        """
        parsed_data = self._parse_input_files()
        uncertainty_commands = parsed_data['uncertainty_commands']
        file_metadata = parsed_data['file_metadata']
        errors = parsed_data['errors']
        
        requirements = self.get_requirements()
        pattern_items = requirements.get('pattern_items', []) if requirements else []
        
        # Get waive items and reasons from WaiverHandlerMixin
        waive_items_dict = self.get_waive_items_with_reasons()
        
        # Track which patterns are matched
        matched_patterns = set()
        found_items = {}
        extra_items = {}  # Commands not in pattern_items
        waived_extra_items = {}  # Extra items that are waived
        used_waivers = set()
        
        # Match each command against patterns
        # Convert pattern_items list to dict format for match_waiver_entry
        pattern_dict = {p: '' for p in pattern_items}
        
        for cmd in uncertainty_commands:
            matched_pattern = self.match_waiver_entry(
                item=cmd['normalized_command'],
                waive_dict=pattern_dict,
                normalizer=self.normalize_command,
                case_sensitive=False
            )
            if matched_pattern:
                matched_patterns.add(matched_pattern)
                found_items[cmd['normalized_command']] = {
                    'line_number': cmd['line_number'],
                    'file_path': file_metadata.get('file_path', ''),
                    'matched_pattern': matched_pattern,
                    'uncertainty_value': cmd['value'],
                    'type': cmd['type'],
                    'from_clock': cmd['from_clock'],
                    'to_clock': cmd['to_clock']
                }
            else:
                # Command exists but not in pattern_items - check if waived
                extra_items[cmd['normalized_command']] = {
                    'line_number': cmd['line_number'],
                    'file_path': file_metadata.get('file_path', ''),
                    'uncertainty_value': cmd['value'],
                    'type': cmd['type'],
                    'from_clock': cmd['from_clock'],
                    'to_clock': cmd['to_clock']
                }
        
        # Find unmatched patterns
        unmatched_patterns = [p for p in pattern_items if p not in matched_patterns]
        
        # Check extra_items against waive_items to filter out waived extras
        waived_extra_reasons = {}  # Map extra item to reason
        unwaived_extra_items = {}
        
        for extra_cmd, meta in extra_items.items():
            matched_waiver = self.match_waiver_entry(
                item=extra_cmd,
                waive_dict=waive_items_dict,
                normalizer=self.normalize_command
            )

            if matched_waiver:
                waived_extra_items[extra_cmd] = meta
                waived_extra_reasons[extra_cmd] = waive_items_dict.get(matched_waiver, '')
                if matched_waiver:
                    used_waivers.add(matched_waiver)
            else:
                unwaived_extra_items[extra_cmd] = meta
        
        # Classify unmatched as waived/unwaived using pattern matching
        unwaived_missing = []
        waived_items_list = []
        used_waivers = set()
        used_waivers = set()
        waived_items_reasons = {}  # Map pattern to reason
        
        for pattern in unmatched_patterns:
            matched_waiver = self.match_waiver_entry(
                item=pattern,
                waive_dict=waive_items_dict,
                normalizer=self.normalize_command
            )

            if matched_waiver:
                waived_items_list.append(pattern)
                waived_items_reasons[pattern] = waive_items_dict.get(matched_waiver, '')
                used_waivers.add(matched_waiver)
            else:
                unwaived_missing.append(pattern)
        
        # Find unused waivers
        unused_waivers = [w for w in waive_items_dict.keys() if w not in used_waivers]
        
        # Add errors to missing
        if errors:
            unwaived_missing.extend([f"Error: {err}" for err in errors])
        
        # Build extra_items list (unwaived only for WARN outputs)
        extra_items_list = list(unwaived_extra_items.keys())
        
        # Manually build details to include all categories
        details = []
        
        # INFO: Found matched items
        for name in sorted(found_items.keys()):
            meta = found_items[name]
            details.append(DetailItem(
                severity=Severity.INFO,
                name=name,
                line_number=meta['line_number'],
                file_path=meta['file_path'],
                reason="clock uncertainty setting is correct and as expected"
            ))
        
        # INFO: Waived missing items
        for name in sorted(waived_items_list):
            waiver_reason = waived_items_reasons.get(name, '')
            if hasattr(self, 'format_waiver_reason'):
                reason = self.format_waiver_reason(
                    base_reason="Required clock uncertainty not found",
                    waiver_reason=waiver_reason,
                    add_tag=True
                )
            else:
                reason = f"Required clock uncertainty not found: {waiver_reason}[WAIVER]" if waiver_reason else "Required clock uncertainty not found[WAIVER]"
            details.append(DetailItem(
                severity=Severity.INFO,
                name=name,
                line_number=0,
                file_path=file_metadata.get('file_path', ''),
                reason=reason
            ))
        
        # INFO: Waived extra items
        for name in sorted(waived_extra_items.keys()):
            meta = waived_extra_items[name]
            waiver_reason = waived_extra_reasons.get(name, '')
            if hasattr(self, 'format_waiver_reason'):
                reason = self.format_waiver_reason(
                    base_reason="Unexpected clock uncertainty setting found",
                    waiver_reason=waiver_reason,
                    add_tag=True
                )
            else:
                reason = f"Unexpected clock uncertainty setting found: {waiver_reason}[WAIVER]" if waiver_reason else "Unexpected clock uncertainty setting found[WAIVER]"
            details.append(DetailItem(
                severity=Severity.INFO,
                name=name,
                line_number=meta['line_number'],
                file_path=meta['file_path'],
                reason=reason
            ))
        
        # FAIL: Unwaived missing items
        for name in sorted(unwaived_missing):
            details.append(DetailItem(
                severity=Severity.FAIL,
                name=name,
                line_number=0,
                file_path=file_metadata.get('file_path', ''),
                reason="Required clock uncertainty not found"
            ))
        
        # WARN: Unused waivers
        for name in sorted(unused_waivers):
            details.append(DetailItem(
                severity=Severity.WARN,
                name=name,
                line_number=0,
                file_path=file_metadata.get('file_path', ''),
                reason="Waived item not used[WAIVER]"
            ))
        
        # WARN: Extra items not in pattern_items (only unwaived)
        for name in sorted(unwaived_extra_items.keys()):
            meta = unwaived_extra_items[name]
            details.append(DetailItem(
                severity=Severity.WARN,
                name=name,
                line_number=meta['line_number'],
                file_path=meta['file_path'],
                reason="Unexpected clock uncertainty setting found and needs to be reviewed"
            ))
        
        # Build groups
        groups = self.build_result_groups(
            found_items=found_items,
            missing_items=unwaived_missing,
            waived_items=waived_items_list,
            unused_waivers=unused_waivers,
            found_desc="Clock uncertainty settings correct",
            missing_desc="Required clock uncertainty missing",
            waived_desc="Waived clock uncertainty patterns",
            unused_desc="Unused waivers"
        )
        
        # Add info group for waived extra items so logs capture them explicitly
        if waived_extra_items:
            info_groups = groups.setdefault('info_groups', {})
            info_key = f"INFO{len(info_groups) + 1:02d}"
            info_groups[info_key] = {
                "description": "Waived unexpected clock uncertainty settings",
                "items": list(waived_extra_items.keys())
            }

        # Add warn group for unwaived extra items only
        extra_items_list = list(unwaived_extra_items.keys())
        if extra_items_list:
            if 'warn_groups' not in groups:
                groups['warn_groups'] = {}
            # Append to existing warn groups
            warn_key = f"WARN{len(groups['warn_groups']) + 1:02d}"
            groups['warn_groups'][warn_key] = {
                "description": "Unexpected clock uncertainty settings need review",
                "items": extra_items_list
            }
        
        return self.build_check_result(
            value=len(found_items),
            is_pass=len(unwaived_missing) == 0,
            details=details,
            has_pattern_items=True,
            has_waiver_value=True,
            **groups
        )
    
    def _execute_type4(self) -> CheckResult:
        """
        Type 4: Boolean check with waiver logic
        
        Check if set_clock_uncertainty commands exist.
        Allow waiving if not found.
        """
        parsed_data = self._parse_input_files()
        uncertainty_commands = parsed_data['uncertainty_commands']
        file_metadata = parsed_data['file_metadata']
        errors = parsed_data['errors']
        
        # Get waive items and reasons from WaiverHandlerMixin
        waive_items_dict = self.get_waive_items_with_reasons()
        
        # Build found_items (commands exist)
        found_items = {}
        for cmd in uncertainty_commands:
            found_items[cmd['normalized_command']] = {
                'line_number': cmd['line_number'],
                'file_path': file_metadata.get('file_path', ''),
                'uncertainty_value': cmd['value'],
                'type': cmd['type'],
                'from_clock': cmd['from_clock'],
                'to_clock': cmd['to_clock']
            }
        
        # Build missing/waived items (no commands)
        missing_items = []
        waived_items_list = []
        used_waivers = set()
        
        if not uncertainty_commands:
            # Check if "no clock uncertainty" is waived
            no_uncertainty_waived = False
            for waiver_key in waive_items_dict.keys():
                waiver_norm = waiver_key.lower()
                if 'no' in waiver_norm and 'clock' in waiver_norm and 'uncertainty' in waiver_norm:
                    no_uncertainty_waived = True
                    waived_items_list.append("No set_clock_uncertainty command found")
                    used_waivers.add(waiver_key)
                    break
            
            if not no_uncertainty_waived:
                missing_items.append("No set_clock_uncertainty command found")
        
        # Detect unused waivers (anything not matched above)
        unused_waivers = [w for w in waive_items_dict.keys() if w not in used_waivers]

        # Add errors
        if errors:
            missing_items.extend([f"Error: {err}" for err in errors])
        
        return self.build_complete_output(
            found_items=found_items,
            missing_items=missing_items,
            waived_items=waived_items_list,
            waive_dict=waive_items_dict,
            unused_waivers=unused_waivers,
            value='N/A',
            has_waiver_value=True,
            default_file=file_metadata.get('file_path', ''),
            found_reason="Clock uncertainty setting found",
            missing_reason="No clock uncertainty settings in constraint report",
            waived_base_reason="No clock uncertainty settings",
            found_desc="Clock uncertainty settings found",
            missing_desc="Clock uncertainty settings not found",
            waived_desc="Clock uncertainty check waived",
            unused_desc="Configured waivers not applied",
            unused_waiver_reason="Waiver configured and not used"
        )
    
    def execute_check(self) -> CheckResult:
        """
        Execute the check by auto-detecting type and calling appropriate method.
        
        Returns:
            CheckResult object containing check results
        """
        try:
            if self.root is None:
                raise RuntimeError("Checker not initialized. Call init_checker() first.")
            
            # Detect checker type (use BaseChecker method)
            checker_type = self.detect_checker_type()
            
            # Execute based on type
            if checker_type == 1:
                return self._execute_type1()
            elif checker_type == 2:
                return self._execute_type2()
            elif checker_type == 3:
                return self._execute_type3()
            else:  # checker_type == 4
                return self._execute_type4()
        except ConfigurationError as e:
            return e.check_result


if __name__ == '__main__':
    checker = ClockUncertaintyChecker()
    checker.run()
