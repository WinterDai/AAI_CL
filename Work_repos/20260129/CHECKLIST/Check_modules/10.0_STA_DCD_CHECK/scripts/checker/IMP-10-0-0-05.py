################################################################################
# Script Name: IMP-10-0-0-05.py
#
# Purpose:
#   Confirm all clocks propagated during STA.
#   Parse clocks report to verify all clocks have Propagated=y.
#
# Logic:
#   - Parse clocks.rpt to extract clock names and propagation status
#   - Extract metadata (tool version, generation date, design name)
#   - Verify all clocks are propagated (Propagated = y)
#   - Support waiver for clocks that are allowed to be non-propagated
#
# Auto Type Detection:
#   Type 1: requirements.value=N/A, waivers.value=N/A/0 → Boolean check (all propagated)
#   Type 2: requirements.value>0, pattern_items exists, waivers.value=N/A/0 → Value comparison
#   Type 3: requirements.value>0, pattern_items exists, waivers.value>0 → Value with waiver logic
#   Type 4: requirements.value=N/A, waivers.value>0 → Boolean with waiver logic
#
# Waiver Tag Rules:
#   When waivers.value > 0 (Type 3/4):
#     - All waive_items related INFO/FAIL/WARN reason suffix: [WAIVER]
#   When waivers.value = 0 (Type 1/2):
#     - waive_items output as INFO with suffix: [WAIVED_INFO]
#     - FAIL/WARN converted to INFO with suffix: [WAIVED_AS_INFO]
#   All types support value = N/A
#
# Author: yyin
# Date: 2025-12-02
################################################################################

from pathlib import Path
import re
import sys
import gzip
from typing import List, Dict, Tuple, Optional, Any


# Add common module to path
_SCRIPT_DIR = Path(__file__).resolve().parent
_CHECK_MODULES_DIR = _SCRIPT_DIR.parents[2]  # Go up to Check_modules/
_COMMON_DIR = _CHECK_MODULES_DIR / 'common'
if str(_COMMON_DIR) not in sys.path:
    sys.path.insert(0, str(_COMMON_DIR))

from base_checker import BaseChecker, CheckResult, ConfigurationError
from output_formatter import DetailItem, Severity, create_check_result


class ClockPropagationChecker(BaseChecker):
    """
    Unified checker that auto-detects and handles all 4 checker types.
    
    Check Target: Confirm all clocks propagated during STA
    
    Type Detection Logic:
    - Type 1: requirements.value=N/A AND waivers.value=N/A/0
    - Type 2: requirements.value>0 AND pattern_items AND waivers.value=N/A/0
    - Type 3: requirements.value>0 AND pattern_items AND waivers.value>0
    - Type 4: requirements.value=N/A AND waivers.value>0
    """
    
    def __init__(self):
        super().__init__(
            check_module="10.0_STA_DCD_CHECK",
            item_id="IMP-10-0-0-05",
            item_desc="Confirm all clocks propagated during STA."
        )
        self._metadata: Dict[str, Any] = {}
        self._clocks: List[Dict[str, Any]] = []
    
    def _parse_file_metadata(self, file_path: Path) -> Dict[str, str]:
        """
        Extract metadata from clocks report file header.
        
        Returns:
            Dict with keys: tool, os, date, design
        """
        metadata = {
            'tool': '',
            'os': '',
            'date': '',
            'design': ''
        }
        
        if not file_path.exists():
            return metadata
        
        try:
            # Try gzip first, fallback to plain text
            try:
                with gzip.open(file_path, 'rt', encoding='utf-8', errors='ignore') as f:
                    lines = [f.readline() for _ in range(10)]
            except (gzip.BadGzipFile, OSError):
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = [f.readline() for _ in range(10)]
            
            for line in lines:
                if 'Generated by:' in line:
                    match = re.search(r'Generated by:\s+(.+)', line)
                    if match:
                        metadata['tool'] = match.group(1).strip()
                elif 'OS:' in line:
                    match = re.search(r'OS:\s+(.+)', line)
                    if match:
                        metadata['os'] = match.group(1).strip()
                elif 'Generated on:' in line:
                    match = re.search(r'Generated on:\s+(.+)', line)
                    if match:
                        metadata['date'] = match.group(1).strip()
                elif 'Design:' in line:
                    match = re.search(r'Design:\s+(\S+)', line)
                    if match:
                        metadata['design'] = match.group(1).strip()
        except Exception as e:
            print(f"Warning: Failed to read metadata from {file_path}: {e}")
        
        return metadata
    
    def _parse_clock_table(self, file_path: Path) -> List[Dict[str, Any]]:
        """
        Parse clock table from clocks report.
        
        Returns:
            List of dicts with keys: name, source, view, period, generated, propagated, line_number
        """
        clocks = []
        
        if not file_path.exists():
            return clocks
        
        try:
            # Try gzip first, fallback to plain text
            try:
                with gzip.open(file_path, 'rt', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
            except (gzip.BadGzipFile, OSError):
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
            
            lines = content.split('\n')
            
            # Find the table header line
            header_line_idx = -1
            for i, line in enumerate(lines):
                if 'Clock Name' in line and 'Propagated' in line:
                    header_line_idx = i
                    break
            
            if header_line_idx == -1:
                return clocks
            
            # Parse table rows (skip header and separator lines)
            in_table = False
            for line_num, line in enumerate(lines[header_line_idx + 1:], start=header_line_idx + 2):
                # Skip separator lines
                if line.strip().startswith('---') or not line.strip():
                    if line.strip().startswith('---'):
                        in_table = True
                    continue
                
                # End of table if we hit another section
                if in_table and line.strip() and not line.strip().startswith('#'):
                    # Parse clock entry
                    parts = line.split()
                    
                    if len(parts) >= 8:
                        clock_name = parts[0].strip()
                        source = parts[1].strip()
                        
                        # Find period index
                        period_idx = -1
                        for idx, part in enumerate(parts[2:], start=2):
                            try:
                                float(part)
                                period_idx = idx
                                break
                            except ValueError:
                                continue
                        
                        if period_idx >= 2:
                            view = ' '.join(parts[2:period_idx])
                            period = parts[period_idx]
                            generated = parts[-2].strip().lower()
                            propagated = parts[-1].strip().lower()
                            
                            clocks.append({
                                'name': clock_name,
                                'source': source,
                                'view': view,
                                'period': period,
                                'generated': generated,
                                'propagated': propagated,
                                'line_number': line_num
                            })
                elif in_table:
                    break
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        
        return clocks
    
    def _parse_input_files(self) -> Tuple[List[Dict[str, Any]], Dict[str, str], List[str]]:
        """Parse input files to extract clock propagation information."""
        clocks = []
        file_metadata = {}
        errors = []
        
        if not self.item_data or 'input_files' not in self.item_data:
            raise ConfigurationError("No input_files specified in configuration")
        
        input_files = self.item_data.get('input_files', '')
        
        if not input_files:
            raise ConfigurationError("input_files is empty in configuration")
        
        if isinstance(input_files, str):
            input_files = [input_files]
        
        if not input_files:
            raise ConfigurationError("input_files list is empty after conversion")
        
        for file_path_str in input_files:
            file_path = Path(file_path_str)
            
            if not file_path.exists():
                raise ConfigurationError(f"Input file not found: {file_path}")
            
            file_metadata = self._parse_file_metadata(file_path)
            file_metadata['file_path'] = str(file_path)
            
            clock_list = self._parse_clock_table(file_path)
            clocks.extend(clock_list)
        
        return clocks, file_metadata, errors
    
    def _get_waive_items_with_reasons(self) -> Dict[str, str]:
        """Get waiver items with their reasons."""
        waivers = self.get_waivers()
        if not waivers:
            return {}
        
        waive_items = waivers.get('waive_items', [])
        
        if waive_items and isinstance(waive_items[0], dict):
            return {item['name']: item.get('reason', '') for item in waive_items}
        
        return {item: '' for item in waive_items}
    
    def _execute_type1(self, clocks: List[Dict[str, Any]], 
                       file_metadata: Dict[str, str], errors: List[str]) -> CheckResult:
        """Type 1: Boolean check - all clocks should be propagated."""
        waivers = self.get_waivers()
        is_waiver_zero = waivers and waivers.get('value') == 0
        waive_items_dict = self._get_waive_items_with_reasons()
        
        propagated_clocks = [c for c in clocks if c['propagated'] == 'y']
        not_propagated_clocks = [c for c in clocks if c['propagated'] == 'n']
        
        details = []
        
        if is_waiver_zero:
            # Forced PASS mode
            for clock in propagated_clocks:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock propagated[WAIVED_AS_INFO]"
                ))
            
            for clock in not_propagated_clocks:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated[WAIVED_AS_INFO]"
                ))
            
            for waive_item in waive_items_dict:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=waive_item,
                    line_number=0,
                    file_path='N/A',
                    reason="Waive item[WAIVED_INFO]"
                ))
            
            return create_check_result(
                value="N/A",
                is_pass=True,
                has_pattern_items=False,
                has_waiver_value=True,
                details=details,
                item_desc=self.item_desc,
                default_group_desc="Clock propagation check (forced PASS mode)"
            )
        else:
            # Normal mode
            if not_propagated_clocks:
                # FAIL
                for clock in not_propagated_clocks:
                    details.append(DetailItem(
                        severity=Severity.FAIL,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Clock not propagated"
                    ))
                
                for clock in propagated_clocks:
                    details.append(DetailItem(
                        severity=Severity.INFO,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Clock propagated"
                    ))
                
                return create_check_result(
                    value="N/A",
                    is_pass=False,
                    has_pattern_items=False,
                    has_waiver_value=False,
                    details=details,
                    item_desc=self.item_desc,
                    default_group_desc=f"Found {len(not_propagated_clocks)} clock(s) not propagated"
                )
            else:
                # PASS
                for clock in propagated_clocks:
                    details.append(DetailItem(
                        severity=Severity.INFO,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Clock propagated"
                    ))
                
                return create_check_result(
                    value="N/A",
                    is_pass=True,
                    has_pattern_items=False,
                    has_waiver_value=False,
                    details=details,
                    item_desc=self.item_desc,
                    default_group_desc="All clocks propagated"
                )
    
    def _execute_type2(self, clocks: List[Dict[str, Any]], 
                       file_metadata: Dict[str, str], errors: List[str]) -> CheckResult:
        """Type 2: Value comparison - check specific clocks are propagated."""
        requirements = self.get_requirements()
        waivers = self.get_waivers()
        pattern_items = requirements.get('pattern_items', [])
        is_waiver_zero = waivers and waivers.get('value') == 0
        waive_items_dict = self._get_waive_items_with_reasons()
        
        clock_dict = {clock['name']: clock for clock in clocks}
        
        matched_propagated = []
        matched_not_propagated = []
        missing = []
        
        for pattern in pattern_items:
            if pattern in clock_dict:
                clock = clock_dict[pattern]
                if clock['propagated'] == 'y':
                    matched_propagated.append(clock)
                else:
                    matched_not_propagated.append(clock)
            else:
                missing.append(pattern)
        
        actual_value = len(matched_propagated)
        details = []
        
        if is_waiver_zero:
            # Forced PASS mode
            for clock in matched_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock propagated[WAIVED_AS_INFO]"
                ))
            
            for clock in matched_not_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock not propagated[WAIVED_AS_INFO]"
                ))
            
            for pattern in missing:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=pattern,
                    line_number=0,
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock not found[WAIVED_AS_INFO]"
                ))
            
            for waive_item in waive_items_dict:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=waive_item,
                    line_number=0,
                    file_path='N/A',
                    reason="Waive item[WAIVED_INFO]"
                ))
            
            return create_check_result(
                value=actual_value,
                is_pass=True,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                item_desc=self.item_desc,
                default_group_desc="Clock propagation check (forced PASS mode)"
            )
        else:
            # Normal mode
            has_failure = len(matched_not_propagated) > 0 or len(missing) > 0
            
            if has_failure:
                # FAIL
                for clock in matched_not_propagated:
                    details.append(DetailItem(
                        severity=Severity.FAIL,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Expected clock not propagated"
                    ))
                
                for pattern in missing:
                    details.append(DetailItem(
                        severity=Severity.FAIL,
                        name=pattern,
                        line_number=0,
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Expected clock not found"
                    ))
                
                for clock in matched_propagated:
                    details.append(DetailItem(
                        severity=Severity.INFO,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Expected clock propagated"
                    ))
                
                return create_check_result(
                    value=actual_value,
                    is_pass=False,
                    has_pattern_items=True,
                    has_waiver_value=False,
                    details=details,
                    item_desc=self.item_desc,
                    default_group_desc="Clock propagation check failed"
                )
            else:
                # PASS
                for clock in matched_propagated:
                    details.append(DetailItem(
                        severity=Severity.INFO,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Expected clock propagated"
                    ))
                
                return create_check_result(
                    value=actual_value,
                    is_pass=True,
                    has_pattern_items=True,
                    has_waiver_value=False,
                    details=details,
                    item_desc=self.item_desc,
                    default_group_desc="All expected clocks propagated"
                )
    
    def _execute_type3(self, clocks: List[Dict[str, Any]], 
                       file_metadata: Dict[str, str], errors: List[str]) -> CheckResult:
        """Type 3: Value comparison with waiver logic."""
        requirements = self.get_requirements()
        waivers = self.get_waivers()
        pattern_items = requirements.get('pattern_items', [])
        waive_items_dict = self._get_waive_items_with_reasons()
        waive_items = list(waive_items_dict.keys())
        
        clock_dict = {clock['name']: clock for clock in clocks}
        
        expected_propagated = []
        expected_not_propagated = []
        expected_missing = []
        waived_not_propagated = []
        waived_propagated = []
        waived_missing = []
        unexpected_not_propagated = []
        
        # First pass: categorize pattern_items
        for pattern in pattern_items:
            if pattern in clock_dict:
                clock = clock_dict[pattern]
                if clock['propagated'] == 'y':
                    expected_propagated.append(clock)
                else:
                    # Check if this clock is waived
                    if pattern in waive_items:
                        # Will be handled in waiver section
                        pass
                    else:
                        expected_not_propagated.append(clock)
            else:
                expected_missing.append(pattern)
        
        # Second pass: categorize waive_items
        for waive_item in waive_items:
            if waive_item in clock_dict:
                clock = clock_dict[waive_item]
                if clock['propagated'] == 'n':
                    waived_not_propagated.append(clock)
                else:
                    waived_propagated.append(clock)
            else:
                waived_missing.append(waive_item)
        
        # Third pass: find unexpected non-propagated clocks
        for clock in clocks:
            if clock['propagated'] == 'n':
                if clock['name'] not in pattern_items and clock['name'] not in waive_items:
                    unexpected_not_propagated.append(clock)
        
        actual_value = len(expected_propagated)
        has_failure = len(expected_not_propagated) > 0 or len(expected_missing) > 0 or len(unexpected_not_propagated) > 0
        has_warning = len(waived_propagated) > 0 or len(waived_missing) > 0
        
        details = []
        error_groups = {}
        info_groups = {}
        warn_groups = {}
        
        if has_failure:
            # FAIL
            for clock in expected_not_propagated:
                details.append(DetailItem(
                    severity=Severity.FAIL,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock not propagated"
                ))
            
            for pattern in expected_missing:
                details.append(DetailItem(
                    severity=Severity.FAIL,
                    name=pattern,
                    line_number=0,
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock not found"
                ))
            
            for clock in unexpected_not_propagated:
                details.append(DetailItem(
                    severity=Severity.FAIL,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (not waived)"
                ))
            
            # Build error_groups with custom description
            fail_items = [c['name'] for c in expected_not_propagated] + expected_missing + [c['name'] for c in unexpected_not_propagated]
            if fail_items:
                error_groups['ERROR01'] = {
                    'description': 'Expected clock not propagated',
                    'items': fail_items
                }
            
            for clock in waived_propagated:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Waiver not used (clock is propagated)[WAIVER]"
                ))
            
            for waive_item in waived_missing:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=waive_item,
                    line_number=0,
                    file_path='N/A',
                    reason="Waiver not used (clock not found)[WAIVER]"
                ))
            
            # Build warn_groups for unused waivers
            warn_items = [c['name'] for c in waived_propagated] + waived_missing
            if warn_items:
                warn_groups['WARN01'] = {
                    'description': 'Waiver not used',
                    'items': warn_items
                }
            
            for clock in expected_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock propagated"
                ))
            
            for clock in waived_not_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (waived)[WAIVER]"
                ))
            
            # Build info_groups for waived items
            waived_items = [c['name'] for c in waived_not_propagated]
            if waived_items:
                info_groups['INFO01'] = {
                    'description': 'Expected clock not propagated but waived',
                    'items': waived_items
                }
            
            return create_check_result(
                value=actual_value,
                is_pass=False,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                error_groups=error_groups if error_groups else None,
                info_groups=info_groups if info_groups else None,
                warn_groups=warn_groups if warn_groups else None,
                item_desc=self.item_desc
            )
        elif has_warning:
            # PASS with WARNING
            for clock in waived_propagated:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Waiver not used (clock is propagated)[WAIVER]"
                ))
            
            for waive_item in waived_missing:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=waive_item,
                    line_number=0,
                    file_path='N/A',
                    reason="Waiver not used (clock not found)[WAIVER]"
                ))
            
            for clock in expected_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock propagated"
                ))
            
            for clock in waived_not_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (waived)[WAIVER]"
                ))
            
            return create_check_result(
                value=actual_value,
                is_pass=True,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                item_desc=self.item_desc,
                default_group_desc="Clock propagation check passed with warnings"
            )
        else:
            # PASS
            for clock in expected_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Expected clock propagated"
                ))
            
            for clock in waived_not_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (waived)[WAIVER]"
                ))
            
            return create_check_result(
                value=actual_value,
                is_pass=True,
                has_pattern_items=True,
                has_waiver_value=True,
                details=details,
                item_desc=self.item_desc,
                default_group_desc="All expected clocks propagated"
            )
    
    def _execute_type4(self, clocks: List[Dict[str, Any]], 
                       file_metadata: Dict[str, str], errors: List[str]) -> CheckResult:
        """Type 4: Boolean check with waiver logic."""
        waivers = self.get_waivers()
        waive_items_dict = self._get_waive_items_with_reasons()
        waive_items = list(waive_items_dict.keys())
        
        clock_dict = {clock['name']: clock for clock in clocks}
        
        propagated_clocks = []
        waived_not_propagated = []
        non_waived_not_propagated = []
        waived_but_propagated = []
        waived_missing = []
        
        for clock in clocks:
            if clock['propagated'] == 'y':
                propagated_clocks.append(clock)
                if clock['name'] in waive_items:
                    waived_but_propagated.append(clock)
            else:
                if clock['name'] in waive_items:
                    waived_not_propagated.append(clock)
                else:
                    non_waived_not_propagated.append(clock)
        
        for waive_item in waive_items:
            if waive_item not in clock_dict:
                waived_missing.append(waive_item)
        
        has_failure = len(non_waived_not_propagated) > 0
        has_warning = len(waived_but_propagated) > 0 or len(waived_missing) > 0
        
        details = []
        error_groups = {}
        info_groups = {}
        warn_groups = {}
        
        if has_failure:
            # FAIL
            for clock in non_waived_not_propagated:
                details.append(DetailItem(
                    severity=Severity.FAIL,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (no waiver)"
                ))
            
            # Build error_groups
            fail_items = [c['name'] for c in non_waived_not_propagated]
            if fail_items:
                error_groups['ERROR01'] = {
                    'description': 'Clock not propagated',
                    'items': fail_items
                }
            
            for clock in waived_but_propagated:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Waiver not used (clock is propagated)[WAIVER]"
                ))
            
            for waive_item in waived_missing:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=waive_item,
                    line_number=0,
                    file_path='N/A',
                    reason="Waiver not used (clock not found)[WAIVER]"
                ))
            
            # Build warn_groups for unused waivers
            warn_items = [c['name'] for c in waived_but_propagated] + waived_missing
            if warn_items:
                warn_groups['WARN01'] = {
                    'description': 'Waiver not used',
                    'items': warn_items
                }
            
            for clock in propagated_clocks:
                if clock not in waived_but_propagated:
                    details.append(DetailItem(
                        severity=Severity.INFO,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Clock propagated"
                    ))
            
            for clock in waived_not_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (waived)[WAIVER]"
                ))
            
            # Build info_groups for waived items
            waived_items = [c['name'] for c in waived_not_propagated]
            if waived_items:
                info_groups['INFO01'] = {
                    'description': 'Clock not propagated but waived',
                    'items': waived_items
                }
            
            return create_check_result(
                value="N/A",
                is_pass=False,
                has_pattern_items=False,
                has_waiver_value=True,
                details=details,
                error_groups=error_groups if error_groups else None,
                info_groups=info_groups if info_groups else None,
                warn_groups=warn_groups if warn_groups else None,
                item_desc=self.item_desc
            )
        elif has_warning:
            # PASS with WARNING
            for clock in waived_but_propagated:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Waiver not used (clock is propagated)[WAIVER]"
                ))
            
            for waive_item in waived_missing:
                details.append(DetailItem(
                    severity=Severity.WARN,
                    name=waive_item,
                    line_number=0,
                    file_path='N/A',
                    reason="Waiver not used (clock not found)[WAIVER]"
                ))
            
            for clock in propagated_clocks:
                if clock not in waived_but_propagated:
                    details.append(DetailItem(
                        severity=Severity.INFO,
                        name=clock['name'],
                        line_number=clock['line_number'],
                        file_path=file_metadata.get('file_path', 'N/A'),
                        reason="Clock propagated"
                    ))
            
            for clock in waived_not_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (waived)[WAIVER]"
                ))
            
            return create_check_result(
                value="N/A",
                is_pass=True,
                has_pattern_items=False,
                has_waiver_value=True,
                details=details,
                item_desc=self.item_desc,
                default_group_desc="All clocks propagated or waived (with warnings)"
            )
        else:
            # PASS
            for clock in propagated_clocks:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock propagated"
                ))
            
            for clock in waived_not_propagated:
                details.append(DetailItem(
                    severity=Severity.INFO,
                    name=clock['name'],
                    line_number=clock['line_number'],
                    file_path=file_metadata.get('file_path', 'N/A'),
                    reason="Clock not propagated (waived)[WAIVER]"
                ))
            
            return create_check_result(
                value="N/A",
                is_pass=True,
                has_pattern_items=False,
                has_waiver_value=True,
                details=details,
                item_desc=self.item_desc,
                default_group_desc="All clocks propagated or waived"
            )
    
    def execute_check(self) -> CheckResult:
        """Execute the clock propagation check."""
        # Parse input files (will raise ConfigurationError if file not found)
        clocks, file_metadata, errors = self._parse_input_files()
        
        self._clocks = clocks
        self._metadata = file_metadata
        
        # Execute based on checker type
        checker_type = self.detect_checker_type()
        
        if checker_type == 1:
            return self._execute_type1(clocks, file_metadata, errors)
        elif checker_type == 2:
            return self._execute_type2(clocks, file_metadata, errors)
        elif checker_type == 3:
            return self._execute_type3(clocks, file_metadata, errors)
        elif checker_type == 4:
            return self._execute_type4(clocks, file_metadata, errors)
        else:
            raise ConfigurationError(f"Unknown checker type: {checker_type}")


def main():
    """Main entry point for standalone testing."""
    checker = ClockPropagationChecker()
    checker.init_checker()
    result = checker.execute_check()
    checker.write_output(result)
    return 0 if result.is_pass else 1


if __name__ == "__main__":
    sys.exit(main())
